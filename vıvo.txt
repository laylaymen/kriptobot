✅ [1] VIVO Nihai Modül Listesi (Tam Liste + Gruplandırma)

Toplam 30 modül, 6 işlevsel grup.

🧭 A. Piyasa Duruşu & Plan Üretimi
Modül	Açıklama
marketPostureAdvisor.js (VIVO-01)	Risk-Açık/Nötr/Risk-Kapalı duruş + Plan A/B/C üretir.
signalHub.js (VIVO-00)	GB sinyallerini toplar, +%4 ve whitelist kapılarını uygular, skorlar.
planVariantGenerator.js	Aynı fikri 2–3 yürütme varyantına (agresif/temkinli) çevirir.
planFeasibilityChecker.js	Tick/lot/notional/limit ve allowedNotional’a göre uygulanabilirlik.
postureMemory.js	Son 7/30 günde duruş/sonuç hafızası, ağırlık güncelleme.
🧮 B. Sermaye Tahsisi & Portföy Politikalı Yürütme
Modül	Açıklama
strategyAllocator.js (VIVO-02)	Planı GB-60 tahsis kurallarıyla lot/çocuk-emre çevirir.
spotCashBalancer.js	Spot %30 hedefini (eşik sonrası) ve nakit dengesini korur.
exposureGuard.js	GB-69 limit/deny/trim kararlarına göre otomatik kısıtlama.
pyramidingOrchestrator.js	Trend yakalamada ekleme/çıkarma adımlarını sıraya koyar.
hedgeCoordinator.js	BTC/ETH/alt sepet koruma hedge’lerini planlar.
🔁 C. Operatör Etkileşimi & Onay Akışı
Modül	Açıklama
operatorDialog.js (VIVO-03)	Telegram/CLI: Plan A/B/C + evet/hayır, timeout→korumacı default.
optionCardBuilder.js	Planı okunur “kart”lara çevirir (notional, exec, risk, beklenen R).
explainabilityReporter.js	“Neden bu plan?” → kısa gerekçe & metrikler.
guardQuestionEngine.js	Kritik kapılarda (REDUCE_ONLY, +%4, whitelist) evet/hayır soruları.
rollbackPromptor.js	“Yanlış gidiyor” tespitinde geri alma/trim önerir.
📊 D. Canlı—BT Uyuşum & A/B Öğrenme
Modül	Açıklama
livePaperChooser.js	A/B kol seçimini yapar (mirror vs counterfactual oranı).
upliftEstimator.js	Plan A vs B kâr/ PF/ slipaj farkı ve güven aralığı.
driftGapWatcher.js	Live vs BT farkı ≤%20 izle; ihlalde alarm/plan düzeltme.
paramFeedbackWriter.js	WF (GB-72) paramlarına küçük düzeltmeleri geri yazar.
executionStyleSwitcher.js	IOC/TWAP/iceberg/post-only tercihlerini CFX sonuçlarına göre döndürür.
🛡️ E. Risk & Sentinellerle Uyum
Modül	Açıklama
sentinelCompliance.js	GB-61/70 durumlarına göre SLOWDOWN/ HALT/ CB uygulama.
drawdownStepDown.js	Gün-içi/haftalık DD’ye göre tahsisi kademeli düşür.
newsWindowTightener.js	GB-34 haber pencerelerinde otomatik sıkılaştırma.
liquidityAwareSizer.js	THICK/THIN likiditeye göre boyut/offset/iceberg ayarı.
capitalObjectiveRouter.js	Hedef: +%4/ PF>1.25/ MaxDD≤%15 optimizasyonunda öncelik.
🧰 F. Telemetri, Log & Test Köprüleri
Modül	Açıklama
actionEmitter.js	Seçilen planı GB-66/67’ye “ops.actions” olarak yollar.
auditTrailWriter.js	Neden-sonuç zinciri; idempotent journal.
vivoMetricsReporter.js	Plan başına PF, hit, avgR, slipaj, mark-out; 7/30g özet.
testHarnessAdapter.js	Entegre fuzz (GB-74) ve health (GB-75) testlerini tetikler.
configSanityChecker.js	Whitelist/+%4/spot %30 eşiklerinin yükleme testleri.
🔄 [2] Modüller Arası Veri Alışverişi Haritası (VIVO)
⇆ Grafik Beyni (GB)

Alır: Sinyal skorları (signalHub), WF paramları (GB-72), yürütme planı şablonları (GB-66/67), RiskNet/Health (GB-70/75).

Gönderir: Seçilen planın ops.actions çıktısı, A/B sonuçlarına dayalı param geri besleme (paramFeedbackWriter).

⇆ Otobilinç

Alır: adaptiveBiasShield uyarıları (riskli davranış halinde sinyal baskısı).

Gönderir: Operatör onayı sırasında “korumacı default” gerekçeleri ve uygulanan sınırlamalar.

⇆ LIVIA

Alır: Seri kayıp/ psikolojik risk durumunda “reduce-only/deny” sinyalleri.

Gönderir: Portföy konum değişiklikleri ve hedge koordinatları.

⇆ Denetim Asistanı

Gönderir: Postür kararları, reddedilen planlar, soru-cevap günlüğü, A/B uplift özetleri.

🧼 [3] Elenen VIVO Modülleri ve Gerekçeler
❌ Modül	Neden Elendi?	Asıl Sistemi
rawSignalGenerator.js	Sinyal üretimi GB’nin görevi.	Grafik Beyni
pnlAttributionCore.js	TCA/PnL ayrıştırma GB-36’da.	Grafik Beyni
deepRiskEngine.js	VaR/limit yönetimi GB-69/70’te.	GB RiskNet
behaviorOverrideKernel.js	Psikolojik baskılama Otobilinç’te.	Otobilinç
venueSwitcher.js	Çoklu borsa meta-router ileride GB-76.	Grafik Beyni (opsiyonel)
🧩 [4] Yeni VIVO Modül Önerileri (boşluk kapatma)

planSafetyNet.js – Onaydan sonra 60–180 sn içinde “mark-out < −X bp” ise otomatik trim/iptal.

scenarioPlaybookBinder.js – Senaryo (rejim/news/liquidity) ↔ plan şablonları eşleştirme matrisi.

operatorConsistencyScore.js – Operatör seçimlerinin tutarlılık ve performans skoru; öneri ağırlıklarını etkiler.

cashRunwayAdvisor.js – Spot/nakit akış planı (haftalık/aylık), çekme-yatırma önerileri.

dominanceShiftWatcher.js – BTC.D/ETH rel. güç kayması olduğunda Plan B’ye otomatik geçiş önerisi.

🧱 VIVO – Temel Kodlama Promptu (Birleşik V2+V3 Standardı)

Amaç: VIVO, sinyal→plan→tahsis→onay→eylem zincirinin “insan-seçimiyle uyumlu” orkestra katmanıdır. +%4 hedef, whitelist, spot %30 politikalarına her zaman uyar; GB risk/sentinel kapılarına öncelik verir.

Gerçek Dünya Kuralları:

Kapanmamış bar yok; modeled vs realized maliyetler dahil.

Binance filtreleri (tick/lot/notional/position/trailing/OCO), rate-limit/backoff.

RiskNet: AMBER→SLOWDOWN, RED→HALT/ CB + reduce-only.

Live-BT gap ≤ %20; A/B uplift ölçümü.

Arayüzler (TS) – örnek:

export interface VIVOPlan {
  id: "A"|"B"|"C"; title: string;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  trend?: { atrK:number; pyramid?:{maxAdds:number; addEveryPct:number; sizePct:number} };
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
}
export interface VIVOAsk { q: string; choices: string[]; default: string; timeoutSec: number; }
export interface VIVOOutput { posture:"RISK_ON"|"NEUTRAL"|"RISK_OFF"; plans: VIVOPlan[]; ask: VIVOAsk[]; }


Event Bus (pub-sub):

Publish: vivo.posture (VIVOOutput), ops.actions (seçilen plan), audit.log.

Subscribe: gb.signal, gb.health, gb.tca, ops.actions (geri bildirim), Otobilinç/LIVIA uyarıları.

Validasyon & Tip:

Girişte whitelist ve minTargetPct=4 zorunlu; exchangeInfo ile quantize.

Runtime guard (zod/ajv veya hafif guard) + TS tip güvenliği.

Hata & Logging:

{ code,message,details,retriable } formunda; merkezi logger + audit.log.

Idempotent aksiyonlar; aynı corrId tekrarı yutulur.

Test Planı:

Birim: plan üretimi, politika kapıları, sentinel etkisi, invalid sembol/ notional.

Entegrasyon: Plan A/B/C → strategyAllocator → actionEmitter zinciri; live-BT gap alarmı; Otobilinç baskı senaryosu.
_________________________________________________________________________________________________________________
VIVO-01 · marketPostureAdvisor.ts

Amaç (tek cümle):
Grafik Beyni + RiskNet + politika kapılarını (whitelist, +%4 hedef, spot %30) birleştirip günün duruşunu (Risk-Açık/Nötr/Risk-Kapalı) ve Plan A/B/C önerilerini üretir; operatöre onay soruları hazırlar.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; expectedMove/ATR kapanmış barlarla.

Slipaj/komisyon/funding etkileri (GB-22/36) plan notlarında dikkate alınır.

Binance kısıtları (tick/lot/notional/position) VIVO-02’de uygulanır; VIVO-01 yalnız uygulanabilirlik bayrağı ekler.

Risk sentinel (GB-61/70): AMBER→SLOWDOWN (temkinli varyant), RED/CB→Risk-Kapalı (reduce-only önerileri).

Politika: +%4 min hedef, whitelist 20 coin, spot %30 (equity eşiği sonrası).

Arayüzler (TypeScript/JSDoc)
// vivo/types.ts
export type ISODate = string;
export type Level = "GREEN"|"AMBER"|"RED";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface Policy {
  minTargetPct: number;           // >= 4
  whitelist: string[];            // 20-coin
  spot: { targetPct: number; equityThresholdUsd: number };
}

export interface RiskNetState {
  level: Level;                   // GB-70
  sentinel: "NORMAL"|"WATCH"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER"; // GB-61/75
}

export interface WFParams {
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  trend?: { atrK:number; pyramid?:{ maxAdds:number; addEveryPct:number; sizePct:number } };
}

export interface LedgerSnap {
  equityUsd: number; spotPct: number; ddPct: number;
}

export interface Dominance {
  btcD:number;            // proxy
  ethRel:number;          // ETH vs BTC güç
  altRet:number;          // alt sepet 1d getiri
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;    // TRIM/ALLOW için
}
export type ExposureMap = Record<string, ExposureGate>;

export interface AnalyticsRow {
  expectedMovePct:number; // kapanmış bar
  R_multiple:number;      // ≥1.2 tercih
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

// ---- VIVO-01 çıktıları ----
export interface VIVOPlan {
  id:"A"|"B"|"C"; title:string;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: WFParams["exec"];
  trend?: WFParams["trend"];
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
  applicability?: {                              // VIVO-02 için erken işaretler
    whitelistOk:boolean; minTargetOk:boolean; exposureOk:boolean;
  }
}
export interface VIVOAsk { q:string; choices:string[]; default:string; timeoutSec:number; }
export interface VIVOOutput {
  asOf:ISODate; posture:Posture; plans:VIVOPlan[]; ask:VIVOAsk[]; audit:string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

export interface VIVO01Input {
  risk: RiskNetState;
  wf: WFParams;
  ledger: LedgerSnap;
  dominance: Dominance;
  policy: Policy;
  exposure: ExposureMap;
  analytics: AnalyticsMap;         // yalnız whitelist içinden kullanılacak
}

Event Bus (publish/subscribe)

Subscribe: vivo.posture:input (VIVO-01’e girdi enveloper), gb.signal (opsiyonel direkt skor beslemesi).

Publish: vivo.posture (VIVOOutput), audit.log (karar izleri).

Validasyon & Tip Kontrolleri

Girişte: policy.minTargetPct ≥ 4, policy.whitelist dolu, ledger.equityUsd > 0.

Semboller whitelist dışındaysa atlanır.

analytics[symbol].expectedMovePct ≥ policy.minTargetPct ve R_multiple ≥ 1.2 değilse plana dahil edilmez.

Risk sentinel RED/CB ⇒ sadece Plan C (Nakit+Spot/Reduce-only) üretilir.

Hata Yönetimi & Logging

Standart hata: { code, message, details, retriable }

audit.log’a: posture kararı, filtrelenen semboller, neden listeleri (whitelist dışı, +%4 altı, R<1.2, exposure=DENY/REDUCE_ONLY, risk=RED).

Kod İskeleti (TypeScript/Node.js)
// vivo/marketPostureAdvisor.ts
import { EventEmitter } from "events";
import type {
  VIVO01Input, VIVOOutput, VIVOPlan, VIVOAsk, Posture, Level, StdError
} from "./types";
import { bus } from "../core/bus";     // ee sarmalayıcı (önceden tanımlı)
import { logger } from "../core/logger";

export class MarketPostureAdvisor extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-01";

  constructor() { super(); }

  run(x: VIVO01Input): VIVOOutput | { error: StdError } {
    try {
      const valErr = this.validate(x);
      if (valErr) return this.err("VALIDATION_ERROR", valErr);

      const posture = this.decidePosture(x.risk);
      const plans = this.buildPlans(x, posture);
      const ask = this.buildQuestions(x, posture, plans);
      const out: VIVOOutput = {
        asOf: new Date().toISOString(),
        posture, plans, ask,
        audit: this.auditLines(x, posture, plans)
      };
      bus.emit<VIVOOutput>("vivo.posture", out);
      return out;
    } catch (e:any) {
      return this.err("VIVO01_FAILED", e?.message || "unknown", { stack: e?.stack });
    }
  }

  private validate(x: VIVO01Input): string | null {
    if (!x || !x.policy) return "policy missing";
    if ((x.policy.minTargetPct ?? 0) < 4) return "minTargetPct must be ≥ 4";
    if (!Array.isArray(x.policy.whitelist) || x.policy.whitelist.length === 0) return "whitelist empty";
    if (!x.ledger || !Number.isFinite(x.ledger.equityUsd) || x.ledger.equityUsd <= 0) return "equity invalid";
    return null;
  }

  private decidePosture(r: VIVO01Input["risk"]): Posture {
    if (r.sentinel !== "NORMAL" || r.level === "RED") return "RISK_OFF";
    if (r.level === "AMBER") return "NEUTRAL";
    return "RISK_ON";
  }

  private buildPlans(x: VIVO01Input, posture: Posture): VIVOPlan[] {
    const plans: VIVOPlan[] = [];
    // C) Nakit + Spot (her durumda öneri olarak bulunsun)
    plans.push(this.planSpot(x, posture));

    if (posture === "RISK_OFF") return plans; // yalnız Plan C

    // A) BTC+ETH Trend
    const planA = this.planTrendBluechips(x);
    if (planA) plans.unshift(planA); // A’yı başa koy

    // B) Alt Momentum Sepeti
    const planB = this.planAltBasket(x);
    if (planB) plans.splice(1, 0, planB);

    return plans;
  }

  private planTrendBluechips(x: VIVO01Input): VIVOPlan | null {
    const picks = this.pickSymbols(x, ["BTCUSDT","ETHUSDT"]);
    if (picks.length === 0) return null;

    const exec = {
      ...x.wf.exec,
      twapMs: x.risk.level==="AMBER" ? x.wf.exec.twapMs + 200 : x.wf.exec.twapMs
    };
    return {
      id:"A", title:"Trend Yakala: BTC+ETH",
      symbols: picks,
      exec, trend: x.wf.trend ?? { atrK: 2.8, pyramid:{ maxAdds:2, addEveryPct:5, sizePct:0.33 } },
      notes: this.notesFrom(x),
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private planAltBasket(x: VIVO01Input): VIVOPlan | null {
    // whitelist’ten BTC/ETH hariç, uygun skorlu ilk 5–6
    const universe = x.policy.whitelist.filter(s => s!=="BTCUSDT" && s!=="ETHUSDT");
    const picks = this.pickSymbols(x, universe, { perSymbolFrac: 0.10, maxCount: 6 });
    if (picks.length === 0) return null;

    const exec = {
      ...x.wf.exec,
      limitOffsetBps: x.wf.exec.limitOffsetBps + 1,
      twapMs: x.wf.exec.twapMs + (x.risk.level==="AMBER" ? 300 : 100),
      iceberg: Math.max(0.10, (x.wf.exec.iceberg ?? 0.12) - 0.02)
    };
    return {
      id:"B", title:"Alt Momentum Sepeti",
      symbols: picks, exec, trend: { atrK: 2.6, pyramid:{ maxAdds:1, addEveryPct:5, sizePct:0.5 } },
      notes: this.notesFrom(x),
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private planSpot(x: VIVO01Input, posture: Posture): VIVOPlan {
    const need = this.spotTopupAmount(x.policy.spot, x.ledger);
    return {
      id:"C", title:"Nakit + Spot Top-Up",
      symbols: [],
      exec: x.wf.exec,
      spotTopup: need>0 ? { targetPct: x.policy.spot.targetPct, amountUsd: Math.round(need) } : null,
      notes: [ posture==="RISK_OFF" ? "Risk-Kapalı: yeni giriş yok, reduce-only" : "Nötr/Risk-On: sınırlı giriş" ],
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private pickSymbols(
    x: VIVO01Input,
    pool: string[],
    opt: { perSymbolFrac?:number; maxCount?:number } = {}
  ): Array<Record<string, number>> {
    const frac = opt.perSymbolFrac ?? 0.25;           // equity * 0.25 * 0.2 = ~%5 varsayılan
    const maxN = opt.maxCount ?? 2;

    const chosen: Array<Record<string, number>> = [];
    for (const s of pool) {
      if (!x.policy.whitelist.includes(s)) continue;
      const an = x.analytics[s]; if (!an) continue;
      if (an.expectedMovePct < x.policy.minTargetPct || (an.R_multiple ?? 0) < 1.2) continue;
      const gate = x.exposure[s]; if (!gate || gate.decision==="DENY" || gate.decision==="REDUCE_ONLY") continue;

      const base = x.ledger.equityUsd * frac * 0.2;    // risk bütçesi ~%20 çarpanı
      const notional = gate.decision==="TRIM" ? (gate.allowedNotionalUsd ?? base) : base;
      if (notional <= 0) continue;

      chosen.push({ [s]: Math.round(notional) });
      if (chosen.length >= maxN) break;
    }
    return chosen;
  }

  private spotTopupAmount(spotPol: VIVO01Input["policy"]["spot"], led: VIVO01Input["ledger"]){
    if (led.equityUsd < spotPol.equityThresholdUsd){
      const target = Math.min(0.15, spotPol.targetPct * (led.equityUsd / spotPol.equityThresholdUsd));
      return Math.max(0, (target - (led.spotPct||0))) * led.equityUsd;
    }
    if ((led.spotPct||0) < spotPol.targetPct){
      return (spotPol.targetPct - (led.spotPct||0)) * led.equityUsd;
    }
    return 0;
  }

  private buildQuestions(_x: VIVO01Input, posture: Posture, plans: VIVOPlan[]): VIVOAsk[] {
    const ids = plans.map(p=>p.id);
    const qs: VIVOAsk[] = [
      { q:"Plan seçimi?", choices: ids, default: ids[0], timeoutSec: 45 },
    ];
    if (posture !== "RISK_OFF") {
      qs.push({ q:"Min +%4 hedef sağlanıyorsa uygulansın mı?", choices:["Evet","Hayır"], default:"Evet", timeoutSec:30 });
    }
    return qs;
  }

  private notesFrom(x: VIVO01Input): string[] {
    const n: string[] = [];
    if (x.risk.level==="AMBER") n.push("AMBER: TWAP +200–300ms, iceberg düşük");
    if (x.risk.sentinel!=="NORMAL") n.push(`Sentinel=${x.risk.sentinel}`);
    if (x.dominance.ethRel>0 && x.dominance.btcD<0.55) n.push("ETH güç > BTC; alt sepet destekli");
    return n;
  }

  private auditLines(x: VIVO01Input, posture: Posture, plans: VIVOPlan[]): string[] {
    return [
      `risk=${x.risk.level}/${x.risk.sentinel}`,
      `posture=${posture}`,
      `btcD=${x.dominance.btcD.toFixed(2)} ethRel=${x.dominance.ethRel.toFixed(2)} altRet=${x.dominance.altRet.toFixed(3)}`,
      `plans=${plans.map(p=>p.id).join(",")}`
    ];
  }

  private err(code:string, message:string, details?:any): { error: StdError } {
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Altyapısı (Vitest örnekleri)
// vivo/__tests__/marketPostureAdvisor.test.ts
import { describe,it,expect } from "vitest";
import { MarketPostureAdvisor } from "../marketPostureAdvisor";
import type { VIVO01Input } from "../types";

const base: VIVO01Input = {
  risk: { level:"AMBER", sentinel:"NORMAL" },
  wf: { exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }, trend:{ atrK:2.8, pyramid:{maxAdds:2, addEveryPct:5, sizePct:0.33} } },
  ledger: { equityUsd: 100_000, spotPct: 0.20, ddPct: 0.05 },
  dominance: { btcD:0.52, ethRel:0.03, altRet:0.01 },
  policy: { minTargetPct:4, whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], spot:{ targetPct:0.30, equityThresholdUsd:100_000 } },
  exposure: { BTCUSDT:{ decision:"ALLOW" }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd: 20_000 }, OPUSDT:{ decision:"ALLOW" } },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:3.5, R_multiple:1.1 } }
};

describe("VIVO-01", ()=>{
  it("validates policy", ()=>{
    const vivo = new MarketPostureAdvisor();
    const bad = JSON.parse(JSON.stringify(base)); bad.policy.minTargetPct = 3;
    const res:any = vivo.run(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });

  it("produces plans A and C on AMBER", ()=>{
    const vivo = new MarketPostureAdvisor();
    const res:any = vivo.run(base);
    const ids = res.plans.map((p:any)=>p.id);
    expect(ids.includes("A")).toBe(true);
    expect(ids.includes("C")).toBe(true);
    // OPUSDT düşük hedef nedeniyle dışarıda
    expect(JSON.stringify(res)).not.toContain("OPUSDT");
  });

  it("RISK_OFF when sentinel != NORMAL", ()=>{
    const vivo = new MarketPostureAdvisor();
    const input = { ...base, risk:{ level:"GREEN", sentinel:"HALT_PARTIAL" } };
    const res:any = vivo.run(input);
    expect(res.posture).toBe("RISK_OFF");
    expect(res.plans.map((p:any)=>p.id)).toEqual(["C"]);
  });
});

Entegrasyon Notları

VIVO-02 · strategyAllocator: Buradaki plans[] doğrudan lot/child-order planına çevrilecek; tick/lot/notional uyumluluğu orada kesinleştirilecek.

operatorDialog: ask[] kartlarını Telegram/CLI’ye dönüştürüp yanıtları VIVO-02’ye iletir.

GB-61/70/75: Posture ve plan notları bu sinyalleri yansıtır; devre kesici durumunda Plan A/B üretimi otomatik devre dışı.

Otobilinç/LIVIA: Riskli davranış uyarısı gelirse plan applicability veya posture baskılanır (NEUTRAL/RISK_OFF).
_________________________________________________________________________________________________________________
VIVO-02 · strategyAllocator.ts

Amaç (tek cümle):
VIVO-01’den gelen Plan A/B/C’yi borsa kuralları ve RiskNet kapıları ile uyuşacak şekilde notional→fiyat→miktar kuantizasyonu yaparak icra edilebilir emir paketlerine dönüştürmek ve ops.actions üzerinden yayınlamak.

Gerçek Dünya Kuralları (latency-safe)

Binance kuralları: PRICE_FILTER (tickSize), LOT_SIZE (stepSize), (MIN_)NOTIONAL, PERCENT_PRICE(_BY_SIDE), MAX_POSITION, TRAILING_DELTA (varsa), LIMIT_MAKER post-only cross koruması.

Rate-limit ve backoff jitter üst katmanda; bu modül paket boyutu ve çocuk sayısını sınırlar.

Risk/sentinel (GB-61/70/75): SLOWDOWN/HALT/CIRCUIT_BREAKER → reduce-only dışında yeni pozisyon açmaz.

Politika kapıları (+%4, whitelist) VIVO-01’de geçildi; burada yeniden doğrulanır (savunmacı programlama).

Kapanmamış bar yok → expectedMove yalnız kapanmış barlardan geldiği varsayılır.

Slipaj/komisyon/funding VIVO-02’de muhasebeleştirilmez; TCA (GB-22/36) raporlar.

Arayüzler (TypeScript / JSDoc)
// vivo/strategyAllocator.types.ts
import type { ISODate } from "../core/types";

export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface ExchangeRule {
  symbol: string;
  tickSize: number;     // PRICE_FILTER
  stepSize: number;     // LOT_SIZE
  minNotional: number;  // (MIN_)NOTIONAL
  percent?: {           // PERCENT_PRICE / BY_SIDE (opsiyonel)
    bidUp?: number; bidDown?: number; askUp?: number; askDown?: number; avgPriceMins?: number;
  };
}

export interface BookTicker {
  symbol: string;
  bid: number; ask: number; mid: number;
  asOf: ISODate;
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;
  maxPositionQty?: number; // opsiyonel üst sınır
}

export interface ExecParams {
  limitOffsetBps: number;     // ör: 6
  twapMs: number;             // ör: 1400
  iceberg: number;            // [0..1] çocuk miktar oranı
  childType: ChildType;       // LIMIT/IOC/POST_ONLY/MARKET
}

export interface PlanSymbol {
  symbol: string;
  notionalUsd: number;
  side?: Side;                // yoksa varsayılan BUY
}

export interface PlanIn {
  id: "A"|"B"|"C";
  title: string;
  symbols: PlanSymbol[];
  exec: ExecParams;
  notes?: string[];
}

export interface AllocatorInput {
  plan: PlanIn;
  whitelist: string[];
  minTargetPct: number;         // ≥4 (savunma amaçlı tekrar doğrula)
  sentiment?: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
  exposure: Record<string, ExposureGate>;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
}

export interface ChildOrder {
  symbol: string;
  side: Side;
  type: ChildType;
  price?: number;               // MARKET/IOC için opsiyonel
  qty: number;
  tif?: "GTC"|"IOC"|"FOK";
  postOnly?: boolean;           // LIMIT_MAKER güvenliği için
  reduceOnly?: boolean;         // sentinel/position düşürme
  meta?: { twapMs?: number; iceberg?: number; corrId?: string };
}

export interface ActionBundle {
  asOf: ISODate;
  planId: "A"|"B"|"C";
  children: ChildOrder[];
  comments?: string[];
}

export interface AllocError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.plan (seçilen plan) veya vivo.posture + operatorDialog sonucu.

Publish: ops.actions (ActionBundle), audit.log (karar izi), gb.route (opsiyonel pre-view).

Kod İskeleti
// vivo/strategyAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocatorInput, ActionBundle, ChildOrder, ExchangeRule, BookTicker, AllocError, Side, ChildType
} from "./strategyAllocator.types";

export class StrategyAllocator extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-02";

  run(x: AllocatorInput): ActionBundle | { error: AllocError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      // Sentinel → reduce-only
      const reduceOnly = x.sentiment && x.sentiment !== "NORMAL";

      const children: ChildOrder[] = [];
      for (const ps of x.plan.symbols) {
        const sym = ps.symbol.toUpperCase();
        if (!x.whitelist.includes(sym)) { logger.warn({sym},"non-whitelist skipped"); continue; }

        const gate = x.exposure[sym];
        if (!gate || gate.decision==="DENY") { logger.warn({sym},"exposure deny"); continue; }
        if (gate.decision==="REDUCE_ONLY" && !reduceOnly) {
          // Plan long açmaya çalışıyorsa engelle; reduce-only ise sadece kapama/trim yapılmalı
          logger.warn({sym},"exposure reduce-only blocks new opens"); continue;
        }

        const rules = x.rules[sym];  if (!rules) { logger.warn({sym},"missing rules"); continue; }
        const tk = x.tickers[sym];   if (!tk || tk.bid<=0 || tk.ask<=0) { logger.warn({sym},"missing ticker"); continue; }

        // Notional → price/qty kuantizasyonu
        const side: Side = ps.side ?? "BUY";
        const px = this.targetPrice(side, x.plan.exec.childType, x.plan.exec.limitOffsetBps, tk);
        const { price, qty, reason } = this.quantize(sym, side, px, ps.notionalUsd, rules);

        if (qty <= 0 || !Number.isFinite(price!)) { logger.warn({sym, reason},"quantize failed"); continue; }

        // Exposure TRIM: notional üst sınırı geçilmesin
        if (gate.decision==="TRIM" && gate.allowedNotionalUsd && ps.notionalUsd > gate.allowedNotionalUsd) {
          const scale = Math.max(0, gate.allowedNotionalUsd / ps.notionalUsd);
          const adjQty = this.roundQty(qty * scale, rules.stepSize);
          if (adjQty <= 0) { logger.warn({sym},"trim→zero qty"); continue; }
          children.push(this.child(sym, side, x.plan.exec.childType, price!, adjQty, reduceOnly, x.plan.exec));
          continue;
        }

        children.push(this.child(sym, side, x.plan.exec.childType, price!, qty, reduceOnly, x.plan.exec));
      }

      const bundle: ActionBundle = { asOf:new Date().toISOString(), planId:x.plan.id, children, comments: x.plan.notes ?? [] };
      bus.emit<ActionBundle>("ops.actions", bundle);
      return bundle;

    } catch (e:any) {
      return this.err("ALLOCATOR_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- Validasyon ---
  private validate(x: AllocatorInput): string | null {
    if (!x.plan || !Array.isArray(x.plan.symbols) || x.plan.symbols.length===0) return "empty plan";
    if (!Array.isArray(x.whitelist) || x.whitelist.length===0) return "empty whitelist";
    if ((x.minTargetPct ?? 0) < 4) return "minTargetPct must be ≥4";
    if (!x.rules || !x.tickers) return "missing rules/tickers";
    return null;
  }

  // --- Fiyat hedefi ---
  private targetPrice(side: Side, type: ChildType, offsetBps: number, t: BookTicker): number {
    const ofs = (offsetBps||0) / 10_000;
    if (type==="MARKET") return side==="BUY" ? t.ask : t.bid;
    if (type==="IOC")    return side==="BUY" ? t.ask * (1 + ofs) : t.bid * (1 - ofs);
    if (type==="POST_ONLY") return side==="BUY" ? t.bid * (1 - Math.max(ofs, 0.0001)) : t.ask * (1 + Math.max(ofs, 0.0001));
    // LIMIT
    return side==="BUY" ? t.ask * (1 + ofs) : t.bid * (1 - ofs);
  }

  // --- Kuantizasyon & filtreler ---
  private quantize(symbol:string, side:Side, rawPx:number, notionalUsd:number, r: ExchangeRule){
    // PRICE_FILTER (tick) → price
    const price = this.roundPrice(rawPx, r.tickSize);
    // NOTIONAL
    const qty0  = notionalUsd / price;
    // LOT_SIZE (step)
    const qty   = this.roundQty(qty0, r.stepSize);
    // MIN_NOTIONAL
    const notion = price * qty;
    if (notion < r.minNotional) {
      return { price, qty: 0, reason:`minNotional ${notion.toFixed(2)} < ${r.minNotional}` };
    }
    // PERCENT_PRICE_BY_SIDE (opsiyonel, fail-safe clamp)
    if (r.percent) {
      const up  = side==="BUY" ? (r.percent.bidUp ?? r.percent.askUp) : (r.percent.askUp ?? r.percent.bidUp);
      const down= side==="BUY" ? (r.percent.bidDown ?? r.percent.askDown) : (r.percent.askDown ?? r.percent.bidDown);
      // Burada yalnızca uyarı üret; gerçek clamp için book ortalamasına ihtiyaç var (upper/lower bound)
      // (Üst katmanda engine reddederse fallback yapılır)
    }
    return { price, qty, reason:"ok" };
  }

  private roundPrice(x:number, tick:number){ return Math.round(x / tick) * tick; }
  private roundQty(x:number, step:number){ return Math.floor(x / step) * step; }

  private child(symbol:string, side:Side, type:ChildType, price:number, qty:number, reduceOnly:boolean, exec:any): ChildOrder {
    const tif = type==="IOC" ? "IOC" : "GTC";
    const postOnly = (type==="POST_ONLY");
    return { symbol, side, type, price, qty, tif, postOnly, reduceOnly, meta:{ twapMs: exec.twapMs, iceberg: exec.iceberg } };
  }

  // --- Hata ---
  private err(code:string, message:string, details?:any): { error: AllocError } {
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/strategyAllocator.test.ts
import { describe,it,expect } from "vitest";
import { StrategyAllocator } from "../strategyAllocator";
import type { AllocatorInput } from "../strategyAllocator.types";

const rules = {
  BTCUSDT: { symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10 },
  ETHUSDT: { symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10 }
};
const tickers = {
  BTCUSDT: { symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
  ETHUSDT: { symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() }
};

const base: AllocatorInput = {
  plan: {
    id:"A", title:"Trend Yakala: BTC+ETH",
    symbols:[ {symbol:"BTCUSDT", notionalUsd: 10_000}, {symbol:"ETHUSDT", notionalUsd: 5_000} ],
    exec: { limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }
  },
  whitelist:["BTCUSDT","ETHUSDT"],
  minTargetPct: 4,
  sentiment: "NORMAL",
  exposure: { BTCUSDT:{ decision:"ALLOW" }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd: 4_000 } },
  rules, tickers
};

describe("VIVO-02 strategyAllocator", ()=>{
  it("builds child orders with tick/step/minNotional", ()=>{
    const sa = new StrategyAllocator();
    const out:any = sa.run(base);
    expect(out.children.length).toBe(2);
    out.children.forEach((c:any)=>{
      // stepSize uygundur
      expect( (c.qty / rules[c.symbol].stepSize) % 1 ).toBe(0);
      // tickSize uygundur
      expect( (c.price / rules[c.symbol].tickSize) % 1 ).toBe(0);
      // notional ≥ min
      expect(c.price * c.qty).toBeGreaterThanOrEqual(rules[c.symbol].minNotional);
    });
  });

  it("respects exposure TRIM and sentinel reduce-only", ()=>{
    const sa = new StrategyAllocator();
    const inp = structuredClone(base);
    inp.sentiment = "HALT_PARTIAL"; // reduce-only
    const out:any = sa.run(inp);
    expect(out.children.every((c:any)=>c.reduceOnly===true)).toBe(true);
  });

  it("skips non-whitelist symbols", ()=>{
    const sa = new StrategyAllocator();
    const inp = structuredClone(base);
    inp.whitelist = ["BTCUSDT"]; // ETH yok
    const out:any = sa.run(inp);
    expect(out.children.find((c:any)=>c.symbol==="ETHUSDT")).toBeUndefined();
  });
});

Entegrasyon Notları

Girdi kaynağı: operatorDialog seçimi sonrası Plan A/B/C → vivo.plan ile StrategyAllocator.run() çağrısına sarılır.

Çıktı: ops.actions (child order listesi) GB-66/67 tarafından yürütülür.

Korumacı davranış: sentiment!="NORMAL" ise tüm çocuk emirler reduceOnly.

LIMIT_MAKER güvenliği: POST_ONLY tipi verildiğinde fiyat best bid/ask’ı cross etmeyecek şekilde negatif/pozitif ofsetle set edilir (yukarıdaki targetPrice bunu yapıyor).

Percent-price clamp (opsiyonel): İstersen rules.percent doluysa upper/lower band hesabını ekleyip priceı banda kırpabilirsin.
_________________________________________________________________________________________________________________
VIVO-03 · operatorDialog.ts

Amaç (tek cümle):
VIVO-01’in ürettiği Plan A/B/C ve politika kapılarına ilişkin evet/hayır sorularını Telegram/CLI üzerinden operatöre sunup yanıtları toplar; timeout durumunda korumacı default karar verir ve seçimi vivo.plan → ops.actions hattına taşır.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok (yalnız diyalog; sinyal metrikleri VIVO-01’den gelir).

Risk/Sentinel RED/HALT/CB ise reduce-only planları tercih et (korumacı default).

Politika kapıları (+%4 hedef / whitelist / spot %30) VIVO-01’de uygulanmıştır; burada sadece kullanıcı onayı alınır.

Idempotency: Aynı corrId tekrar gelirse ikinci kez soru sorma.

Timeout → varsayılan seçeneği uygula (genellikle Plan A ve “Evet”).

Arayüzler (TypeScript / JSDoc)
// vivo/operatorDialog.types.ts
import type { ISODate } from "../core/types";

export interface VIVOAsk {
  q: string;
  choices: string[];      // ["A","B","C"] veya ["Evet","Hayır"]
  default: string;        // default seçim
  timeoutSec: number;     // 10..120 arası önerilir
}

export interface VIVOPlan {
  id: "A"|"B"|"C";
  title: string;
  symbols: Array<Record<string, number>>;
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
}

export interface VIVOOutputPayload {
  asOf: ISODate;
  posture: "RISK_ON"|"NEUTRAL"|"RISK_OFF";
  plans: VIVOPlan[];
  ask: VIVOAsk[];
  audit: string[];
  corrId?: string;
}

export interface DialogConfig {
  ui: "TELEGRAM"|"CLI";
  chatId?: string;        // telegram ise zorunlu
  timeoutSafetySec?: number; // global fail-safe (opsiyonel)
}

export interface DialogResult {
  corrId?: string;
  selectedPlanId: "A"|"B"|"C";
  confirmations: Record<number,string>;  // soru index → cevap
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.posture (VIVO-01 çıktısı; içindeki ask[] soruları ve plans[] kartları)

Publish:

vivo.plan (seçilen plan: VIVOPlan)

audit.log (soru-cevap ve timeout/gerekçeler)

Validasyon & Tip Kontrolleri

En az 1 plan ve 1 soru olmalı (Plan C — Nakit/Spot — her durumda bulunur).

ask[].choices içinde default bulunmak zorunda.

ui="TELEGRAM" ise chatId zorunlu.

Aynı corrId daha önce işlendiyse idempotent olarak yut (yeniden soru sorma).

Hata Yönetimi & Logging

{ code,message,details,retriable } biçimi; tüm kritik adımlar audit.log’a düşer.

Telegram/CLI iletim hatası durumunda CLI fallback mesajı (opsiyonel hook) veya timeout default uygulanır.

Kod İskeleti (TypeScript / Node.js)
// vivo/operatorDialog.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type { VIVOOutputPayload, VIVOPlan, VIVOAsk, DialogConfig, DialogResult, StdError } from "./operatorDialog.types";

export interface ChatAdapter {
  sendText(chatId: string, text: string): Promise<void>;
  askChoice(chatId: string, text: string, choices: string[], timeoutSec: number, defaultChoice: string): Promise<{ choice: string; decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT" }>;
}

// Basit CLI adapter örneği:
export class CliAdapter implements ChatAdapter {
  async sendText(_chatId: string, text: string){ console.log(text); }
  async askChoice(_chatId: string, text: string, choices: string[], timeoutSec: number, defaultChoice: string){
    console.log(`[SORU] ${text} (${timeoutSec}s) -> ${choices.join("/")}, default=${defaultChoice}`);
    // Gerçek CLI için readline + timer; demo amaçlı otomatik default:
    await new Promise(r=>setTimeout(r, Math.min(1500, timeoutSec*1000)));
    return { choice: defaultChoice, decidedBy: "TIMEOUT_DEFAULT" };
  }
}

export class OperatorDialog extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-03";
  private seenCorr = new Set<string>();
  constructor(private cfg: DialogConfig, private adapter: ChatAdapter){ super(); }

  /** VIVO-01 çıktılarını dinle ve soru/plan akışını başlat */
  attach(){
    bus.on<VIVOOutputPayload>("vivo.posture", (env)=> this.process(env));
  }

  async process(env: VIVOOutputPayload): Promise<DialogResult | { error: StdError }> {
    try {
      const corrId = env.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      if (this.seenCorr.has(corrId)) return this.err("IDEMPOTENT", "corrId already processed", { corrId });

      const { plans, ask } = env;
      const valErr = this.validate(plans, ask); if (valErr) return this.err("VALIDATION_ERROR", valErr);

      const chatId = this.cfg.chatId ?? "CLI";
      // 1) Plan kartlarını gönder
      await this.adapter.sendText(chatId, this.renderPlanCards(env));

      // 2) Soruları sırayla sor
      const answers: string[] = [];
      for (let i=0; i<ask.length; i++){
        const a = ask[i];
        const res = await this.adapter.askChoice(chatId, a.q, a.choices, a.timeoutSec, a.default);
        answers.push(res.choice);
      }

      // 3) Plan seçimi (ilk soru Plan seçimi olmalı)
      const planChoice = answers[0] as "A"|"B"|"C";
      const selected = plans.find(p=>p.id===planChoice) ?? plans[0];

      const decidedBy = (answers[0]===ask[0].default) ? "TIMEOUT_DEFAULT" : "OPERATOR";
      const result: DialogResult = {
        corrId, selectedPlanId: selected.id,
        confirmations: Object.fromEntries(answers.map((v,i)=>[i,v])),
        decidedBy, decidedAt: new Date().toISOString()
      };

      // 4) Yayınla → strategyAllocator bu planı alacak
      bus.emit<VIVOPlan>("vivo.plan", selected);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ dialog: result, posture: env.posture } });

      this.seenCorr.add(corrId);
      return result;

    } catch (e:any){
      return this.err("DIALOG_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private validate(plans: VIVOPlan[], ask: VIVOAsk[]): string | null {
    if (!Array.isArray(plans) || plans.length===0) return "no plans";
    if (!Array.isArray(ask) || ask.length===0) return "no questions";
    for (const q of ask){
      if (!q.choices.includes(q.default)) return `default not in choices for question: ${q.q}`;
    }
    return null;
  }

  private renderPlanCards(env: VIVOOutputPayload){
    const lines: string[] = [];
    lines.push(`📣 VIVO-01 | Postür: ${env.posture}`);
    for (const p of env.plans){
      const sumNotional = p.symbols.reduce((a,o)=>a+Object.values(o)[0],0);
      lines.push(`\n— Plan ${p.id}: ${p.title}\n  Notional≈$${Math.round(sumNotional)} | Exec=${p.exec.childType}/twap:${p.exec.twapMs}ms/iceberg:${p.exec.iceberg}`);
      const syms = p.symbols.map(o=>`${Object.keys(o)[0]}:$${Object.values(o)[0]}`).join(", ");
      if (syms) lines.push(`  > ${syms}`);
      if (p.spotTopup) lines.push(`  Spot Top-Up: %${Math.round(p.spotTopup.targetPct*100)/100} → $${p.spotTopup.amountUsd}`);
      if (p.notes?.length) lines.push(`  Notlar: ${p.notes.join(" | ")}`);
    }
    lines.push("\n❓ Lütfen seçim yap: Plan A/B/C. Ardından +%4 kapısı için 'Evet/Hayır'.");
    return lines.join("\n");
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/operatorDialog.test.ts
import { describe,it,expect,vi } from "vitest";
import { OperatorDialog, CliAdapter } from "../operatorDialog";
import type { VIVOOutputPayload } from "../operatorDialog.types";

const env: VIVOOutputPayload = {
  asOf: new Date().toISOString(),
  posture: "NEUTRAL",
  corrId: "test-123",
  plans: [
    { id:"A", title:"Trend Yakala BTC+ETH", symbols:[{"BTCUSDT":10000},{"ETHUSDT":8000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"}, spotTopup:{targetPct:0.3, amountUsd:2000} }
  ],
  ask: [
    { q:"Plan seçimi?", choices:["A","B","C"], default:"A", timeoutSec:3 },
    { q:"+%4 hedef uygulanacak. Onay?", choices:["Evet","Hayır"], default:"Evet", timeoutSec:3 }
  ],
  audit:[]
};

describe("VIVO-03 operatorDialog", ()=>{
  it("falls back to timeout default", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    const res:any = await od.process(env);
    expect(res.decidedBy).toBe("TIMEOUT_DEFAULT");
    expect(res.selectedPlanId).toBe("A");
  });

  it("validates questions", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    const bad = structuredClone(env);
    bad.ask[0].default = "X";
    const res:any = await od.process(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });

  it("idempotent by corrId", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    await od.process(env);
    const res:any = await od.process(env); // aynı corrId
    expect(res.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon Akışı

VIVO-01 → (vivo.posture): Plan A/B/C + ask[] yayınlanır.

VIVO-03 operatorDialog: Plan kartlarını ve soruları Telegram/CLI’de gösterip yanıtları toplar.

Seçim → (vivo.plan): Seçilen VIVOPlan yayınlanır.

VIVO-02 strategyAllocator: vivo.plan’ı alır → ops.actions çocuk emir paketi üretir.

GB-66/67: Emirleri yürütür; sonuçlar GB-22/36 ve VIVO uplift modüllerine akar.
_________________________________________________________________________________________________________________
VIVO-04 · postureMemory.ts

Amaç (tek cümle):
Son 7/30 günün postür (Risk-Açık/Nötr/Risk-Kapalı) ve plan (A/B/C) performanslarını EWMA ile izleyip postür ağırlıkları, varsayılan plan ve yürütme ayarı (TWAP/iceberg/childType) önerileri üretmek; VIVO-01 (plan kurucu) ve VIVO-03 (dialog default) için karar kalitesini artırmak.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; metrikler GB-22/36 (TCA/mark-out/slipaj) tarafından hesaplanır, bu modül sadece tüketir.

Live-BT farkı ≤ %20 hedefini ihlal eden dönemler ağırlığı cezalandırır.

Risk/Sentinel (GB-61/70/75) RED/CB günleri ayrı etiketlenir (normal günlerle karışmaz).

Politika (+%4, whitelist, spot %30) üst katmanda uygulanır; hafıza öneri/tuning üretir (politika kapılarını değiştirmez).

Arayüzler (TypeScript / JSDoc)
// vivo/postureMemory.types.ts
import type { ISODate } from "../core/types";

export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";

export interface SessionKey {
  corrId: string;
}

export interface DecisionEvent {
  asOf: ISODate;
  corrId: string;
  posture: Posture;
  planId: PlanId;
  symbols: string[];
  sentiment: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
}

export interface OutcomeEvent {
  asOf: ISODate;
  corrId: string;
  pf: number;              // profit factor
  hitRate: number;         // 0..1
  avgR: number;            // beklenen ≥ 0.3
  maxDD: number;           // 0..1 (örn 0.12 = %12)
  slipBps: number;         // realized slippage (bps)
  markout30sBps: number;   // 30s mark-out
  commShare: number;       // komisyonun kâr içindeki payı (0..1)
  liveBTGap: number;       // |live - backtest| / backtest (0..1)
}

export interface MemoryConfig {
  shortDays: number; // 7
  longDays: number;  // 30
  alphaShort: number; // 0.3
  alphaLong: number;  // 0.1
  decayPerDay: number; // 0.98
}

export interface Weights {
  posture: Record<Posture, number>; // 0..1 normalize
  planDefault: Record<Posture, PlanId>; // önerilen default Plan
  execTuning: {  // VIVO-01/02 için öneriler
    twapMsDelta: number;         // +pozitif = daha yavaş
    icebergDelta: number;        // +pozitif = daha küçük görünür boy
    preferChild?: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
  };
}

export interface Snapshot {
  asOf: ISODate;
  short: { pf:number; hit:number; avgR:number; dd:number; slip:number; gap:number };
  long:  { pf:number; hit:number; avgR:number; dd:number; slip:number; gap:number };
  weights: Weights;
  notes: string[];
}

export interface MemoryError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.plan (seçilen plan) → DecisionEvent’e dönüştürülür (corrId varsa).

gb.tca (TCA/sonuç akışı) → OutcomeEvent.

(opsiyonel) audit.log içindeki operatorDialog sonucu (corrId eşlemesi için).

Publish:

vivo.memory (Snapshot) — VIVO-01 ve VIVO-03 tarafından tüketilir.

audit.log — güncelleme ve ağırlık notları.

Validasyon & Tip Kontrolleri

DecisionEvent.corrId ve OutcomeEvent.corrId zorunlu (eşleşme için).

Metrikler aralıklara clamp edilir: hit∈[0,1], pf≥0, liveBTGap∈[0,1], maxDD∈[0,1].

Sentinel RED/CB günleri karar ağırlığına dahil edilmez, ayrı not edilir.

Hata Yönetimi & Logging

{ code,message,details,retriable } formatı; tüm update adımları audit.log.

Eşleşmeyen OutcomeEvent geldiğinde gecikmiş eşleştirme kuyruğu (TTL=24h) denenir; sonra düşülür.

Kod İskeleti (TypeScript / Node.js)
// vivo/postureMemory.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  DecisionEvent, OutcomeEvent, MemoryConfig, Snapshot, Weights, Posture, PlanId, MemoryError
} from "./postureMemory.types";

const clamp01 = (x:number)=> Math.max(0, Math.min(1, x));

interface SessionRow {
  corrId: string;
  asOf: string;
  posture: Posture;
  planId: PlanId;
  sentiment: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
  outcome?: OutcomeEvent;
}

export class PostureMemory extends EventEmitter {
  ver="1.0.0"; src="VIVO-04";

  private cfg: MemoryConfig;
  private sessions: Map<string, SessionRow> = new Map(); // corrId→row
  private aggShort = { pf:1, hit:0.5, avgR:0.3, dd:0.05, slip:10, gap:0.1 };
  private aggLong  = { pf:1, hit:0.5, avgR:0.3, dd:0.07, slip:12, gap:0.12 };

  constructor(cfg?: Partial<MemoryConfig>) {
    super();
    this.cfg = { shortDays:7, longDays:30, alphaShort:0.3, alphaLong:0.1, decayPerDay:0.98, ...cfg };
  }

  attach(){
    bus.on<DecisionEvent>("vivo.plan", (p:any)=> this.onDecision(this.normalizeDecision(p)));
    bus.on<OutcomeEvent>("gb.tca", (t:any)=> this.onOutcome(this.normalizeOutcome(t)));
  }

  onDecision(d: DecisionEvent){ // karar geldi
    if (!d?.corrId) return this.logErr("VALIDATION_ERROR","missing corrId",{d});
    this.sessions.set(d.corrId, { ...d });
    logger.info({ d }, "VIVO-04 decision stored");
  }

  onOutcome(o: OutcomeEvent){ // sonuç geldi
    if (!o?.corrId) return this.logErr("VALIDATION_ERROR","missing corrId",{o});
    const row = this.sessions.get(o.corrId);
    if (!row) { // gecikmiş eşleşme için tente
      this.sessions.set(o.corrId, { corrId:o.corrId, asOf:o.asOf, posture:"NEUTRAL", planId:"C", sentiment:"NORMAL", outcome:o });
      logger.warn({o},"outcome without decision — tentatively stored");
      return;
    }
    row.outcome = o;
    this.updateAggregates(row);
    const snap = this.snapshot();
    bus.emit<Snapshot>("vivo.memory", snap);
    bus.emit("audit.log", { asOf:snap.asOf, ver:this.ver, src:this.src, payload:{ snapshot:snap } });
  }

  private updateAggregates(r: SessionRow){
    const o = r.outcome!;
    // Sentinel RED/CB günlerini aggregasyondan çıkar
    const sentinelBad = r.sentiment==="HALT_PARTIAL" || r.sentiment==="CIRCUIT_BREAKER";
    if (sentinelBad) { logger.warn({corrId:r.corrId},"excluded due to sentinel"); return; }

    // Normalize (temel cezalar)
    const pf     = Math.max(0, o.pf);
    const hit    = clamp01(o.hitRate);
    const avgR   = Math.max(0, o.avgR);
    const dd     = clamp01(o.maxDD);
    const slip   = Math.max(0, o.slipBps);
    const gap    = clamp01(o.liveBTGap);

    // Skor ceza fonksiyonları (fazla agresif değil: 0..1 arası)
    const slipPenalty = 1 / (1 + slip/20);     // 20 bps üstü baskılanır
    const ddPenalty   = 1 / (1 + (dd*100)/10); // %10 DD ~ yarım çarpan
    const gapPenalty  = 1 - Math.min(gap, 0.5); // %50 gap → 0.5 çarpan

    // Kısa/uzun EWMA
    const sA = this.cfg.alphaShort, lA = this.cfg.alphaLong;
    this.aggShort.pf   = (1-sA)*this.aggShort.pf   + sA*(pf * slipPenalty * ddPenalty * gapPenalty);
    this.aggShort.hit  = (1-sA)*this.aggShort.hit  + sA*(hit);
    this.aggShort.avgR = (1-sA)*this.aggShort.avgR + sA*(avgR);
    this.aggShort.dd   = (1-sA)*this.aggShort.dd   + sA*(dd);
    this.aggShort.slip = (1-sA)*this.aggShort.slip + sA*(slip);
    this.aggShort.gap  = (1-sA)*this.aggShort.gap  + sA*(gap);

    this.aggLong.pf   = (1-lA)*this.aggLong.pf   + lA*(pf * slipPenalty * ddPenalty * gapPenalty);
    this.aggLong.hit  = (1-lA)*this.aggLong.hit  + lA*(hit);
    this.aggLong.avgR = (1-lA)*this.aggLong.avgR + lA*(avgR);
    this.aggLong.dd   = (1-lA)*this.aggLong.dd   + lA*(dd);
    this.aggLong.slip = (1-lA)*this.aggLong.slip + lA*(slip);
    this.aggLong.gap  = (1-lA)*this.aggLong.gap  + lA*(gap);

    logger.info({ short:this.aggShort, long:this.aggLong },"EWMA updated");
  }

  snapshot(): Snapshot {
    const asOf = new Date().toISOString();
    const weights = this.computeWeights();

    const notes:string[] = [];
    if (this.aggShort.gap > 0.2) notes.push("Live-BT gap short > 20% — temkinli varsayılan");
    if (this.aggShort.slip > 25) notes.push("Slipaj yüksek — TWAP/iceberg artır");
    if (this.aggShort.dd > 0.15) notes.push("MaxDD > %15 — risk düşür");

    return {
      asOf,
      short: { ...this.aggShort },
      long : { ...this.aggLong },
      weights,
      notes
    };
  }

  private computeWeights(): Weights {
    // Basit puanlama: PF↑, hit↑, avgR↑; DD↓, slip↓, gap↓
    const score = (pf:number, hit:number, r:number, dd:number, slip:number, gap:number)=>{
      const pos = (pf/1.25) * (0.6*hit + 0.4*clamp01(r/0.5));
      const neg = (dd/0.15) + (slip/30) + (gap/0.2);
      return Math.max(0, pos - neg); // ~0..1 aralığına yakın
    };
    const s = score(this.aggShort.pf, this.aggShort.hit, this.aggShort.avgR, this.aggShort.dd, this.aggShort.slip, this.aggShort.gap);
    const l = score(this.aggLong.pf,  this.aggLong.hit,  this.aggLong.avgR,  this.aggLong.dd,  this.aggLong.slip,  this.aggLong.gap);

    // Kısa dönem ağırlığı yaklaşımı
    const wOn  = clamp01(0.5*s + 0.3*l);
    const wNeu = clamp01(0.4*l + 0.2*(1-s));
    const wOff = clamp01(1 - wOn*0.7 - wNeu*0.2);

    // Normalize
    const sum = wOn + wNeu + wOff || 1;
    const posture = {
      RISK_ON: +(wOn / sum).toFixed(3),
      NEUTRAL: +(wNeu/ sum).toFixed(3),
      RISK_OFF:+(wOff/ sum).toFixed(3)
    };

    // Varsayılan plan ve yürütme tuning önerisi
    const planDefault: Record<Posture, PlanId> = {
      RISK_ON: "A",
      NEUTRAL: "A",
      RISK_OFF:"C"
    };

    // Exec tuning (kısa dönem metriklerine göre)
    const execTuning = {
      twapMsDelta: this.aggShort.slip > 20 ? +300 : (this.aggShort.gap > 0.2 ? +150 : 0),
      icebergDelta: this.aggShort.slip > 20 ? +0.03 : 0,
      preferChild: this.aggShort.slip > 25 ? "POST_ONLY" :
                   this.aggShort.gap  > 0.2 ? "IOC" : undefined
    } as Weights["execTuning"];

    return { posture, planDefault, execTuning };
  }

  // ---- yardımcı: gelen objeleri sınırla ----
  private normalizeDecision(d:any): DecisionEvent {
    return {
      asOf: d.asOf || new Date().toISOString(),
      corrId: String(d.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`),
      posture: d.posture, planId: d.planId,
      symbols: Array.isArray(d.symbols) ? d.symbols : [],
      sentiment: d.sentinel ?? "NORMAL"
    };
  }
  private normalizeOutcome(o:any): OutcomeEvent {
    return {
      asOf: o.asOf || new Date().toISOString(),
      corrId: String(o.corrId),
      pf: Math.max(0, Number(o.pf ?? 0)),
      hitRate: clamp01(Number(o.hitRate ?? 0)),
      avgR: Math.max(0, Number(o.avgR ?? 0)),
      maxDD: clamp01(Number(o.maxDD ?? 0)),
      slipBps: Math.max(0, Number(o.slipBps ?? 0)),
      markout30sBps: Number(o.markout30sBps ?? 0),
      commShare: clamp01(Number(o.commShare ?? 0)),
      liveBTGap: clamp01(Number(o.liveBTGap ?? 0))
    };
  }

  private logErr(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return e as MemoryError;
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/postureMemory.test.ts
import { describe,it,expect } from "vitest";
import { PostureMemory } from "../postureMemory";

describe("VIVO-04 postureMemory", ()=>{
  it("updates EWMA and emits snapshot", ()=>{
    const pm = new PostureMemory({ alphaShort:0.5, alphaLong:0.2 });
    // Karar
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x1", posture:"RISK_ON", planId:"A", symbols:["BTCUSDT"], sentiment:"NORMAL" });
    // Sonuç
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x1", pf:1.5, hitRate:0.55, avgR:0.35, maxDD:0.08, slipBps:12, markout30sBps:5, commShare:0.25, liveBTGap:0.12 });
    const snap = pm.snapshot();
    expect(snap.short.pf).toBeGreaterThan(1);
    expect(snap.weights.posture.RISK_ON).toBeGreaterThan(0.3);
  });

  it("penalizes high slippage and liveBT gap", ()=>{
    const pm = new PostureMemory({ alphaShort:0.7, alphaLong:0.3 });
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x2", posture:"NEUTRAL", planId:"A", symbols:["ETHUSDT"], sentiment:"NORMAL" });
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x2", pf:1.3, hitRate:0.52, avgR:0.32, maxDD:0.1, slipBps:35, markout30sBps:-3, commShare:0.4, liveBTGap:0.35 });
    const snap = pm.snapshot();
    expect(snap.weights.execTuning.twapMsDelta).toBeGreaterThanOrEqual(150);
    expect(["POST_ONLY","IOC",undefined]).toContain(snap.weights.execTuning.preferChild);
  });

  it("excludes RED/CB sentinel outcomes", ()=>{
    const pm = new PostureMemory();
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x3", posture:"RISK_OFF", planId:"C", symbols:[], sentiment:"CIRCUIT_BREAKER" });
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x3", pf:2.0, hitRate:0.8, avgR:0.5, maxDD:0.01, slipBps:2, markout30sBps:10, commShare:0.1, liveBTGap:0.05 });
    const before = pm.snapshot().short.pf;
    // RED/CB hariç bırakıldığı için pf sıçramaz
    expect(before).toBeLessThanOrEqual(2.0);
  });
});

Entegrasyon Akışı

VIVO-01 planları ve VIVO-03 seçimi → vivo.plan (corrId ile) → VIVO-04 onDecision.

GB-22/36 sonuç akışı → gb.tca (corrId ile) → VIVO-04 onOutcome.

VIVO-04 → vivo.memory yayınlar: postür weights, Plan default, exec tuning.

VIVO-01 bu önerileri plan kurulumunda kullanır; VIVO-03 default seçimleri günceller; VIVO-02 exec paramlarına twapMsDelta/icebergDelta/preferChild uygular.
_________________________________________________________________________________________________________________
VIVO-04 · postureMemory.ts

Amaç (tek cümle):
Son 7/30 gün karar ve sonuç günlüklerini tutup (PF, hit, avgR, slipaj, mark-out), postür ağırlıklarını ve plan öneri ağırlıklarını güncellemek; VIVO-01’in plan sıralamasını ve VIVO-03’ün default seçimini veriyle yönlendirmek.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar verisi yok; sonuçlar yalnızca kapanan işlemler/oturum üzerinden gelir (GB-22/36 → TCA).

Live vs BT drift ≤%20 hedefi; hafıza, canlı sonuçları BT’ye göre ayrı tutar.

Slipaj/komisyon/funding net PnL içinde muhasebeleştirilmiş kabul edilir (GB-22/36 besler).

Idempotency: aynı tradeId/planCorrId bir kez işlenir.

Arayüzler (TypeScript / JSDoc)
// vivo/postureMemory.types.ts
import type { ISODate } from "../core/types";

export type Horizon = "H7"|"H30";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";

export interface PlanOutcome {
  corrId: string;               // plan akışının korelasyon id'si
  planId: PlanId;
  postureAtDecision: Posture;
  asOf: ISODate;
  // Performans (net)
  pnlUsd: number;               // realized net PnL
  rMultiple?: number;           // avg R
  hit?: boolean;                // TP/SL vb. özet
  profitFactor?: number;        // gross win / gross loss
  slippageBps?: number;         // realized vs modeled
  markoutBp_5s?: number;        // ex-post kısa mark-out
  liveVsBtGapPct?: number;      // +: live > BT
}

export interface Rollup {
  n: number;
  pnlUsd: number;
  hitRate: number;
  avgR: number;
  profitFactor: number;
  slipAvgBps: number;
  markAvgBp5s: number;
}

export interface MemorySnapshot {
  asOf: ISODate;
  // Horizon başına toplulaştırmalar
  byPosture: Record<Posture, Record<Horizon, Rollup>>;
  byPlan:    Record<PlanId,  Record<Horizon, Rollup>>;
  // VIVO-01'e geri besleme
  postureWeights: Record<Posture, number>;   // 0..1 normalize
  planWeights:    Record<PlanId, number>;    // 0..1 normalize (A/B/C)
  defaults: { defaultPlan: PlanId };         // VIVO-03 timeout default önerisi
}

export interface UpdateEvent {
  asOf: ISODate;
  outcome: PlanOutcome;
}

export interface MemoryConfig {
  ewmaAlphaShort: number;   // 0.2
  ewmaAlphaLong: number;    // 0.1
  minTradesForWeight: number; // 20 (H30’de)
  tieBreak: PlanId;         // eşitlikte default (örn "A")
}

export interface MemoryStore {
  load(): Promise<MemorySnapshot | null>;
  save(s: MemorySnapshot): Promise<void>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

gb.tca (GB-22/36 sonuçları → PlanOutcome’a maplenmiş)

vivo.uplift (A/B kolu sonuçları; yine PlanOutcome alanlarını doldurur)

Publish:

vivo.memory (MemorySnapshot) – VIVO-01 plan sıralaması, VIVO-03 default, VIVO-02 exec ince ayarı için

audit.log – güncelleme özeti (önce/sonra ağırlıklar)

Validasyon & Tip Kontrolleri

pnlUsd finite; planId ∈ {A,B,C}; postureAtDecision geçerli.

Same corrId ikinci kez gelirse yutulur (idempotent).

Rollup: EWMA (H7 için α=ewmaAlphaShort, H30 için α=ewmaAlphaLong), ayrıca count-weighted agregasyon.

Hata Yönetimi & Logging

Standart hata { code, message, details, retriable }.

audit.log: outcome kabul/ret, rollup önce/sonra, weight değişimleri.

Kod İskeleti
// vivo/postureMemory.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  MemorySnapshot, MemoryConfig, MemoryStore, UpdateEvent, PlanOutcome, Posture, Horizon, Rollup, PlanId, StdError
} from "./postureMemory.types";

const POSTURES: Posture[] = ["RISK_ON","NEUTRAL","RISK_OFF"];
const PLANS: PlanId[] = ["A","B","C"];
const HORIZONS: Horizon[] = ["H7","H30"];

function emptyRoll(): Rollup { return { n:0, pnlUsd:0, hitRate:0, avgR:0, profitFactor:1, slipAvgBps:0, markAvgBp5s:0 }; }

export class InMemoryStore implements MemoryStore {
  private snap: MemorySnapshot | null = null;
  async load(){ return this.snap; }
  async save(s: MemorySnapshot){ this.snap = s; }
}

export class PostureMemory extends EventEmitter {
  ver="1.0.0"; src="VIVO-04";
  private store: MemoryStore;
  private cfg: MemoryConfig;
  private seenCorr = new Set<string>();
  private snap: MemorySnapshot;

  constructor(cfg?: Partial<MemoryConfig>, store?: MemoryStore){
    super();
    this.cfg = { ewmaAlphaShort:0.2, ewmaAlphaLong:0.1, minTradesForWeight:20, tieBreak:"A", ...cfg };
    this.store = store ?? new InMemoryStore();
    this.snap = {
      asOf: new Date().toISOString(),
      byPosture: Object.fromEntries(POSTURES.map(p=>[p, { H7:emptyRoll(), H30:emptyRoll() }])) as any,
      byPlan:    Object.fromEntries(PLANS.map(p=>[p, { H7:emptyRoll(), H30:emptyRoll() }])) as any,
      postureWeights: { RISK_ON:0.34, NEUTRAL:0.33, RISK_OFF:0.33 },
      planWeights: { A:0.5, B:0.35, C:0.15 },
      defaults: { defaultPlan:"A" }
    };
  }

  async attach(){
    const loaded = await this.store.load(); if (loaded) this.snap = loaded;
    bus.on<UpdateEvent>("gb.tca", (evt)=> this.update(evt).catch(e=>logger.error(e,"VIVO-04 update gb.tca")));
    bus.on<UpdateEvent>("vivo.uplift", (evt)=> this.update(evt).catch(e=>logger.error(e,"VIVO-04 update uplift")));
  }

  /** Manuel tetikleme için */
  async update(evt: UpdateEvent): Promise<MemorySnapshot | { error: StdError }> {
    try {
      const o = evt.outcome;
      // idempotency
      if (this.seenCorr.has(o.corrId)) return this.ok();
      const val = this.validate(o); if (val) return this.err("VALIDATION_ERROR", val, { o });

      // EWMA güncelle
      this.ewmaUpdate("byPlan",    o.planId, o);
      this.ewmaUpdate("byPosture", o.postureAtDecision, o);

      // Ağırlıkları hesapla (H30 öncelikli, H7 ile hafif modülasyon)
      this.recomputeWeights();

      // Varsayılan plan önerisi (VIVO-03 timeout default)
      this.recomputeDefaultPlan();

      this.snap.asOf = new Date().toISOString();
      await this.store.save(this.snap);
      this.seenCorr.add(o.corrId);

      // publish
      bus.emit<MemorySnapshot>("vivo.memory", this.snap);
      bus.emit("audit.log", { asOf:this.snap.asOf, ver:this.ver, src:this.src,
        payload:{ msg:"memory updated", corrId:o.corrId, plan:o.planId, posture:o.postureAtDecision,
                  weights:{ posture:this.snap.postureWeights, plan:this.snap.planWeights } } });
      return this.snap;

    } catch (e:any){
      return this.err("MEMORY_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private validate(o: PlanOutcome): string | null {
    if (!o || typeof o.planId!=="string") return "outcome missing/planId invalid";
    if (!["A","B","C"].includes(o.planId)) return "planId not in A/B/C";
    if (!["RISK_ON","NEUTRAL","RISK_OFF"].includes(o.postureAtDecision)) return "invalid postureAtDecision";
    if (!Number.isFinite(o.pnlUsd)) return "pnlUsd invalid";
    return null;
  }

  private ewmaUpdate(target:"byPlan"|"byPosture", key: PlanId | Posture, o: PlanOutcome){
    const h7  = this.snap[target][key]["H7"];
    const h30 = this.snap[target][key]["H30"];
    this.mix(h7,  o, this.cfg.ewmaAlphaShort);
    this.mix(h30, o, this.cfg.ewmaAlphaLong);
  }

  private mix(r: Rollup, o: PlanOutcome, alpha: number){
    // EWMA: x_t = α·obs + (1-α)·x_{t-1}; n: sayma için +1 (cap’leyebiliriz)
    r.n = Math.min(99999, r.n + 1);
    r.pnlUsd        = alpha*o.pnlUsd               + (1-alpha)*r.pnlUsd;
    r.hitRate       = alpha*((o.hit?1:0))          + (1-alpha)*r.hitRate;
    r.avgR          = alpha*(o.rMultiple ?? 0)     + (1-alpha)*r.avgR;
    r.profitFactor  = alpha*(o.profitFactor ?? 1)  + (1-alpha)*r.profitFactor;
    r.slipAvgBps    = alpha*(o.slippageBps ?? 0)   + (1-alpha)*r.slipAvgBps;
    r.markAvgBp5s   = alpha*(o.markoutBp_5s ?? 0)  + (1-alpha)*r.markAvgBp5s;
  }

  private recomputeWeights(){
    // H30’e göre ana ağırlık, H7 ile ±%10 modülasyon
    const wPlan: Record<PlanId, number> = { A:0, B:0, C:0 };
    for (const p of PLANS){
      const r30 = this.snap.byPlan[p]["H30"];
      const r7  = this.snap.byPlan[p]["H7"];
      const base = this.weightFromRoll(r30, this.cfg.minTradesForWeight);
      const mod  = 1 + clamp(this.weightFromRoll(r7, 5) - 0.5, -0.1, 0.1); // ±%10
      wPlan[p] = Math.max(0, base * mod);
    }
    this.snap.planWeights = normalize(wPlan);

    const wPos: Record<Posture, number> = { RISK_ON:0, NEUTRAL:0, RISK_OFF:0 };
    for (const po of POSTURES){
      const r30 = this.snap.byPosture[po]["H30"];
      const r7  = this.snap.byPosture[po]["H7"];
      const base = this.weightFromRoll(r30, this.cfg.minTradesForWeight);
      const mod  = 1 + clamp(this.weightFromRoll(r7, 5) - 0.5, -0.1, 0.1);
      wPos[po] = Math.max(0, base * mod);
    }
    this.snap.postureWeights = normalize(wPos);
  }

  private weightFromRoll(r: Rollup, minN: number){
    // Basit skor: sigmoidal PF + hit + avgR – slipaj cezalı; yetersiz n’de zayıf skor
    const nScale = Math.min(1, r.n / minN);
    const pf = isFinite(r.profitFactor) ? Math.max(0, Math.min(2, r.profitFactor)) : 1;
    const pfScore  = (pf-1)/1;                 // [0..1] ~ PF 1..2
    const hitScore = r.hitRate;                // [0..1]
    const rScore   = Math.max(0, Math.min(1, r.avgR/1.0));   // R≈1 → 1.0
    const slipPen  = Math.min(1, Math.abs(r.slipAvgBps)/20); // 20bps üstü ceza
    const score = clamp(0.5*pfScore + 0.3*hitScore + 0.3*rScore - 0.2*slipPen, 0, 1);
    return score * (0.5 + 0.5*nScale); // az trade’de yarım ağırlık
  }

  private recomputeDefaultPlan(){
    // En yüksek plan weight → default, sık sık C’ye kayıyorsa VIVO-01 planlaması daha korumacı başlar
    const entries = Object.entries(this.snap.planWeights) as Array<[PlanId, number]>;
    entries.sort((a,b)=>b[1]-a[1]);
    const top = entries[0];
    this.snap.defaults.defaultPlan = (top && top[1]>0 ? top[0] : this.cfg.tieBreak);
  }

  private ok(){ return this.snap; }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

// ---- yardımcı ----
function normalize<T extends string>(m: Record<T, number>): Record<T, number> {
  const sum = Object.values(m).reduce((a,b)=>a+b,0) || 1;
  const out = {} as Record<T, number>;
  for (const k in m) out[k as T] = +(m[k as T]/sum).toFixed(4);
  return out;
}

Test İskeleti (Vitest)
// vivo/__tests__/postureMemory.test.ts
import { describe,it,expect } from "vitest";
import { PostureMemory, InMemoryStore } from "../postureMemory";
import type { UpdateEvent } from "../postureMemory.types";

function mkEvt(id:string, plan:"A"|"B"|"C", posture:"RISK_ON"|"NEUTRAL"|"RISK_OFF", pnl:number): UpdateEvent {
  return { asOf:new Date().toISOString(), outcome:{ corrId:id, planId:plan, postureAtDecision:posture, asOf:new Date().toISOString(), pnlUsd:pnl, hit:(pnl>0), profitFactor:pnl>0?1.5:0.8, rMultiple: pnl>0?0.6: -0.3, slippageBps: 6, markoutBp_5s: 2 } };
}

describe("VIVO-04 postureMemory", ()=>{
  it("updates EWMA and publishes snapshot", async ()=>{
    const pm = new PostureMemory({ minTradesForWeight: 5 }, new InMemoryStore());
    await pm.attach(); // load none

    for (let i=0;i<6;i++){
      await pm.update( mkEvt(`x${i}`,"A","NEUTRAL", i%2===0? +100 : -50) );
    }
    const snap:any = await pm.update( mkEvt("x6","B","RISK_ON", +120) );
    expect(snap.byPlan.A.H30.n).toBeGreaterThan(0);
    expect(snap.planWeights.A + snap.planWeights.B + snap.planWeights.C).toBeCloseTo(1, 5);
    expect(["A","B","C"]).toContain(snap.defaults.defaultPlan);
  });

  it("is idempotent by corrId", async ()=>{
    const pm = new PostureMemory({}, new InMemoryStore());
    await pm.attach();
    const evt = mkEvt("dup","A","NEUTRAL",100);
    const s1:any = await pm.update(evt);
    const s2:any = await pm.update(evt); // same corrId
    expect(s2).toEqual(s1); // yutuldu
  });

  it("rejects invalid outcome", async ()=>{
    const pm = new PostureMemory({}, new InMemoryStore());
    await pm.attach();
    const bad:any = { asOf:new Date().toISOString(), outcome:{ corrId:"bad", planId:"Z", postureAtDecision:"NEUTRAL", asOf:new Date().toISOString(), pnlUsd: 10 } };
    const res:any = await pm.update(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });
});

Entegrasyon Akışı

GB-22/36 → gb.tca: Kapanan emir/plan sonuçları PlanOutcome’a maplenip PostureMemory.update()’a akar.

VIVO-04: EWMA ile H7/H30 rollup’ları günceller → planWeights, postureWeights, defaults.defaultPlan.

Publish → vivo.memory:

VIVO-01 plan sıralaması ve postür önerisine ağırlıkları uygular.

VIVO-03 timeout default’ı defaults.defaultPlan ile set eder.

VIVO-02 agresif/temkinli exec tercihlerinde hafif modülasyon yapabilir.
_________________________________________________________________________________________________________________
VIVO-05 · planVariantGenerator.ts

Amaç (tek cümle):
Baz plan(lar)ı A/B/C varyantlarına dönüştürmek: limit ofseti, TWAP süresi, iceberg oranı, çocuk-tipi (LIMIT/IOC/POST_ONLY/MARKET) ve pyramiding parametrelerini RiskNet + Hafıza (VIVO-04) ile modüle etmek.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar verisi yok; yalnız param modülasyonu yapılır.

Risk/Sentinel: AMBER→temkinli mod; RED/CB→yalnız korumacı (C veya reduce-only varyant).

Politika (savunmacı kontrol): whitelist ve minTargetPct ≥ +%4 sağlanmayan sembol varyanta alınmaz.

Binance kuralları doğrudan uygulanmaz (VIVO-02’ye bırakılır); ancak POST_ONLY seçeneğinde cross risk azaltıcı ofset önerisi eklenir.

Hafıza (VIVO-04): planWeights ve postureWeights varyant katsayılarına çevrilir (bounded).

Arayüzler (TypeScript)
// vivo/planVariantGenerator.types.ts
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface BaseExec {
  limitOffsetBps: number;      // ör: 6
  twapMs: number;              // ör: 1400
  iceberg: number;             // 0..1
  childType: ChildType;
}
export interface TrendExec {
  atrK: number;
  pyramid?: { maxAdds:number; addEveryPct:number; sizePct:number };
}
export interface BasePlan {
  id: "A"|"B"|"C";
  title: string;
  symbols: Array<Record<string, number>>;   // {SYMBOL: notionalUsd}
  exec: BaseExec;
  trend?: TrendExec;
  notes?: string[];
}

export interface MemoryWeights {
  postureWeights: Record<Posture, number>;    // 0..1 normalize
  planWeights:    Record<"A"|"B"|"C", number>;
  defaults: { defaultPlan: "A"|"B"|"C" };
}

export interface RiskNetState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
}

export interface Policy {
  whitelist: string[];
  minTargetPct: number;                        // ≥ 4
}

export interface AnalyticsRow {
  expectedMovePct: number;  // kapanmış bar
  R_multiple: number;       // ≥1.2 önerilir
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface VariantPlan extends BasePlan {
  variant: VariantId;
  exec: BaseExec;
  trend?: TrendExec;
  riskHints?: string[];        // VIVO-03 kartlarına not
}

export interface VariantInput {
  posture: Posture;
  risk: RiskNetState;
  memory: MemoryWeights;
  policy: Policy;
  analytics: AnalyticsMap;
  basePlans: BasePlan[];       // VIVO-01’den
}

export interface VariantOutput {
  asOf: string;
  variants: Record<"A"|"B"|"C", VariantPlan[]>;  // her plan için 1–3 varyant
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.posture (VIVO-01 çıktısı) veya doğrudan VariantInput.

Publish: vivo.variants (VariantOutput) ve audit.log (uygulanan katsayılar / risk notları).

Varyant Mantığı (deterministik katsayılar)
Rejim / Kaynak	Katsayı / Etki
Posture = RISK_ON	AGGR: offset −2 bps, TWAP −300ms, iceberg +0.00 → daha hızlı; BAL: baz; CONSV: offset +1 bps, TWAP +150ms, iceberg +0.03
Posture = NEUTRAL	AGGR: offset −1 bps, TWAP −150ms; BAL: baz; CONSV: offset +2 bps, TWAP +300ms, iceberg +0.04
Posture = RISK_OFF	Yalnız CONSV: offset +3 bps, TWAP +400ms, iceberg +0.06; gerekiyorsa childType POST_ONLY öner
Risk level = AMBER	Her varyanta +100–200ms TWAP ekle, iceberg +0.02 bound’la
Sentinel ≠ NORMAL	Sadece CONSV üret; not: “reduce-only önerilir”
Hafıza planWeight	AGGR aktifliği: weightA>0.5 ise A için AGGR açık; düşük ağırlıkta yalnız BAL/CONSV
Politika	whitelist dışı / +%4 altı semboller varyanttan atılır (plan yapısı korunur)

Bound’lar:

limitOffsetBps min 0, max +15;

twapMs min 400ms, max 4000ms;

iceberg min 0.05, max 0.5.

Kod İskeleti
// vivo/planVariantGenerator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  VariantInput, VariantOutput, VariantPlan, BasePlan, VariantId, Policy, AnalyticsMap, StdError
} from "./planVariantGenerator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=0)=> Number(x.toFixed(n));

export class PlanVariantGenerator extends EventEmitter {
  ver="1.0.0"; src="VIVO-05";

  attach(){
    bus.on<VariantInput>("vivo.posture", (env:any)=>{
      // VIVO-01 output → VariantInput’a map edilmiş payload beklenir
      // Eğer doğrudan VIVO-01 formatı geliyorsa küçük bir adaptör yazıp basePlans/analytics/policy ekle.
    });
  }

  run(x: VariantInput): VariantOutput | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const out: VariantOutput = { asOf:new Date().toISOString(), variants:{ A:[], B:[], C:[] } };
      for (const base of x.basePlans){
        const vs = this.buildForPlan(x, base);
        out.variants[base.id] = vs;
      }

      bus.emit<VariantOutput>("vivo.variants", out);
      return out;

    } catch (e:any){
      return this.err("VIVO05_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private buildForPlan(x: VariantInput, base: BasePlan): VariantPlan[] {
    const allowAggressive = x.memory.planWeights[base.id] > 0.5 && x.posture!=="RISK_OFF" && x.risk.sentinel==="NORMAL";
    const arr: VariantPlan[] = [];

    // RISK_OFF ya da sentinel ≠ NORMAL ise yalnız CONSV
    if (x.posture==="RISK_OFF" || x.risk.sentinel!=="NORMAL"){
      const p = this.mkVariant(base, "CONSV", x);
      p.riskHints = ["Risk-Off/Sentinel: reduce-only önerilir", ...(p.riskHints||[])];
      arr.push(p);
      return arr;
    }

    // NEUTRAL / RISK_ON: AGGR (opsiyonel), BAL, CONSV
    if (allowAggressive) arr.push( this.mkVariant(base, "AGGR", x) );
    arr.push( this.mkVariant(base, "BAL", x) );
    arr.push( this.mkVariant(base, "CONSV", x) );

    return arr;
  }

  private mkVariant(base: BasePlan, variant: VariantId, x: VariantInput): VariantPlan {
    // Baz parametreler
    let { limitOffsetBps, twapMs, iceberg, childType } = base.exec;
    const hints:string[] = [];

    // Posture etkisi
    if (x.posture==="RISK_ON"){
      if (variant==="AGGR"){ limitOffsetBps-=2; twapMs-=300; }
      if (variant==="BAL") { /* baz */ }
      if (variant==="CONSV"){ limitOffsetBps+=1; twapMs+=150; iceberg+=0.03; }
    } else if (x.posture==="NEUTRAL"){
      if (variant==="AGGR"){ limitOffsetBps-=1; twapMs-=150; }
      if (variant==="BAL") { /* baz */ }
      if (variant==="CONSV"){ limitOffsetBps+=2; twapMs+=300; iceberg+=0.04; }
    } else { // RISK_OFF (buraya normalde düşmez)
      variant = "CONSV";
      limitOffsetBps+=3; twapMs+=400; iceberg+=0.06; childType = "POST_ONLY";
    }

    // Risk level etkisi (AMBER → temkinli)
    if (x.risk.level==="AMBER"){ twapMs+= (variant==="AGGR"?100:200); iceberg+=0.02; hints.push("AMBER: TWAP↑ iceberg↑"); }

    // Bound’lar
    limitOffsetBps = clamp(limitOffsetBps, 0, 15);
    twapMs         = clamp(twapMs, 400, 4000);
    iceberg        = clamp(iceberg, 0.05, 0.5);

    // Politika: whitelist + minTarget %+4 (analytics’ten filtrele)
    const filteredSyms = base.symbols.filter(o=>{
      const s = Object.keys(o)[0];
      if (!x.policy.whitelist.includes(s)) return false;
      const an = x.analytics[s];
      return an && an.expectedMovePct >= x.policy.minTargetPct && (an.R_multiple ?? 0) >= 1.2;
    });

    const p: VariantPlan = {
      ...base,
      symbols: filteredSyms,
      variant,
      exec: { limitOffsetBps: round(limitOffsetBps), twapMs: Math.round(twapMs), iceberg: round(iceberg, 2), childType },
      trend: base.trend,
      riskHints: hints
    };

    // RISK_OFF/Sentinel uyarısı (güvenlik için iki kez)
    if (x.posture==="RISK_OFF" || x.risk.sentinel!=="NORMAL"){
      p.riskHints = [...(p.riskHints||[]), "Reduce-only / yeni giriş yok"];
      if (p.exec.childType==="LIMIT") p.exec.childType = "POST_ONLY";
    }

    return p;
  }

  private validate(x: VariantInput): string | null {
    if (!x || !Array.isArray(x.basePlans) || x.basePlans.length===0) return "basePlans missing";
    if (!x.memory || !x.memory.planWeights) return "memory weights missing";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be ≥ 4";
    if (!x.analytics) return "analytics missing";
    return null;
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/planVariantGenerator.test.ts
import { describe,it,expect } from "vitest";
import { PlanVariantGenerator } from "../planVariantGenerator";
import type { VariantInput } from "../planVariantGenerator.types";

const base: VariantInput = {
  posture: "NEUTRAL",
  risk: { level:"AMBER", sentinel:"NORMAL" },
  memory: { postureWeights:{RISK_ON:0.3, NEUTRAL:0.5, RISK_OFF:0.2}, planWeights:{A:0.6, B:0.3, C:0.1}, defaults:{ defaultPlan:"A" } },
  policy: { whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct: 4 },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:3.5, R_multiple:1.1 } },
  basePlans: [
    { id:"A", title:"BTC+ETH", symbols:[{"BTCUSDT":10000},{"ETHUSDT":8000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } }
  ]
};

describe("VIVO-05 planVariantGenerator", ()=>{
  it("generates AGGR/BAL/CONSV for eligible plan", ()=>{
    const gen = new PlanVariantGenerator();
    const out:any = gen.run(base);
    expect(out.variants.A.length).toBeGreaterThanOrEqual(2);
    const names = out.variants.A.map((v:any)=>v.variant);
    expect(names).toContain("BAL");
    expect(names).toContain("CONSV");
  });

  it("filters non-compliant symbols by policy", ()=>{
    const gen = new PlanVariantGenerator();
    const out:any = gen.run(base);
    const aggr:any = out.variants.A.find((v:any)=>v.variant==="AGGR") || out.variants.A[0];
    const syms = aggr.symbols.map((o:any)=>Object.keys(o)[0]);
    expect(syms).not.toContain("OPUSDT"); // +%4 altı / R<1.2
  });

  it("risk-off produces conservative only", ()=>{
    const gen = new PlanVariantGenerator();
    const inp = structuredClone(base);
    inp.posture = "RISK_OFF";
    const out:any = gen.run(inp);
    expect(out.variants.A.length).toBe(1);
    expect(out.variants.A[0].variant).toBe("CONSV");
  });
});

Entegrasyon Akışı

VIVO-01 baz planları ve soruları üretir → VIVO-03 kart/diolog; operatör seçiminden önce veya sonra VIVO-05 varyant setini verir (ikisi de mümkün).

VIVO-05: Plan başına AGGR/BAL/CONSV parametreleri üretir → vivo.variants.

VIVO-03 kartları: Varyant özetlerini seçenek olarak gösterebilir (opsiyonel).

VIVO-02: Seçilen varyant planını child order’lara çevirir (tick/lot/notional/post-only denetimleri).
_________________________________________________________________________________________________________________
VIVO-06 · planFeasibilityChecker.ts

Amaç (tek cümle):
Plan A/B/C (+ varyant) için tick/lot/(min_)notional/percent-price/post-only, exposure gates, risk/sentinel, +%4 hedef & whitelist kapılarını hızlıca değerlendirip feasible? + score + reasons[] üretmek.

Gerçek Dünya Kuralları

Kapanmamış bar yok; expectedMove % kapanmış barlardan (VIVO-01/VIVO-05’ten) gelir.

Risk/Sentinel: SLOWDOWN/HALT_PARTIAL/CIRCUIT_BREAKER → yeni giriş yok (reduce-only öner).

Binance kuralları simülasyon (kuantize etmeden önce): fiyatı tick’e, miktarı step’e varsayımsal yuvarla ve (MIN_)NOTIONALı kontrol et. Post-only için cross etmeme kuralını kontrol et.

Policy: whitelist dışı veya minTargetPct < +%4 olan semboller fail gerekçesiyle düşer.

Hız: Bu modül tek geçişte karar verir; gerçek emir üretimi VIVO-02’de.

Arayüzler (TypeScript)
// vivo/planFeasibilityChecker.types.ts
export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";

export interface ExecParams {
  limitOffsetBps: number;
  twapMs: number;
  iceberg: number;
  childType: ChildType;
}
export interface PlanSymbol {
  symbol: string;
  notionalUsd: number;
  side?: Side;
}
export interface PlanIn {
  id: "A"|"B"|"C";
  title: string;
  symbols: PlanSymbol[];
  exec: ExecParams;
  notes?: string[];
}

export interface Policy {
  whitelist: string[];
  minTargetPct: number; // ≥4
}

export interface AnalyticsRow {
  expectedMovePct: number; // ≥ minTargetPct olmalı
  R_multiple: number;      // ≥ 1.2 önerilir
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface BookTicker {
  symbol: string;
  bid: number; ask: number; mid: number;
}
export interface ExchangeRule {
  symbol: string;
  tickSize: number;
  stepSize: number;
  minNotional: number;
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;
  maxPositionQty?: number;
  currentPositionQty?: number;
}

export interface FeasibilityInput {
  plan: PlanIn;
  posture: Posture;
  sentinel: Sentinel;
  policy: Policy;
  analytics: AnalyticsMap;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  exposure: Record<string, ExposureGate>;
}

export interface SymbolCheck {
  symbol: string;
  side: Side;
  intendedNotionalUsd: number;
  feasible: boolean;
  reasons: string[];
  simulated?: { price:number; qty:number; notional:number; ruleHits:string[] };
}

export interface FeasibilityResult {
  planId: "A"|"B"|"C";
  feasible: boolean;
  score: number;           // 0..100
  reasons: string[];       // plan genel nedenleri
  symbols: SymbolCheck[];  // sembol bazlı detay
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Skor & Kurallar (özet)

Başlangıç 100 puan; her ihlal ceza:

whitelist dışı / +%4 altı / R<1.2: −25

DENY/REDUCE_ONLY (yeni giriş): −35

(MIN_)NOTIONAL yetersiz: −20

post-only cross riski: −10

tick/step uyumsuz (kuantize sonrası qty 0): −20

sentinel≠NORMAL (yeni giriş): plan bazında −40 ve feasible=false

score<60 → feasible=false. Sembol bazlı feasible=false olsa bile plan birkaç sembolle geçebilir.

Kod İskeleti
// vivo/planFeasibilityChecker.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  FeasibilityInput, FeasibilityResult, SymbolCheck, PlanIn, ExecParams, StdError, BookTicker, ExchangeRule
} from "./planFeasibilityChecker.types";

const roundTo = (x:number, step:number)=> Math.round(x/step)*step;
const floorTo = (x:number, step:number)=> Math.floor(x/step)*step;

export class PlanFeasibilityChecker extends EventEmitter {
  ver="1.0.0"; src="VIVO-06";

  run(x: FeasibilityInput): FeasibilityResult | { error: StdError } {
    try {
      const val = this.validate(x); if (val) return this.err("VALIDATION_ERROR", val);
      const reasons: string[] = [];
      let score = 100;

      // Sentinel: yeni girişlere izin yoksa planı reddet (reduce-only bilgi amaçlı)
      const hardHalt = (x.sentinel!=="NORMAL");
      if (hardHalt) { reasons.push(`sentinel=${x.sentinel}: new opens not allowed (reduce-only)`); score -= 40; }

      const symChecks: SymbolCheck[] = [];
      for (const ps of x.plan.symbols) {
        symChecks.push( this.checkSymbol(x, ps.symbol.toUpperCase(), ps.notionalUsd, ps.side ?? "BUY", x.plan.exec) );
      }

      // Plan düzeyli değerlendirme
      const failCount = symChecks.filter(s=>!s.feasible).length;
      if (failCount === symChecks.length) {
        reasons.push("all symbols infeasible");
        score -= 30;
      } else if (failCount>0) {
        reasons.push(`${failCount} symbols infeasible`);
        score -= 10;
      }

      if (hardHalt) {
        return { planId: x.plan.id, feasible:false, score: Math.max(0, score), reasons, symbols: symChecks };
      }

      const feasible = score >= 60 && symChecks.some(s=>s.feasible);
      return { planId: x.plan.id, feasible, score: Math.max(0, score), reasons, symbols: symChecks };

    } catch (e:any){
      return this.err("FEASIBILITY_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private checkSymbol(x: FeasibilityInput, sym:string, intendedNotional:number, side:"BUY"|"SELL", exec: ExecParams): SymbolCheck {
    const reasons: string[] = [];
    let feasible = true;
    const ruleHits: string[] = [];

    // Policy: whitelist / +%4
    if (!x.policy.whitelist.includes(sym)) { feasible=false; reasons.push("whitelist"); }
    const an = x.analytics[sym];
    if (!an || an.expectedMovePct < x.policy.minTargetPct) { feasible=false; reasons.push("minTarget"); }
    if (!an || (an.R_multiple ?? 0) < 1.2) { reasons.push("lowR"); } // uyarı; planı tek başına öldürmez

    // Exposure gates
    const gate = x.exposure[sym];
    if (!gate || gate.decision==="DENY") { feasible=false; reasons.push("exposure=DENY"); }
    if (gate?.decision==="REDUCE_ONLY") { feasible=false; reasons.push("exposure=REDUCE_ONLY"); }
    if (gate?.decision==="TRIM" && gate.allowedNotionalUsd!==undefined) {
      intendedNotional = Math.min(intendedNotional, gate.allowedNotionalUsd);
      ruleHits.push("trim");
      if (intendedNotional<=0) { feasible=false; reasons.push("trim→zero"); }
    }

    const r = x.rules[sym];  const t = x.tickers[sym];
    if (!r || !t || !Number.isFinite(t.bid) || !Number.isFinite(t.ask)) {
      feasible=false; reasons.push("missing rules/ticker");
      return { symbol:sym, side, intendedNotionalUsd:intendedNotional, feasible, reasons };
    }

    // Fiyat simülasyonu (limit/IOC/post-only ofsetleri göz önünde; market için ask/bid)
    const price = this.simPrice(side, exec, t, r);
    // LOT_SIZE kuantizasyon (simülasyon)
    const qty0 = intendedNotional / price;
    const qty  = floorTo(qty0, r.stepSize);
    const notional = price * qty;

    if (qty<=0) { feasible=false; reasons.push("step→qty=0"); }
    if (notional < r.minNotional) { feasible=false; reasons.push("minNotional"); }

    // Post-only cross kontrol
    if (exec.childType==="POST_ONLY") {
      const crosses = (side==="BUY") ? (price >= t.bid) : (price <= t.ask);
      if (crosses) { feasible=false; reasons.push("post-only-cross"); }
    }

    return {
      symbol:sym, side, intendedNotionalUsd:intendedNotional,
      feasible, reasons,
      simulated:{ price, qty, notional, ruleHits }
    };
  }

  private simPrice(side:"BUY"|"SELL", exec: ExecParams, t: BookTicker, r: ExchangeRule){
    const ofs = (exec.limitOffsetBps||0)/10_000;
    let px = t.mid;
    if (exec.childType==="MARKET") px = (side==="BUY") ? t.ask : t.bid;
    else if (exec.childType==="IOC") px = (side==="BUY") ? t.ask*(1+ofs) : t.bid*(1-ofs);
    else if (exec.childType==="POST_ONLY") px = (side==="BUY") ? t.bid*(1-Math.max(ofs,0.0001)) : t.ask*(1+Math.max(ofs,0.0001));
    else /* LIMIT */ px = (side==="BUY") ? t.ask*(1+ofs) : t.bid*(1-ofs);

    // tick yuvarlama
    px = roundTo(px, r.tickSize);
    // post-only güvenliği (cross olmasın)
    if (exec.childType==="POST_ONLY"){
      if (side==="BUY" && px >= t.bid) px = roundTo(t.bid - r.tickSize, r.tickSize);
      if (side==="SELL" && px <= t.ask) px = roundTo(t.ask + r.tickSize, r.tickSize);
    }
    return px;
  }

  private validate(x: FeasibilityInput): string | null {
    if (!x.plan || !x.plan.symbols?.length) return "empty plan";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be ≥4";
    if (!x.rules || !x.tickers) return "missing rules/tickers";
    if (!x.analytics) return "missing analytics";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/planFeasibilityChecker.test.ts
import { describe,it,expect } from "vitest";
import { PlanFeasibilityChecker } from "../planFeasibilityChecker";
import type { FeasibilityInput } from "../planFeasibilityChecker.types";

const rules = {
  BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10 },
  ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10 }
};
const ticks = {
  BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005 },
  ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5 }
};
const base: FeasibilityInput = {
  plan: { id:"A", title:"BTC+ETH", symbols:[{symbol:"BTCUSDT", notionalUsd:10_000},{symbol:"ETHUSDT", notionalUsd:5_000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
  posture:"NEUTRAL", sentinel:"NORMAL",
  policy:{ whitelist:["BTCUSDT","ETHUSDT"], minTargetPct:4 },
  analytics:{ BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 } },
  rules, tickers: ticks,
  exposure:{ BTCUSDT:{ decision:"ALLOW", currentPositionQty:0 }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd:4000, currentPositionQty:0 } }
};

describe("VIVO-06 planFeasibilityChecker", ()=>{
  it("passes feasible plan", ()=>{
    const f = new PlanFeasibilityChecker();
    const res:any = f.run(base);
    expect(res.feasible).toBe(true);
    expect(res.score).toBeGreaterThan(60);
  });

  it("rejects with sentinel halt", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.sentinel = "HALT_PARTIAL";
    const res:any = f.run(inp);
    expect(res.feasible).toBe(false);
    expect(res.reasons.join(" ")).toMatch(/reduce-only/);
  });

  it("flags post-only cross", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.plan.exec.childType = "POST_ONLY";
    // BUY için price ≥ bid olursa cross sayacağız; checker bunu yakalamalı
    const res:any = f.run(inp);
    const btc = res.symbols.find((s:any)=>s.symbol==="BTCUSDT");
    expect(btc.reasons.join(",")).not.toContain("post-only-cross"); // çünkü module fiyatı bid-tick'e çeker
  });

  it("fails non-whitelist", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.policy.whitelist = ["BTCUSDT"]; // ETH yok
    const res:any = f.run(inp);
    const eth = res.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.feasible).toBe(false);
    expect(eth.reasons).toContain("whitelist");
  });
});

Entegrasyon Akışı

VIVO-03 operatör seçimi → VIVO-06 ile hızlı feasibility check.

VIVO-06 sonucu UI’de kısa gerekçe kartı olarak gösterilebilir: score, reasons[], sembol bazlı notlar.

VIVO-02 yalnız feasible=true planı çocuk emirlere çevirir; feasible=false ise operatorDialog fallback/yeniden seçim akışı tetiklenir.

Tüm gerekçeler audit.log’a düşer → Denetim Asistanı/GB-36 tarafından raporlanır.
_________________________________________________________________________________________________________________
VIVO-06 · planFeasibilityChecker.ts

Amaç (tek cümle):
Plan(lar)ın icra edilebilirliğini hızlı ve deterministik şekilde skorlarken, başarısızlıklara gerekçe ve otomatik düzeltme önerileri üretmek (örn. notional trim, POST_ONLY, TWAP↑, iceberg↑).

Gerçek Dünya Kuralları (latency-safe)

Binance filtreleri: PRICE_FILTER (tick), LOT_SIZE (step), (MIN_)NOTIONAL, PERCENT_PRICE(_BY_SIDE), MAX_POSITION, MARKET_LOT_SIZE (varsa).

Risk/Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER → yeni açılışlar uygunsuz (sadece reduce-only öner).

Politika kapıları: whitelist ve minTargetPct ≥ +%4 (savunmacı tekrar doğrula).

Bakiye kontrolü (opsiyonel): Quote bakiyesi yetersizse quick-fix → notional↓ veya planC.

Kapanmamış bar yok: expectedMove/ATR kapanmış barlardan gelmiş olmalı (VIVO-01/GB).

Hız: Sadece ön kontrol yapar; kesin kuantizasyon VIVO-02’dedir.

Arayüzler (TypeScript)
// vivo/planFeasibilityChecker.types.ts
export type Level = "GREEN"|"AMBER"|"RED";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
export type VariantId = "AGGR"|"BAL"|"CONSV";

export interface BaseExec {
  limitOffsetBps:number; twapMs:number; iceberg:number; childType:ChildType;
}

export interface VariantPlan {
  id:"A"|"B"|"C";
  title:string;
  variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: BaseExec;
  notes?: string[];
}

export interface AnalyticsRow { expectedMovePct:number; R_multiple:number; }
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  percent?: { up:number; down:number; refMins?:number };
  maxPositionQty?: number;
  status?: "TRADING"|"HALT"|"BREAK";
  permissions?: string[]; // ["SPOT", ...]
}

export interface BookTicker {
  symbol:string; bid:number; ask:number; mid:number; asOf:string; refPrice?:number;
}

export interface ExposureGate {
  decision:"ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?:number;
  currentPositionQty?:number;
}

export interface Balances {
  // hızlı kontrol için (opsiyonel) toplam kullanılabilir quote USD eşleniği
  freeQuoteUsd?: number;
}

export interface Policy {
  whitelist:string[];
  minTargetPct:number; // ≥4
}

export interface RiskState {
  level:Level; sentinel:Sentinel; posture:Posture;
}

export interface FeasInput {
  plans: VariantPlan[];                  // VIVO-01 veya VIVO-05’ten
  analytics: AnalyticsMap;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  exposure: Record<string, ExposureGate>;
  balances?: Balances;
  policy: Policy;
  risk: RiskState;
}

export interface ItemFinding {
  type:
    | "WHITELIST" | "TARGET_PCT" | "SYMBOL_STATUS" | "PERMISSIONS"
    | "DENY" | "REDUCE_ONLY" | "TRIM"
    | "MIN_NOTIONAL" | "PERCENT_PRICE" | "MAX_POSITION" | "BALANCE"
    | "SENTINEL"
    | "OK";
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string; // öneri metni
}

export interface SymbolFeas {
  symbol:string;
  requestedNotionalUsd:number;
  estimatedPrice:number;
  estimatedQty:number;
  score:number; // 0..100
  findings: ItemFinding[];
  adjustedNotionalUsd?: number; // TRIM sonrası
}

export interface PlanFeas {
  planId:"A"|"B"|"C";
  variant?: VariantId;
  score:number; // 0..100 (sembol skorlarının weighted avg’i)
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf:string;
  overallScore:number;
  plans: PlanFeas[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.variants (VIVO-05) veya vivo.posture (VIVO-01 baz plan).

Publish: vivo.feasibility (FeasOutput), audit.log (özet neden listesi + skorlar).

Skor & Mantık (özet)

Başlangıç 100; her sorun −penalty.

ERROR: −40…−100 (örn. DENY, SENTINEL, SYMBOL_STATUS≠TRADING).

WARN: −10…−30 (örn. TRIM, MIN_NOTIONAL yakın, PERCENT_PRICE bandına dayalı).

INFO: −0…−5 (örn. permissions eksikliği uyarısı).

Plan skoru: sembol skor ağırlıklı ortalama (notional ağırlığı).

overallScore: plan skorlarının ortalaması.

Kod İskeleti
// vivo/planFeasibilityChecker.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  FeasInput, FeasOutput, PlanFeas, SymbolFeas, ItemFinding, VariantPlan,
  ExchangeRule, BookTicker, StdError
} from "./planFeasibilityChecker.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class PlanFeasibilityChecker extends EventEmitter {
  ver="1.0.0"; src="VIVO-06";

  attach(){
    bus.on<FeasInput>("vivo.variants", (env)=> this.safeRun(env));
  }

  safeRun(x: FeasInput): void {
    const res = this.run(x);
    if ("error" in (res as any)) {
      const e:any = res as any;
      logger.error(e, "VIVO-06 failed");
    } else {
      bus.emit<FeasOutput>("vivo.feasibility", res as FeasOutput);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src,
        payload:{ msg:"feas computed", overall:(res as FeasOutput).overallScore }});
    }
  }

  run(x: FeasInput): FeasOutput | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const plans: PlanFeas[] = x.plans.map(p=> this.checkPlan(x, p));
      const overall = Math.round( plans.reduce((a,b)=>a+b.score,0) / Math.max(1, plans.length) );

      const out: FeasOutput = { asOf: new Date().toISOString(), overallScore: overall, plans };
      return out;

    } catch (e:any){
      return this.err("FEAS_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private checkPlan(x: FeasInput, plan: VariantPlan): PlanFeas {
    const symFeas: SymbolFeas[] = [];
    for (const o of plan.symbols){
      const s = Object.keys(o)[0];
      const notional = Object.values(o)[0] as number;
      symFeas.push( this.checkSymbol(x, s, notional, plan) );
    }

    // Plan skor: notional ağırlıklı ortalama
    const totalNotional = symFeas.reduce((a,b)=>a+b.requestedNotionalUsd, 0) || 1;
    let score = 0;
    for (const f of symFeas) score += f.score * (f.requestedNotionalUsd/totalNotional);
    score = Math.round(score);

    // Özet bulgular
    const summary: ItemFinding[] = [];
    if (x.risk.sentinel!=="NORMAL") {
      summary.push({ type:"SENTINEL", severity:"ERROR", message:`Sentinel=${x.risk.sentinel}; yeni açılışlar önerilmez`, quickFix:"PlanC / reduce-only" });
    }
    if (score<60) summary.push({ type:"BALANCE", severity:"WARN", message:"Plan skoru düşük; parametreleri korumacı yap", quickFix:"TWAP+200ms, iceberg+0.02, POST_ONLY" });

    const recommend = score>=80 ? "OK" : score>=60 ? "ADJUST" : "REJECT";

    return { planId: plan.id, variant: plan.variant, score, symbols: symFeas, summaryFindings: summary, recommend };
  }

  private checkSymbol(x: FeasInput, symbol: string, notionalUsd: number, plan: VariantPlan): SymbolFeas {
    const findings: ItemFinding[] = [];
    let score = 100;

    // whitelist / target
    if (!x.policy.whitelist.includes(symbol)){
      findings.push({ type:"WHITELIST", severity:"ERROR", message:`${symbol} whitelist dışı` });
      score -= 100;
    }
    const an = x.analytics[symbol];
    if (!an || an.expectedMovePct < x.policy.minTargetPct || (an.R_multiple ?? 0) < 1.2){
      findings.push({ type:"TARGET_PCT", severity:"ERROR", message:`${symbol} +%${x.policy.minTargetPct} hedefi/R threshold karşılanmıyor` });
      score -= 40;
    }

    // risk/sentinel
    if (x.risk.sentinel!=="NORMAL"){
      findings.push({ type:"SENTINEL", severity:"ERROR", message:`Sentinel=${x.risk.sentinel}`, quickFix:"Yeni açılış yok; reduce-only" });
      score -= 40;
    }

    const rule: ExchangeRule | undefined = x.rules[symbol];
    const tk: BookTicker | undefined = x.tickers[symbol];
    if (!rule || !tk) {
      findings.push({ type:"SYMBOL_STATUS", severity:"ERROR", message:"rule/ticker eksik" });
      return this.buildSym(symbol, notionalUsd, tk?.mid ?? 0, 0, score, findings);
    }

    if (rule.status && rule.status!=="TRADING"){
      findings.push({ type:"SYMBOL_STATUS", severity:"ERROR", message:`status=${rule.status}` });
      score -= 100;
    }
    if (rule.permissions && !rule.permissions.includes("SPOT")){
      findings.push({ type:"PERMISSIONS", severity:"WARN", message:`permissions=${rule.permissions?.join(",")}` });
      score -= 5;
    }

    // exposure
    const gate = x.exposure[symbol];
    if (!gate || gate.decision==="DENY"){
      findings.push({ type:"DENY", severity:"ERROR", message:"EXPOSURE=DENY" });
      score -= 100;
    } else if (gate.decision==="REDUCE_ONLY"){
      findings.push({ type:"REDUCE_ONLY", severity:"ERROR", message:"EXPOSURE=REDUCE_ONLY", quickFix:"Yeni açılış yerine kapama/trim" });
      score -= 50;
    } else if (gate.decision==="TRIM" && gate.allowedNotionalUsd!==undefined && notionalUsd>gate.allowedNotionalUsd){
      findings.push({ type:"TRIM", severity:"WARN", message:`notional>${gate.allowedNotionalUsd}`, quickFix:`${gate.allowedNotionalUsd} USD’ye düşür` });
      score -= 15;
      notionalUsd = gate.allowedNotionalUsd; // değerlendirmeyi trimlenmiş notional ile sürdür
    }

    // fiyat/qty kaba tahmin (VIVO-02 kesinleştirir)
    const side: Side = "BUY";
    let px = this.targetPrice(side, plan.exec.childType, plan.exec.limitOffsetBps, tk, rule);
    const qty = Math.floor((notionalUsd / px) / rule.stepSize) * rule.stepSize;
    const notion = px * qty;

    // minNotional
    if (notion < rule.minNotional){
      findings.push({ type:"MIN_NOTIONAL", severity:"ERROR", message:`$${notion.toFixed(2)} < minNotional $${rule.minNotional}`, quickFix:`notional↑ veya sembol atla` });
      score -= 30;
    }

    // percent-price bandı (uyarı)
    if (rule.percent){
      const ref = tk.refPrice ?? tk.mid;
      const lo = ref * rule.percent.down;
      const hi = ref * rule.percent.up;
      if (px < lo || px > hi){
        findings.push({ type:"PERCENT_PRICE", severity:"WARN", message:"Fiyat percent-price bandı dışında", quickFix:"offset bps ayarla / POST_ONLY" });
        score -= 10;
      }
    }

    // max position (opsiyonel)
    if (rule.maxPositionQty!==undefined && (gate?.currentPositionQty ?? 0) + qty > rule.maxPositionQty){
      findings.push({ type:"MAX_POSITION", severity:"ERROR", message:"MAX_POSITION aşımı", quickFix:"qty↓ / reduce-only" });
      score -= 40;
    }

    // bakiye (opsiyonel)
    if (x.balances?.freeQuoteUsd!==undefined && notionalUsd > x.balances.freeQuoteUsd){
      findings.push({ type:"BALANCE", severity:"WARN", message:"free quote yetersiz", quickFix:"notional↓ / PlanC spot/nakit" });
      score -= 20;
    }

    // POST_ONLY önerisi (çapraz risk)
    if (plan.exec.childType==="POST_ONLY"){
      // güvenli tarafta kal; bilgi amaçlı not
      findings.push({ type:"OK", severity:"INFO", message:"POST_ONLY: cross risk düşük" });
    }

    score = clamp(score, 0, 100);
    return this.buildSym(symbol, notionalUsd, px, qty, score, findings);
  }

  private targetPrice(side:"BUY"|"SELL", type:ChildType, offsetBps:number, t:BookTicker, r:ExchangeRule){
    const ofs = (offsetBps||0)/10_000;
    let base = side==="BUY" ? t.ask*(1+ofs) : t.bid*(1-ofs);
    if (type==="POST_ONLY") base = side==="BUY" ? t.bid*(1-Math.max(ofs, 0.0001)) : t.ask*(1+Math.max(ofs, 0.0001));
    // tick’e yuvarla
    const price = Math.round(base / r.tickSize) * r.tickSize;
    return price;
  }

  private buildSym(symbol:string, req:number, px:number, qty:number, score:number, findings:ItemFinding[]): SymbolFeas {
    return {
      symbol, requestedNotionalUsd:req,
      estimatedPrice: px, estimatedQty: qty,
      score, findings
    };
  }

  private validate(x: FeasInput): string | null {
    if (!x || !Array.isArray(x.plans) || x.plans.length===0) return "plans missing";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be ≥ 4";
    if (!x.rules || !x.tickers || !x.exposure) return "rules/tickers/exposure missing";
    if (!x.risk) return "risk missing";
    return null;
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/planFeasibilityChecker.test.ts
import { describe,it,expect } from "vitest";
import { PlanFeasibilityChecker } from "../planFeasibilityChecker";
import type { FeasInput } from "../planFeasibilityChecker.types";

const rules = {
  BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, percent:{up:1.2,down:0.8}, status:"TRADING", permissions:["SPOT"] },
  ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10, status:"TRADING", permissions:["SPOT"] }
};
const tickers = {
  BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
  ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() }
};
const base: FeasInput = {
  plans:[
    { id:"A", title:"BTC+ETH", symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } }
  ],
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 } },
  rules, tickers,
  exposure: { BTCUSDT:{ decision:"ALLOW", currentPositionQty:0 }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd:3000, currentPositionQty:0 } },
  balances:{ freeQuoteUsd: 9000 },
  policy:{ whitelist:["BTCUSDT","ETHUSDT"], minTargetPct:4 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" }
};

describe("VIVO-06 planFeasibilityChecker", ()=>{
  it("scores plans and gives quick-fixes", ()=>{
    const fc = new PlanFeasibilityChecker();
    const out:any = fc.run(base);
    expect(out.overallScore).toBeGreaterThan(0);
    const pA = out.plans.find((p:any)=>p.planId==="A");
    expect(pA.symbols.length).toBe(2);
    expect(pA.symbols.find((s:any)=>s.symbol==="ETHUSDT").findings.some((f:any)=>f.type==="TRIM")).toBe(true);
  });

  it("rejects non-whitelist or sentinel halt", ()=>{
    const fc = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.policy.whitelist = ["BTCUSDT"]; // ETH dışı
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = fc.run(inp);
    const pA = out.plans.find((p:any)=>p.planId==="A");
    expect(pA.summaryFindings.some((f:any)=>f.type==="SENTINEL")).toBe(true);
    const eth = pA.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.findings.some((f:any)=>f.type==="WHITELIST")).toBe(true);
  });
});

Entegrasyon Akışı

VIVO-05 → vivo.variants: Varyant planları yayınlar.

VIVO-06: Feasibility skorlar/ neden listeleri/ quick-fix üretir → vivo.feasibility.

VIVO-03: Kartlarda score ve kritik uyarıları gösterir; operatör ADJUST/REJECT kararına yardımcı olur.

VIVO-02: TRIM ve POST_ONLY gibi quick-fix ipuçlarını doğrudan uygular (ör. allowedNotional’a kesme).
_________________________________________________________________________________________________________________
VIVO-07 · explainabilityReporter.ts

Amaç (tek cümle):
Seçilen plan/varyantın neden seçildiğini; hangi risk, hafıza, politika ve uygulanabilirlik kriterlerini geçtiğini, hangi alternatiflerin neden elendiğini ve bir sonraki adımları operatöre (Telegram/CLI) ve log sistemine açıklamak.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; tüm metrikler kapanmış bar/işlem sonuçlarından gelir (VIVO-01/GB & VIVO-04/22/36).

Idempotency: Aynı corrId için birden fazla kart üretme.

Redline/CB: Sentinel NORMAL değilse, kart “reduce-only” tavsiyesiyle işaretlenir.

Politika/güvenlik: Whitelist, minTargetPct ≥ +%4 ihlalleri karta net yazılır.

TCA farkları: (varsa) modeled vs realized slipaj/mark-out kısa özeti.

Arayüzler (TypeScript)
// vivo/explainabilityReporter.types.ts
import type { ISODate } from "../core/types";

// Özet tipler (diğer modüllerden sadeleştirilmiş)
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type PlanId = "A"|"B"|"C";

export interface MemorySnapshot {
  asOf: ISODate;
  postureWeights: Record<Posture, number>;
  planWeights: Record<PlanId, number>;
  defaults: { defaultPlan: PlanId };
}

export interface VariantPlan {
  id: PlanId;
  title: string;
  variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  riskHints?: string[];
  notes?: string[];
}

export interface VariantOutput {
  asOf: ISODate;
  variants: Record<PlanId, VariantPlan[]>;
}

export interface ItemFinding {
  type: string;     // "WHITELIST"|"TARGET_PCT"|... (VIVO-06)
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}
export interface SymbolFeas {
  symbol: string;
  requestedNotionalUsd: number;
  estimatedPrice: number;
  estimatedQty: number;
  score: number;             // 0..100
  findings: ItemFinding[];
}
export interface PlanFeas {
  planId: PlanId;
  variant?: VariantId;
  score: number;             // plan feasibility score 0..100
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}
export interface FeasOutput {
  asOf: ISODate;
  overallScore: number;
  plans: PlanFeas[];
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;
  confirmations: Record<number,string>;  // 0: plan seçimi, 1: +%4 onayı vb.
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface ActionBundle {
  asOf: ISODate;
  planId: PlanId;
  children: Array<{
    symbol: string; side: "BUY"|"SELL"; type: string;
    price?: number; qty: number; reduceOnly?: boolean; postOnly?: boolean;
    meta?: { twapMs?: number; slice?: number; slices?: number; iceberg?: number; corrId?: string };
  }>;
  comments?: string[];
}

// Rapor biçimi
export interface ExplainNode {
  label: string;
  value?: string|number;
  children?: ExplainNode[];
  severity?: "INFO"|"WARN"|"ERROR";
}

export interface ExplainCard {
  corrId: string;
  asOf: ISODate;
  header: {
    posture: Posture;
    sentinel: Sentinel;
    decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
    selected: { planId: PlanId; variant?: VariantId; title?: string };
  };
  weights: {
    posture: Record<Posture, number>;
    plans: Record<PlanId, number>;
    defaultPlan: PlanId;
  };
  feasibility: {
    selectedScore: number;
    altScores: Array<{ planId: PlanId; variant?: VariantId; score: number }>;
    topFindings: ItemFinding[];
  };
  policyCompliance: ExplainNode[];   // whitelist / +%4 / exposure vs.
  execSummary?: {
    childCount: number;
    reduceOnlyRatio: number;
    postOnlyCount: number;
    notionalUsd: number;
  };
  whyTree: ExplainNode[];            // “neden seçildi?” ağacı
  nextSteps: string[];               // quick-fix / operatör aksiyonları
}

export interface ReporterInput {
  corrId: string;
  posture: Posture;
  sentinel: Sentinel;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Kod İskeleti
// vivo/explainabilityReporter.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  MemorySnapshot, VariantOutput, FeasOutput, OperatorResult, ActionBundle,
  ExplainCard, ExplainNode, ReporterInput, StdError, PlanId, VariantPlan, PlanFeas
} from "./explainabilityReporter.types";

export class ExplainabilityReporter extends EventEmitter {
  ver="1.0.0"; src="VIVO-07";
  private seen = new Set<string>();
  private memory: MemorySnapshot | null = null;
  private variants: VariantOutput | null = null;
  private feas: FeasOutput | null = null;
  private lastSelection: OperatorResult | null = null;
  private lastActions: ActionBundle | null = null;

  attach(){
    bus.on<MemorySnapshot>("vivo.memory",  (m)=>{ this.memory = m; });
    bus.on<VariantOutput>("vivo.variants", (v)=>{ this.variants = v; });
    bus.on<FeasOutput>("vivo.feasibility",(f)=>{ this.feas = f; });
    bus.on<OperatorResult>("vivo.operator.result",(r)=>{ this.lastSelection = r; });
    bus.on<ActionBundle>("ops.actions",(a)=>{ this.lastActions = a; });
    // İsteğe bağlı tetikleyici: seçim ya da feasibility geldiğinde kart üret
    bus.on<ReporterInput>("vivo.explain.request", (req)=> this.safeBuild(req));
  }

  safeBuild(req: ReporterInput){
    const res = this.build(req);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-07 build failed");
    } else {
      const card = res as ExplainCard;
      bus.emit<ExplainCard>("vivo.explain.card", card);
      bus.emit("audit.log", { asOf:card.asOf, ver:this.ver, src:this.src, payload:{ corrId:card.corrId, selected:card.header.selected, score:card.feasibility.selectedScore }});
    }
  }

  build(req: ReporterInput): ExplainCard | { error: StdError } {
    try {
      if (!req?.corrId) return this.err("VALIDATION_ERROR","corrId missing");
      if (this.seen.has(req.corrId)) return this.err("IDEMPOTENT","corrId already explained",{corrId:req.corrId});
      if (!this.memory || !this.variants || !this.feas || !this.lastSelection) {
        return this.err("STATE_MISSING","memory/variants/feas/selection missing");
      }

      const selectedPlanId = this.lastSelection.selectedPlanId;
      const selVar = this.pickSelectedVariant(selectedPlanId);
      const feasSel = this.pickFeas(selectedPlanId, selVar?.variant);

      const card: ExplainCard = {
        corrId: req.corrId,
        asOf: new Date().toISOString(),
        header: {
          posture: req.posture,
          sentinel: req.sentinel,
          decidedBy: this.lastSelection.decidedBy,
          selected: { planId: selectedPlanId, variant: selVar?.variant, title: selVar?.title }
        },
        weights: {
          posture: this.memory.postureWeights,
          plans: this.memory.planWeights,
          defaultPlan: this.memory.defaults.defaultPlan
        },
        feasibility: {
          selectedScore: feasSel?.score ?? 0,
          altScores: this.altScores(feasSel),
          topFindings: this.topFindings(feasSel)
        },
        policyCompliance: this.policyNodes(selVar, feasSel),
        execSummary: this.execSummary(this.lastActions, selectedPlanId),
        whyTree: this.buildWhyTree(selVar, feasSel),
        nextSteps: this.suggestNext(selVar, feasSel, req.sentinel)
      };

      this.seen.add(req.corrId);
      return card;

    } catch (e:any){
      return this.err("EXPLAIN_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- yardımcılar ---
  private pickSelectedVariant(planId: PlanId): VariantPlan | null {
    const arr = this.variants?.variants?.[planId] ?? [];
    // Operatör kartında varyant seçimi ayrıysa burada default: en yüksek feasibility skoru
    const bestFeas = this.feas?.plans
      ?.filter(p=>p.planId===planId)
      .sort((a,b)=>b.score-a.score)[0];
    if (bestFeas) {
      const vp = arr.find(v=>v.variant===bestFeas.variant) || arr[0] || null;
      return vp || null;
    }
    return arr[0] || null;
  }

  private pickFeas(planId: PlanId, variant?: string | undefined | null): PlanFeas | null {
    const arr = this.feas?.plans?.filter(p=>p.planId===planId) ?? [];
    if (!arr.length) return null;
    if (variant) return arr.find(p=>p.variant===variant) || arr[0];
    return arr[0];
  }

  private altScores(sel: PlanFeas | null){
    if (!this.feas?.plans) return [];
    return this.feas.plans
      .filter(p=> !sel || p!==sel)
      .map(p=>({ planId:p.planId, variant:p.variant, score:p.score }))
      .sort((a,b)=>b.score-a.score)
      .slice(0,4);
  }

  private topFindings(sel: PlanFeas | null){
    if (!sel) return [];
    const combine = [...(sel.summaryFindings||[])];
    for (const s of sel.symbols) {
      const crit = s.findings.filter(f=>f.severity!=="INFO");
      combine.push(...crit);
    }
    // Önce ERROR, sonra WARN; ilk 6
    return combine.sort((a,b)=>{
      const rank = (x:ItemFinding)=> x.severity==="ERROR"?2 : x.severity==="WARN"?1 : 0;
      return rank(b)-rank(a);
    }).slice(0,6);
  }

  private policyNodes(vp: VariantPlan | null, sel: PlanFeas | null): ExplainNode[] {
    const out: ExplainNode[] = [];
    if (!vp || !sel) return out;

    const symSet = new Set(vp.symbols.map(o=>Object.keys(o)[0]));
    // Whitelist/+%4 filtreleri VIVO-05 & VIVO-06’da uygulanmıştı; buradan özetleyelim:
    const rejected = this.feas?.plans
      .filter(p=>p.planId===vp.id && p.variant===vp.variant)
      .flatMap(p=>p.symbols)
      .filter(s=> s.findings.some(f=>f.type==="WHITELIST" || f.type==="TARGET_PCT")) || [];

    if (rejected.length){
      out.push({
        label:"Politika Uyum Özeti",
        children:[
          { label:"Whitelist-dışı / +%4 altı sebebiyle elenen semboller", value: rejected.map(x=>x.symbol).join(", ") || "-", severity:"WARN" },
          { label:"Seçilen plandaki aktif semboller", value:[...symSet].join(", ") || "-" }
        ]
      });
    } else {
      out.push({ label:"Politika Uyum", value:"Tümü uygun", severity:"INFO" });
    }
    return out;
  }

  private execSummary(actions: ActionBundle | null, planId: PlanId){
    if (!actions || actions.planId!==planId) return undefined;
    const n = actions.children.length;
    const reduceOnly = actions.children.filter(c=>c.reduceOnly).length;
    const postOnly   = actions.children.filter(c=>c.postOnly).length;
    const notion = actions.children.reduce((a,c)=> a + (c.price??0)*c.qty, 0);
    return { childCount:n, reduceOnlyRatio: +(reduceOnly/Math.max(1,n)).toFixed(2), postOnlyCount: postOnly, notionalUsd: Math.round(notion) };
  }

  private buildWhyTree(vp: VariantPlan | null, sel: PlanFeas | null): ExplainNode[] {
    const nodes: ExplainNode[] = [];
    if (!vp || !sel) return nodes;

    nodes.push({
      label:"Seçim Kriterleri",
      children:[
        { label:"Feasibility Skoru", value: sel.score },
        { label:"Öneri", value: sel.recommend || "—" },
        { label:"Varyant", value: vp.variant || "—" },
        { label:"Exec Parametreleri", children:[
          { label:"childType", value: vp.exec.childType },
          { label:"limitOffsetBps", value: vp.exec.limitOffsetBps },
          { label:"twapMs", value: vp.exec.twapMs },
          { label:"iceberg", value: vp.exec.iceberg }
        ]}
      ]
    });

    // En kritik nedenler (ERROR/WARN)
    const crit = this.topFindings(sel);
    if (crit.length){
      nodes.push({
        label:"Kritik Bulgular",
        children: crit.map(f=>({ label:f.type, value:f.message + (f.quickFix?` | Fix: ${f.quickFix}`:""), severity:f.severity }))
      });
    }

    // Risk/sentinel ipuçları
    if (vp.riskHints?.length){
      nodes.push({
        label:"Risk İpuçları",
        children: vp.riskHints.map(h=>({ label:"hint", value:h, severity:"WARN" }))
      });
    }
    return nodes;
  }

  private suggestNext(vp: VariantPlan | null, sel: PlanFeas | null, sentinel: string): string[] {
    const out: string[] = [];
    if (!vp || !sel) return out;

    if (sentinel!=="NORMAL") out.push("Sentinel aktif: Yeni açılışları durdur, yalnız reduce-only uygula.");
    if (sel.recommend==="ADJUST") out.push("Planı ayarla: TWAP +200ms, iceberg +0.02, gerekiyorsa POST_ONLY.");
    if (sel.recommend==="REJECT") out.push("Planı reddet: Plan C (nakit/spot) veya daha düşük notional ile yeniden dener.");

    // Sembollerde uyarı
    for (const s of sel.symbols){
      const w = s.findings.find(f=>f.type==="TRIM" || f.type==="MIN_NOTIONAL" || f.type==="PERCENT_PRICE");
      if (w) out.push(`${s.symbol}: ${w.message}${w.quickFix?` → ${w.quickFix}`:""}`);
    }
    if (!out.length) out.push("Plan uygun: VIVO-02’ye aktar ve yürütmeyi izle.");
    return Array.from(new Set(out)).slice(0,6);
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/explainabilityReporter.test.ts
import { describe,it,expect } from "vitest";
import { ExplainabilityReporter } from "../explainabilityReporter";
import type { MemorySnapshot, VariantOutput, FeasOutput, OperatorResult, ActionBundle, ReporterInput } from "../explainabilityReporter.types";

function feed(er: ExplainabilityReporter){
  const memory: MemorySnapshot = {
    asOf:new Date().toISOString(),
    postureWeights:{ RISK_ON:0.4, NEUTRAL:0.45, RISK_OFF:0.15 },
    planWeights:{ A:0.55, B:0.3, C:0.15 },
    defaults:{ defaultPlan:"A" }
  };
  const variants: VariantOutput = {
    asOf:new Date().toISOString(),
    variants:{
      A:[ { id:"A", title:"BTC+ETH", variant:"BAL", symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} } ],
      B:[ ],
      C:[ { id:"C", title:"Nakit+Spot", variant:"CONSV", symbols:[], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.2, childType:"POST_ONLY"} } ]
    }
  };
  const feas: FeasOutput = {
    asOf:new Date().toISOString(),
    overallScore: 78,
    plans:[
      { planId:"A", variant:"BAL", score:82, symbols:[{ symbol:"BTCUSDT", requestedNotionalUsd:8000, estimatedPrice:65000, estimatedQty:0.12, score:85, findings:[] }], summaryFindings:[], recommend:"OK" },
      { planId:"C", variant:"CONSV", score:65, symbols:[], summaryFindings:[{type:"SENTINEL",severity:"WARN",message:"—"}], recommend:"ADJUST" }
    ]
  };
  const op: OperatorResult = { selectedPlanId:"A", confirmations:{0:"A",1:"Evet"}, decidedBy:"OPERATOR", decidedAt:new Date().toISOString(), corrId:"test-corr" };
  const act: ActionBundle = { asOf:new Date().toISOString(), planId:"A", children:[{ symbol:"BTCUSDT", side:"BUY", type:"LIMIT", price:65010, qty:0.12 }], comments:[] };

  // Bus yerine doğrudan alanlara set edelim (test kolaylığı)
  (er as any).memory = memory;
  (er as any).variants = variants;
  (er as any).feas = feas;
  (er as any).lastSelection = op;
  (er as any).lastActions = act;
}

describe("VIVO-07 explainabilityReporter", ()=>{
  it("builds explain card with scores and why-tree", ()=>{
    const er = new ExplainabilityReporter();
    feed(er);
    const req: ReporterInput = { corrId:"test-corr", posture:"NEUTRAL", sentinel:"NORMAL" };
    const out:any = er.build(req);
    expect(out.header.selected.planId).toBe("A");
    expect(out.feasibility.selectedScore).toBeGreaterThan(0);
    expect(out.whyTree.length).toBeGreaterThan(0);
    expect(out.execSummary?.childCount).toBe(1);
  });

  it("is idempotent by corrId", ()=>{
    const er = new ExplainabilityReporter();
    feed(er);
    const req = { corrId:"dup", posture:"NEUTRAL", sentinel:"NORMAL" } as ReporterInput;
    const c1:any = er.build(req);
    const c2:any = er.build(req);
    expect(c2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon Akışı

VIVO-01/05/06 akışı çalışır → vivo.variants + vivo.feasibility.

VIVO-03 operatör seçimi → vivo.operator.result.

VIVO-02 çocuk emirleri üretir → ops.actions.

VIVO-07 vivo.explain.request geldiğinde (veya otomatik tetik), kartı üretir → vivo.explain.card.

Telegram/CLI’da kart özetini göster; audit.log’a kalıcı iz bırak.
_________________________________________________________________________________________________________________
VIVO-08 · execGuardrailBridge.ts

Amaç (tek cümle):
VIVO-02’nin önerdiği ops.actions.proposed paketini, feasibility/findings + sentinel + policy sinyallerine göre guardrail’lerden geçirip güvenli ops.actions olarak yayınlamak; gerekli durumlarda tam engelleme veya reduce-only moduna zorlamak.

Gerçek Dünya Kuralları (latency-safe)

Sentinel ≠ NORMAL → yeni açılış yok.

SLOWDOWN: yeni girişleri POST_ONLY + TWAP↑ + iceberg↑ ile yavaşlat; gerekirse notional TRIM.

HALT_PARTIAL | CIRCUIT_BREAKER: yalnız reduce-only (açık poz. kapama/trim).

Feasibility ERROR’ları: DENY, REDUCE_ONLY, SYMBOL_STATUS!=TRADING, WHITELIST/TARGET_PCT fail → o sembolde yeni giriş iptal.

Feasibility WARN’ları: TRIM, PERCENT_PRICE, MIN_NOTIONAL yakın, BALANCE → quick-fix uygula (notional↓, POST_ONLY, TWAP+Δ, iceberg+Δ).

Kapanmamış bar yok: Tüm metrikler kapanmış veriden gelmiştir (VIVO-05/06/GB).

Borsa kuralları (tick/lot/notional) nihai kuantizasyonu VIVO-02 yapar; bu köprü davranışsal/operasyonel ayarlar uygular.

Arayüzler (TypeScript)
// vivo/execGuardrailBridge.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Level = "GREEN"|"AMBER"|"RED";
export type PlanId = "A"|"B"|"C";

export interface RiskState {
  level: Level;
  sentinel: Sentinel;
}

export interface ItemFinding {
  type: string;                 // "TRIM" | "REDUCE_ONLY" | "DENY" | "PERCENT_PRICE" | ...
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}

export interface SymbolFeas {
  symbol: string;
  requestedNotionalUsd: number;
  estimatedPrice: number;
  estimatedQty: number;
  score: number;                 // 0..100
  findings: ItemFinding[];
  adjustedNotionalUsd?: number;  // VIVO-06 önerisi
}

export interface PlanFeas {
  planId: PlanId;
  variant?: "AGGR"|"BAL"|"CONSV";
  score: number;
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf: string;
  overallScore: number;
  plans: PlanFeas[];
}

export interface ActionChild {
  symbol: string;
  side: "BUY"|"SELL";
  type: "LIMIT"|"MARKET"|"POST_ONLY"|"IOC";
  price?: number;
  qty: number;
  reduceOnly?: boolean;
  postOnly?: boolean;
  meta?: { twapMs?: number; iceberg?: number; slice?: number; slices?: number; corrId?: string };
}

export interface ActionBundle {
  asOf: string;
  planId: PlanId;
  corrId?: string;
  children: ActionChild[];
  comments?: string[];
}

export interface GuardrailConfig {
  twapBumpMs: number;          // SLOWDOWN/HIGH-RISK için eklenecek min TWAP (örn 200–400ms)
  icebergBump: number;         // 0.02–0.05 arası ek parça
  maxIceberg: number;          // 0.5
  notionalTrimRatio: number;   // TRIM uyarısında % kesinti (örn 0.85)
  enforcePostOnly: boolean;    // yavaşlama modunda post-only zorlansın mı?
}

export interface GuardrailReport {
  corrId?: string;
  planId: PlanId;
  before: ActionBundle;
  after: ActionBundle;
  changes: string[];           // insan-okur özet
  blockedSymbols: string[];    // tamamen engellenen semboller
  mode: "NORMAL"|"SLOWDOWN"|"REDUCE_ONLY";
}

export interface ExecGuardrailInput {
  risk: RiskState;
  feas: FeasOutput;
  proposed: ActionBundle;      // VIVO-02 üretti
  cfg?: Partial<GuardrailConfig>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

ops.actions.proposed (VIVO-02’den)

vivo.feasibility (VIVO-06’dan – en son skor/bulgular)

risk.state (GB-61/Net/Sentinel akışı)

Publish:

ops.actions (guarded, yürütmeye hazır)

ops.guardrail.report (önce/sonra fark raporu)

audit.log (özet; idempotent/corrId izleri)

Guardrail Politikaları (deterministik eşleştirme)
Koşul / Bulgu	Uygulama (auto-tweak)
Sentinel = CIRCUIT_BREAKER / HALT_PARTIAL	Tüm yeni BUY/SELL açılışları kaldır, kalanlar reduceOnly=true
Sentinel = SLOWDOWN	POST_ONLY=true, twapMs += twapBumpMs, iceberg += icebergBump (≤ maxIceberg)
Finding = REDUCE_ONLY (ERROR)	İlgili sembolde yalnız reduceOnly emirler bırak
Finding = DENY / WHITELIST / TARGET_PCT	İlgili sembolde tüm yeni girişleri kaldır
Finding = TRIM (WARN)	Sembol notional’ı notionalTrimRatio ile kes (qty↓)
Finding = PERCENT_PRICE (WARN)	POST_ONLY=true + twapMs += twapBumpMs/2
Finding = MIN_NOTIONAL (ERROR)	Sembolü kaldır veya aynı plandaki başka sembollere paylaştırma yapma (iyimserlik önlenir)

Not: Tick/lot/notional kesin yuvarlama VIVO-02’de; VIVO-08 yalnız davranışsal korumaları uygular.

Kod İskeleti (TypeScript)
// vivo/execGuardrailBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  ExecGuardrailInput, GuardrailConfig, GuardrailReport, FeasOutput,
  PlanFeas, SymbolFeas, ActionBundle, ActionChild, StdError
} from "./execGuardrailBridge.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class ExecGuardrailBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-08";
  private feas: FeasOutput | null = null;
  private lastRisk: ExecGuardrailInput["risk"] | null = null;
  private seenCorr = new Set<string>();
  private cfg: GuardrailConfig = {
    twapBumpMs: 300,
    icebergBump: 0.03,
    maxIceberg: 0.5,
    notionalTrimRatio: 0.85,
    enforcePostOnly: true
  };

  attach(){
    bus.on<FeasOutput>("vivo.feasibility", (f)=> this.feas = f);
    bus.on<any>("risk.state", (r)=> this.lastRisk = r);
    bus.on<ActionBundle>("ops.actions.proposed", (ab)=> this.safeGuard({ risk:this.lastRisk!, feas:this.feas!, proposed:ab }));
  }

  /** Dışarıdan manuel tetikleme için */
  safeGuard(x: ExecGuardrailInput){
    const res = this.run(x);
    if ("error" in (res as any)){
      logger.error(res, "VIVO-08 guard failed");
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:res }});
    } else {
      const rep = res as GuardrailReport;
      bus.emit<ActionBundle>("ops.actions", rep.after);
      bus.emit<GuardrailReport>("ops.guardrail.report", rep);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ corrId:rep.corrId, mode:rep.mode, changes:rep.changes.slice(0,6) }});
    }
  }

  run(x: ExecGuardrailInput): GuardrailReport | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      const corr = x.proposed.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      if (this.seenCorr.has(corr)) return this.err("IDEMPOTENT","corrId already processed",{corrId:corr});

      const before = deepClone(x.proposed);
      const after: ActionBundle = deepClone(x.proposed);

      const planFeas = this.pickPlanFeas(x.feas, after.planId);
      const mode = this.applyGuards(after, planFeas, x);
      this.seenCorr.add(corr);

      return { corrId:corr, planId:after.planId, before, after, changes: diffSumm(before, after), blockedSymbols: blocked(after, before), mode };

    } catch (e:any){
      return this.err("GUARD_FAILED", e?.message || "unknown", { stack:e?.stack });
    }
  }

  private applyGuards(after: ActionBundle, pf: PlanFeas | null, x: ExecGuardrailInput): "NORMAL"|"SLOWDOWN"|"REDUCE_ONLY" {
    const risk = x.risk;
    let mode:"NORMAL"|"SLOWDOWN"|"REDUCE_ONLY" = "NORMAL";

    // 0) Sentinel sert kurallar
    if (risk.sentinel==="CIRCUIT_BREAKER" || risk.sentinel==="HALT_PARTIAL"){
      mode = "REDUCE_ONLY";
      // yeni açılışları kaldır; kalanları reduce-only’a çevir
      after.children = after.children.filter(c=> c.reduceOnly || c.side==="SELL"); // BUY açılışı at
      for (const c of after.children){ c.reduceOnly = true; c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
      return mode;
    }
    if (risk.sentinel==="SLOWDOWN"){
      mode = "SLOWDOWN";
      for (const c of after.children){
        if (this.cfg.enforcePostOnly){ c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
        c.meta = c.meta || {};
        c.meta.twapMs = (c.meta.twapMs ?? 0) + this.cfg.twapBumpMs;
        c.meta.iceberg = clamp((c.meta.iceberg ?? 0.1) + this.cfg.icebergBump, 0.05, this.cfg.maxIceberg);
      }
    }

    // 1) Feasibility bulguları
    if (pf){
      // Sembol bazlı quick-fix
      for (const sym of pf.symbols){
        const has = (t:string)=> sym.findings.some(f=>f.type===t);
        const hardDeny = has("DENY") || has("WHITELIST") || has("TARGET_PCT") || has("SYMBOL_STATUS") || has("REDUCE_ONLY");
        const warnTrim = has("TRIM");
        const warnBand = has("PERCENT_PRICE");
        const minNotionalErr = has("MIN_NOTIONAL");

        for (const c of after.children.filter(c=>c.symbol===sym.symbol)){
          if (hardDeny){
            // yeni girişleri kaldır; reduce-only varsa bırak
            if (!c.reduceOnly){ c.qty = 0; } // VIVO-02 kuantize ederken 0’ları drop edecek
            c.postOnly = true;
          } else {
            // quick-fix’ler
            if (warnTrim){
              c.qty = c.qty * this.cfg.notionalTrimRatio; // notional ~ qty * price
            }
            if (warnBand){
              c.postOnly = true;
              c.meta = c.meta || {};
              c.meta.twapMs = (c.meta.twapMs ?? 0) + Math.floor(this.cfg.twapBumpMs/2);
            }
            if (minNotionalErr){
              // minNotional fail: güvenli tarafta sembolü kaldırıyoruz (iyimserliği önle)
              c.qty = 0;
            }
          }
        }
      }

      // Plan önerisi "REJECT" ise varsayılan konservatif: yalnız reduce-only bırak
      if (pf.recommend==="REJECT"){
        mode = mode==="SLOWDOWN" ? "SLOWDOWN" : "REDUCE_ONLY";
        after.children = after.children.filter(c=> c.reduceOnly || c.side==="SELL");
        for (const c of after.children){ c.reduceOnly = true; c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
      }
    }

    // 2) Temizlik: qty<=0 olanları at
    after.children = after.children.filter(c=> (c.qty ?? 0) > 0);

    return mode;
  }

  private pickPlanFeas(feas: FeasOutput, planId: PlanFeas["planId"]): PlanFeas | null {
    if (!feas?.plans?.length) return null;
    const arr = feas.plans.filter(p=>p.planId===planId);
    if (!arr.length) return null;
    // en yüksek skorlu varyantı seç
    return arr.sort((a,b)=>b.score-a.score)[0];
  }

  private validate(x: ExecGuardrailInput): string | null {
    if (!x?.proposed || !Array.isArray(x.proposed.children)) return "proposed actions missing/invalid";
    if (!x?.risk) return "risk state missing";
    if (!x?.feas || !Array.isArray(x.feas.plans)) return "feas missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    return { error: e };
  }
}

// ------- yardımcılar
function deepClone<T>(o:T):T{ return JSON.parse(JSON.stringify(o)); }

function diffSumm(a:ActionBundle, b:ActionBundle): string[] {
  const lines: string[] = [];
  const key = (c:ActionChild)=>`${c.symbol}:${c.side}:${c.type}`;
  const idxA = new Map(a.children.map((c,i)=>[key(c), {i,c}]));
  const idxB = new Map(b.children.map((c,i)=>[key(c), {i,c}]));
  for (const [k,{c}] of idxA){
    if (!idxB.has(k)) lines.push(`DROP ${k}`);
  }
  for (const [k,{c}] of idxB){
    if (!idxA.has(k)) { lines.push(`ADD ${k} qty=${c.qty}`); continue; }
    const prev = idxA.get(k)!.c;
    if ((prev.qty??0)!==(c.qty??0)) lines.push(`QTY ${k}: ${prev.qty}→${c.qty}`);
    if (!!prev.postOnly!==!!c.postOnly) lines.push(`POST_ONLY ${k}: ${!!prev.postOnly}→${!!c.postOnly}`);
    if (!!prev.reduceOnly!==!!c.reduceOnly) lines.push(`REDUCE_ONLY ${k}: ${!!prev.reduceOnly}→${!!c.reduceOnly}`);
    const pT = prev.meta?.twapMs ?? 0, nT = c.meta?.twapMs ?? 0;
    if (pT!==nT) lines.push(`TWAP ${k}: ${pT}→${nT}`);
    const pI = prev.meta?.iceberg ?? 0, nI = c.meta?.iceberg ?? 0;
    if (pI!==nI) lines.push(`ICEBERG ${k}: ${pI}→${nI}`);
  }
  return lines.slice(0,20);
}

function blocked(after:ActionBundle, before:ActionBundle): string[] {
  const setB = new Set(before.children.map(c=>c.symbol+":"+c.side));
  const setA = new Set(after.children.map(c=>c.symbol+":"+c.side));
  return [...setB].filter(k=>!setA.has(k)).slice(0,20).map(s=>s.split(":")[0]);
}

Test İskeleti (Vitest)
// vivo/__tests__/execGuardrailBridge.test.ts
import { describe,it,expect } from "vitest";
import { ExecGuardrailBridge } from "../execGuardrailBridge";
import type { ExecGuardrailInput } from "../execGuardrailBridge.types";

const feas = {
  asOf: new Date().toISOString(),
  overallScore: 70,
  plans: [{
    planId:"A", variant:"BAL", score:72, recommend:"ADJUST",
    symbols:[
      { symbol:"ETHUSDT", requestedNotionalUsd:3000, estimatedPrice:3000, estimatedQty:1, score:68, findings:[{type:"TRIM",severity:"WARN",message:"notional>allowed"}] },
      { symbol:"OPUSDT",  requestedNotionalUsd:1500, estimatedPrice:4,    estimatedQty:375, score:40, findings:[{type:"WHITELIST",severity:"ERROR",message:"whitelist dışı"}] }
    ],
    summaryFindings:[]
  }]
};

const proposed = {
  asOf: new Date().toISOString(),
  planId:"A",
  corrId:"corr-1",
  children:[
    { symbol:"BTCUSDT", side:"BUY", type:"LIMIT", qty:0.12, meta:{ twapMs:1200, iceberg:0.12 } },
    { symbol:"ETHUSDT", side:"BUY", type:"LIMIT", qty:1.00,  meta:{ twapMs:1200, iceberg:0.10 } },
    { symbol:"OPUSDT",  side:"BUY", type:"LIMIT", qty:400,   meta:{ twapMs:1200, iceberg:0.10 } }
  ],
  comments:[]
};

describe("VIVO-08 execGuardrailBridge", ()=>{
  it("applies TRIM, drops whitelist-failed, bumps TWAP/iceberg on slowdown", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run({
      risk:{ level:"AMBER", sentinel:"SLOWDOWN" },
      feas: feas as any,
      proposed: proposed as any
    } as ExecGuardrailInput);

    expect(out.mode).toBe("SLOWDOWN");
    // OPUSDT whitelist hatalı → düşmeli
    const symsAfter = out.after.children.map((c:any)=>c.symbol);
    expect(symsAfter).not.toContain("OPUSDT");
    // ETHUSDT TRIM → qty düşmeli
    const ethBefore = proposed.children.find(c=>c.symbol==="ETHUSDT")!.qty;
    const ethAfter  = out.after.children.find((c:any)=>c.symbol==="ETHUSDT")!.qty;
    expect(ethAfter).toBeLessThan(ethBefore);
    // TWAP bump + POST_ONLY
    const anyChild = out.after.children[0];
    expect(anyChild.meta.twapMs).toBeGreaterThanOrEqual(1200+200);
    expect(anyChild.postOnly).toBe(true);
  });

  it("forces reduce-only on circuit breaker", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run({
      risk:{ level:"RED", sentinel:"CIRCUIT_BREAKER" },
      feas: feas as any,
      proposed: proposed as any
    } as ExecGuardrailInput);

    expect(out.mode).toBe("REDUCE_ONLY");
    expect(out.after.children.every((c:any)=>c.reduceOnly===true)).toBe(true);
    // BUY açılışlarının çoğu düşer (qty 0 veya drop)
    expect(out.after.children.length).toBeGreaterThan(0);
  });

  it("idempotent by corrId", ()=>{
    const br = new ExecGuardrailBridge();
    const inp: ExecGuardrailInput = { risk:{ level:"AMBER", sentinel:"NORMAL" }, feas: feas as any, proposed: proposed as any };
    const r1:any = br.run(inp);
    const r2:any = br.run(inp);
    expect(r2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon Akışı

VIVO-02 çocuk emirleri üretir → ops.actions.proposed.

VIVO-06 feasibility & findings hazırdır → VIVO-08 “proposed” + “feasibility” + “risk.state” verilerini alır.

VIVO-08 guardrail uygular → ops.actions (yürütmeye hazır) + ops.guardrail.report (önce/sonra fark).

GB-66/67 yürütür; sonuçlar GB-22/36 TCA’ya akar.
_________________________________________________________________________________________________________________
VIVO-09 · upliftABEngine.ts

Amaç (tek cümle):
Plan/varyant seçimini kontrollü deney kurgusuna bağlayıp (A/B/C), canlı sonuçlardan uplift istatistiği üreterek VIVO’nun plan ağırlıklarını veriyle optimize etmek.

Gerçek Dünya Kuralları (latency-safe)

Sinyal kapanmamış bar kullanmaz; sadece atama & sonuç toplama yapar.

Risk/Sentinel RED/HALT/CB → deney askıya alınır (yalnız “C/korumacı” kola izin).

Politika kapıları (whitelist, minTarget ≥ +%4) VIVO-05/06’da zaten uygulanır; burada sadece deney kurgusu yürür.

Muhasebe: Net PnL (komisyon, slipaj, funding dahil) ve mark-out/realized verileri GB-22/36’dan dinlenir.

Idempotency: Aynı corrId için ikinci kez atama veya sonuç yazılmaz.

Arayüzler (TypeScript / JSDoc)
// vivo/upliftABEngine.types.ts
import type { ISODate } from "../core/types";

export type PlanId = "A"|"B"|"C";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";

export interface VariantPlan {
  id: PlanId;
  title: string;
  variant?: VariantId;
  symbols: Array<Record<string,number>>;
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
}

export interface VariantOutput {
  asOf: ISODate;
  variants: Record<PlanId, VariantPlan[]>;
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;                 // Operatör seçimi (karttaki Plan)
  confirmations: Record<number,string>;   // 0: plan A/B/C, devamı evet/hayır vb.
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface AssignConfig {
  mode: "FIXED_SPLIT"|"EPS_GREEDY";     // sabit yüzdeler veya epsilon-greedy
  fixedSplit?: Record<VariantId, number>; // ör: {AGGR:0.3,BAL:0.5,CONSV:0.2}
  epsilon?: number;                       // 0.05..0.2 önerilir
  minPerArm?: number;                     // anlamlılık için min örnek
  corrPrefix?: string;                    // deney corr id ön eki
}

export interface AssignDecision {
  corrId: string;                // deney korelasyon id’si
  planId: PlanId;                // A/B/C planı
  variant: VariantId;            // seçilen varyant kolu
  decidedAt: ISODate;
  decidedBy: "ENGINE"|"OPERATOR_DEFAULT";
  exposureSeq: number;           // kolun maruz kaldığı örnek sayısı
}

export interface OutcomeIn {
  corrId: string;                // atama corrId
  planId: PlanId;
  variant?: VariantId;
  postureAtDecision: Posture;
  asOf: ISODate;
  pnlUsd: number;                // net realized PnL
  hit?: boolean;
  profitFactor?: number;
  rMultiple?: number;
  slippageBps?: number;
  markoutBp_5s?: number;
}

export interface ArmStat {
  n: number;
  sumPnl: number;
  hit: number;
  pfEWMA: number;
  meanPnl: number;
}

export interface LiftResult {
  baseline: VariantId;                 // karşılaştırma kolu (genelde BAL)
  compare: VariantId;                  // kıyaslanan kol
  upliftPnl: number;                   // mean pnl farkı (USD)
  upliftHit: number;                   // hit rate farkı (pp)
  pValue?: number;                     // opsiyonel hızlı z-test
  significant?: boolean;               // p<0.05 ?
}

export interface Snapshot {
  asOf: ISODate;
  arms: Record<VariantId, ArmStat>;
  lifts: LiftResult[];
}

export interface UpliftStore {
  load(): Promise<Snapshot | null>;
  save(s: Snapshot): Promise<void>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.variants (VIVO-05): eldeki planın varyant seti

vivo.operator.result (VIVO-03): seçilen Plan A/B/C

gb.tca (GB-22/36): kapanan işlem sonuçları → OutcomeIn

risk.state (GB-61/ops): sentinel/posture güncellemeleri

Publish:

vivo.uplift.assign (AssignDecision) – VIVO-02’ye atıf için

vivo.uplift (OutcomeIn) – sonuç, VIVO-04 postureMemory kullanır

vivo.uplift.snapshot (Snapshot) – Denetim Asistanı/raporlar için

audit.log – atama & sonuç özeti

Validasyon & Kurallar

Sentinel ≠ NORMAL → yalnız CONSV kolu atanır, decidedBy="OPERATOR_DEFAULT" işaretlenebilir.

Operatör bir Plan seçtikten sonra VIVO-09, bu planın içindeki varyant kolunu atar (örn. A/B/C planında BAL/AGGR/CONSV).

EPS_GREEDY: %ε rastgele, %1-ε en yüksek meanPnL kolu.

FIXED_SPLIT: normalize split; exposure sayısı eşik altındaysa under-exposed kola öncelik.

Idempotency: aynı corrId ikinci kez atama/sonuç kabul etmeyiz.

Kod İskeleti (TypeScript / Node)
// vivo/upliftABEngine.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AssignConfig, AssignDecision, VariantOutput, OperatorResult, RiskState,
  OutcomeIn, Snapshot, UpliftStore, VariantId, PlanId, StdError
} from "./upliftABEngine.types";

const VARS: VariantId[] = ["AGGR","BAL","CONSV"];

class InMemoryStore implements UpliftStore {
  private snap: Snapshot | null = null;
  async load(){ return this.snap; }
  async save(s: Snapshot){ this.snap = s; }
}

export class UpliftABEngine extends EventEmitter {
  ver="1.0.0"; src="VIVO-09";
  private cfg: Required<AssignConfig>;
  private store: UpliftStore;
  private snap: Snapshot = { asOf:new Date().toISOString(), arms:{
      AGGR:{n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0},
      BAL: {n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0},
      CONSV:{n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0}
    }, lifts:[] };
  private lastVariants: VariantOutput | null = null;
  private lastOperator: OperatorResult | null = null;
  private lastRisk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  private seenCorr = new Set<string>();

  constructor(cfg?: Partial<AssignConfig>, store?: UpliftStore){
    super();
    this.cfg = {
      mode: "EPS_GREEDY",
      epsilon: 0.1,
      fixedSplit: { AGGR:0.33, BAL:0.34, CONSV:0.33 },
      minPerArm: 30,
      corrPrefix: "upl"
      , ...cfg
    } as Required<AssignConfig>;
    this.store = store ?? new InMemoryStore();
  }

  async attach(){
    const saved = await this.store.load(); if (saved) this.snap = saved;
    bus.on<VariantOutput>("vivo.variants", v=>{ this.lastVariants = v; });
    bus.on<OperatorResult>("vivo.operator.result", o=>{ this.lastOperator = o; });
    bus.on<RiskState>("risk.state", r=>{ this.lastRisk = r; });
    bus.on<OutcomeIn>("gb.tca", o=> this.ingestOutcome(o).catch(e=>logger.error(e,"VIVO-09 outcome")));
    bus.on("vivo.uplift.request", ()=> this.safeAssign());
  }

  // --- ATAMA ---
  safeAssign(){
    const res = this.assign();
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-09 assign failed");
    } else {
      const a = res as AssignDecision;
      bus.emit<AssignDecision>("vivo.uplift.assign", a);
      bus.emit("audit.log", { asOf:a.decidedAt, ver:this.ver, src:this.src, payload:{ msg:"assign", corrId:a.corrId, plan:a.planId, var:a.variant }});
    }
  }

  assign(): AssignDecision | { error: StdError } {
    try {
      if (!this.lastOperator) return this.err("STATE_MISSING","operator selection missing");
      if (!this.lastVariants) return this.err("STATE_MISSING","variants missing");
      const planId = this.lastOperator.selectedPlanId;
      const candidates = this.lastVariants.variants[planId] || [];
      if (!candidates.length) return this.err("NO_ARMS",`no variants for plan ${planId}`);

      // Sentinel / Risk kuralı
      if (this.lastRisk.sentinel!=="NORMAL"){
        const consv = candidates.find(v=>v.variant==="CONSV") || candidates[0];
        return this.makeDecision(planId, consv.variant ?? "CONSV", "OPERATOR_DEFAULT");
      }

      // Deney: AGGR/BAL/CONSV içinden seç
      const avail = candidates.map(v=>v.variant || "BAL") as VariantId[];
      const chosen = this.cfg.mode==="EPS_GREEDY"
        ? this.pickEpsGreedy(avail)
        : this.pickFixedSplit(avail);

      return this.makeDecision(planId, chosen, "ENGINE");

    } catch (e:any){
      return this.err("ASSIGN_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private makeDecision(planId: PlanId, variant: VariantId, by:"ENGINE"|"OPERATOR_DEFAULT"): AssignDecision {
    const corrId = `${this.cfg.corrPrefix}-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;
    const exposureSeq = this.snap.arms[variant].n + 1;
    const dec: AssignDecision = { corrId, planId, variant, decidedAt:new Date().toISOString(), decidedBy:by, exposureSeq };
    return dec;
  }

  private pickEpsGreedy(avail: VariantId[]): VariantId {
    // ε rastgele, 1-ε en iyi meanPnl
    if (Math.random() < this.cfg.epsilon){
      return avail[Math.floor(Math.random()*avail.length)];
    }
    // En iyi kol: mevcut snapshot’taki meanPnl en yüksek olan (sadece avail’den)
    let best: VariantId = avail[0]; let bestVal = -1e9;
    for (const v of avail){
      const m = this.snap.arms[v].meanPnl;
      if (m > bestVal){ bestVal = m; best = v; }
    }
    return best;
  }

  private pickFixedSplit(avail: VariantId[]): VariantId {
    // Under-exposed öncelik: minPerArm altındaki avail kolları tercih et
    const under = avail.filter(v=> this.snap.arms[v].n < this.cfg.minPerArm);
    const pool = under.length ? under : avail;
    // Ağırlıklar normalize
    const w = pool.map(v=> Math.max(0, this.cfg.fixedSplit[v] ?? 0.001));
    const sum = w.reduce((a,b)=>a+b,0) || 1;
    const r = Math.random() * sum;
    let acc = 0;
    for (let i=0;i<pool.length;i++){ acc += w[i]; if (r <= acc) return pool[i]; }
    return pool[pool.length-1];
  }

  // --- SONUÇ İÇERME ---
  async ingestOutcome(x: OutcomeIn): Promise<Snapshot | { error: StdError }> {
    try {
      if (!x?.corrId) return this.err("VALIDATION_ERROR","corrId missing");
      if (this.seenCorr.has(x.corrId)) return this.ok(); // idempotent
      if (!VARS.includes((x.variant as VariantId) || "BAL")) return this.err("VALIDATION_ERROR","variant invalid");

      const v = (x.variant as VariantId) || "BAL";
      const arm = this.snap.arms[v];
      arm.n += 1;
      arm.sumPnl += x.pnlUsd;
      arm.hit += x.hit ? 1 : 0;
      // PF EWMA kaba güncelleme
      const alpha = 0.1;
      const pfObs = x.profitFactor ?? 1;
      arm.pfEWMA = alpha*pfObs + (1-alpha)*arm.pfEWMA;
      arm.meanPnl = arm.sumPnl / Math.max(1, arm.n);

      this.snap.lifts = this.computeLifts();
      this.snap.asOf = new Date().toISOString();
      await this.store.save(this.snap);

      // PostureMemory için publish (VIVO-04 bu olayı dinliyor)
      bus.emit<OutcomeIn>("vivo.uplift", x);
      bus.emit<Snapshot>("vivo.uplift.snapshot", this.snap);
      bus.emit("audit.log", { asOf:this.snap.asOf, ver:this.ver, src:this.src,
        payload:{ msg:"uplift outcome", variant:v, meanPnl:arm.meanPnl, n:arm.n } });

      this.seenCorr.add(x.corrId);
      return this.snap;

    } catch (e:any){
      return this.err("INGEST_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private computeLifts(){
    const base: VariantId = "BAL";
    const out = [] as any[];
    for (const v of VARS){
      if (v===base) continue;
      const a = this.snap.arms[base], b = this.snap.arms[v];
      const upliftPnl = (b.meanPnl - a.meanPnl);
      const upliftHit = (b.n? b.hit/b.n : 0) - (a.n? a.hit/a.n : 0);
      const pValue = this.quickZTest(a.hit, a.n, b.hit, b.n);
      out.push({ baseline:base, compare:v, upliftPnl, upliftHit, pValue, significant: (pValue!==null && pValue<0.05) });
    }
    return out;
  }

  // Basit iki-oran z-testi (hit rate için). n küçükse pValue=null.
  private quickZTest(h1:number, n1:number, h2:number, n2:number): number | null {
    if (n1<20 || n2<20) return null;
    const p1 = h1/Math.max(1,n1), p2 = h2/Math.max(1,n2);
    const p  = (h1+h2)/Math.max(1,(n1+n2));
    const se = Math.sqrt(p*(1-p)*(1/n1 + 1/n2));
    if (!isFinite(se) || se===0) return null;
    const z = (p2 - p1)/se;
    // yaklaşık p-değeri (iki kuyruk)
    const cdf = (x:number)=> 0.5*(1+erf(x/Math.SQRT2));
    const pval = 2*(1 - cdf(Math.abs(z)));
    return pval;
  }

  private ok(){ return this.snap; }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

// hızlı erf yaklaşımı
function erf(x:number){
  // Abramowitz & Stegun formülü
  const s = Math.sign(x);
  x = Math.abs(x);
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
  const t=1/(1+p*x);
  const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return s*y;
}

Test İskeleti (Vitest)
// vivo/__tests__/upliftABEngine.test.ts
import { describe,it,expect } from "vitest";
import { UpliftABEngine } from "../upliftABEngine";
import type { VariantOutput, OperatorResult, RiskState, OutcomeIn } from "../upliftABEngine.types";

function feed(engine: any){
  const variants: VariantOutput = {
    asOf:new Date().toISOString(),
    variants:{
      A:[
        { id:"A", title:"Plan A", variant:"AGGR",  symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1200, iceberg:0.12, childType:"LIMIT"} },
        { id:"A", title:"Plan A", variant:"BAL",   symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} },
        { id:"A", title:"Plan A", variant:"CONSV", symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1700, iceberg:0.16, childType:"POST_ONLY"} }
      ],
      B:[], C:[]
    }
  };
  const op: OperatorResult = { selectedPlanId:"A", confirmations:{0:"A"}, decidedBy:"OPERATOR", decidedAt:new Date().toISOString(), corrId:"op-1" };
  const risk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  engine.lastVariants = variants;
  engine.lastOperator = op;
  engine.lastRisk = risk;
}

describe("VIVO-09 upliftABEngine", ()=>{
  it("assigns a variant via epsilon-greedy", ()=>{
    const eng:any = new UpliftABEngine({ mode:"EPS_GREEDY", epsilon:0.2 });
    feed(eng);
    const a = eng.assign() as any;
    expect(["AGGR","BAL","CONSV"]).toContain(a.variant);
    expect(a.planId).toBe("A");
  });

  it("ingests outcomes and computes lifts", async ()=>{
    const eng:any = new UpliftABEngine({ mode:"FIXED_SPLIT", fixedSplit:{AGGR:0.4,BAL:0.4,CONSV:0.2}, minPerArm: 2 });
    feed(eng);
    // iki AGGR, iki BAL sonucu gönder
    const mk = (id:string, varId:"AGGR"|"BAL", pnl:number): OutcomeIn => ({
      corrId:id, planId:"A", variant:varId, postureAtDecision:"NEUTRAL", asOf:new Date().toISOString(), pnlUsd:pnl, hit:(pnl>0), profitFactor:pnl>0?1.4:0.8
    });
    await eng.ingestOutcome( mk("c1","AGGR", 100) );
    await eng.ingestOutcome( mk("c2","AGGR", -20) );
    await eng.ingestOutcome( mk("c3","BAL", 60) );
    await eng.ingestOutcome( mk("c4","BAL", 10) );
    const snap = eng.snap as any;
    expect(snap.arms.AGGR.n).toBe(2);
    expect(snap.lifts.length).toBeGreaterThan(0);
  });

  it("falls back to CONSV on sentinel halt", ()=>{
    const eng:any = new UpliftABEngine();
    feed(eng);
    eng.lastRisk.sentinel = "HALT_PARTIAL";
    const a = eng.assign() as any;
    expect(a.variant).toBe("CONSV");
    expect(a.decidedBy).toBe("OPERATOR_DEFAULT");
  });
});

Entegrasyon Akışı

VIVO-05 → varyant seti (vivo.variants).

VIVO-03 → operatör Plan A/B/C seçimi (vivo.operator.result).

VIVO-09 → seçilen planın içinden varyant ataması yapar (vivo.uplift.assign) → VIVO-02 bu kola göre çocuk emirleri üretir.

GB-22/36 → işlem kapandıkça sonuç (gb.tca) yayınlar.

VIVO-09 → sonucu ingest eder → vivo.uplift olarak VIVO-04 postureMemory’ye yollar; vivo.uplift.snapshot ile de Denetim Asistanı’na/resimlere şeffaflık sağlar.

VIVO-04 → ağırlıkları günceller; VIVO-01/03/05 varsayılanları ve sıralamayı bu hafızaya göre modüle eder.
_________________________________________________________________________________________________________________
VIVO-10 · execGuardrailBridge.ts
Amaç

Seçilen plan/varyantı, borsa kuralları + risk/sentinel + politika kapıları ışığında icraya güvenli hâle getirip VIVO-02’ye “patch” olarak iletmek. Hedef: canlı-BT farkını ve slipajı düşürmek; “yanlış emir” riskini sıfıra yaklaştırmak.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar kullanılmaz. Yalnızca feasibility bulguları ve risk durumu işlenir.

Sentinel ≠ NORMAL: Yeni açılış yasak; yalnız reduceOnly kapamaya izin.

Politika: whitelist dışı veya minTargetPct < +%4 semboller plandan çıkarılır (fail-closed).

Feasibility türüne göre aksiyon (deterministik):

TRIM → notional’ı allowedNotionalUsd’a indir.

REDUCE_ONLY/DENY/MAX_POSITION/SENTINEL → yeni giriş yok; pozlar reduce-only.

PERCENT_PRICE → limitOffsetBps güvenli banda kaydır, POST_ONLY öner/uygula.

MIN_NOTIONAL → artır(a)mayacaksak sembolü ele (veya operatorDialog gerekirse flagle).

BALANCE yetersiz → notional ↓ veya Plan-C fallback etiketi.

Koruyucu param tweakleri (AMBER/RISK_OFF): TWAP +200..400ms, iceberg +0.02..0.06, mümkünse POST_ONLY.

Arayüzler (TypeScript)
// vivo/execGuardrailBridge.types.ts
export type Level = "GREEN"|"AMBER"|"RED";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface ExecParams {
  limitOffsetBps:number; twapMs:number; iceberg:number; childType:ChildType;
}

export interface VariantPlan {
  id: PlanId; title: string; variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: ExecParams;
}

export interface ItemFinding {
  type:
    | "WHITELIST" | "TARGET_PCT" | "SYMBOL_STATUS" | "PERMISSIONS"
    | "DENY" | "REDUCE_ONLY" | "TRIM"
    | "MIN_NOTIONAL" | "PERCENT_PRICE" | "MAX_POSITION" | "BALANCE"
    | "SENTINEL" | "OK";
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}

export interface SymbolFeas {
  symbol:string;
  requestedNotionalUsd:number;
  estimatedPrice:number;
  estimatedQty:number;
  score:number;
  findings: ItemFinding[];
  adjustedNotionalUsd?: number;
}

export interface PlanFeas {
  planId: PlanId; variant?: VariantId; score:number;
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf:string; overallScore:number; plans: PlanFeas[];
}

export interface RiskState {
  level: Level; sentinel: Sentinel; posture: Posture;
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;
  confirmations: Record<number,string>;
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: string; // ISO
}

export interface AssignDecision {
  corrId: string; planId: PlanId; variant: VariantId;
  decidedAt: string; decidedBy: "ENGINE"|"OPERATOR_DEFAULT";
  exposureSeq: number;
}

export interface GuardInput {
  corrId: string;                          // VIVO-09 atamasından
  selected: VariantPlan;                   // VIVO-05/07 ile aynı format
  feas: PlanFeas;                          // VIVO-06’dan seçili planın feasibility’si
  risk: RiskState;                         // GB-61/ops
}

export interface GuardedSymbolPatch {
  symbol: string;
  action: "KEEP"|"DROP"|"REDUCE_ONLY";
  reason?: string[];
  notionalUsd?: number;                    // TRIM sonrası
}

export interface GuardPatch {
  corrId: string;
  planId: PlanId; variant?: VariantId;
  exec: ExecParams;                         // tweaked
  symbols: GuardedSymbolPatch[];            // ele/trim/keep
  reduceOnlyAll?: boolean;                  // sentinel/fail kapısı
  notes?: string[];                         // VIVO-03’e kart notu
}

export interface ActionIntent {
  asOf: string;
  planId: PlanId;
  reduceOnlyAll?: boolean;
  exec: ExecParams;
  children: Array<{
    symbol:string; side:"BUY"|"SELL"; type:ChildType;
    qty?: number; price?: number; notionalUsd?: number;
    reduceOnly?: boolean; postOnly?: boolean;
    meta?: { twapMs?: number; iceberg?: number; corrId?: string };
  }>;
  comments?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus

Subscribe:

vivo.explain.card veya vivo.uplift.assign (corrId/plan/variant kaydı)

vivo.feasibility (VIVO-06)

risk.state (GB-61)

Publish:

ops.exec.patch (GuardPatch) → VIVO-02 bu patch’i uygulayıp çocuk emirleri üretir

vivo.guardrail.report (özet)

audit.log

Guard Kuralları (deterministik tablo)
Bulgu / Durum	Patch
SENTINEL≠NORMAL	reduceOnlyAll=true, exec.childType="POST_ONLY", TWAP+=300ms, iceberg+=0.04
DENY / REDUCE_ONLY / MAX_POSITION	İlgili sembol: action="REDUCE_ONLY" (yeni giriş yok)
TRIM (+ allowedNotionalUsd)	Sembol notionalUsd = allowedNotionalUsd, action="KEEP"
PERCENT_PRICE	limitOffsetBps güvenli banda it; childType="POST_ONLY" öner/uygula; TWAP+200ms
MIN_NOTIONAL	Artır(a)mayacaksak action="DROP"
BALANCE	Sembol notional ↓ (pro-rata) veya Plan-C bayrağı (not düş)
WHITELIST/TARGET_PCT	action="DROP" (fail-closed)
AMBER seviyesi	TWAP+200ms, iceberg+0.02 (bound’lu)
RISK_OFF posture	childType="POST_ONLY", limitOffsetBps+=2, TWAP+300ms, iceberg+0.04

Bound’lar: 0 ≤ limitOffsetBps ≤ 15, 400 ≤ TWAP(ms) ≤ 4000, 0.05 ≤ iceberg ≤ 0.5.

Kod İskeleti
// vivo/execGuardrailBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  GuardInput, GuardPatch, GuardedSymbolPatch, ExecParams, StdError
} from "./execGuardrailBridge.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=0)=> Number(x.toFixed(n));

export class ExecGuardrailBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-10";

  attach(){
    // Tipik tetikleyici: explain card veya uplift assign geldiğinde, seçili plan için feasibility’yi alıp guard çalıştır
    bus.on<GuardInput>("vivo.guard.request", (gi)=> this.safeRun(gi));
  }

  safeRun(gi: GuardInput){
    const res = this.run(gi);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-10 guard failed");
    } else {
      const patch = res as GuardPatch;
      bus.emit<GuardPatch>("ops.exec.patch", patch);
      bus.emit("vivo.guardrail.report", { asOf:new Date().toISOString(), ver:this.ver, src:this.src,
        payload:{ plan:patch.planId, variant:patch.variant, reduceOnlyAll:patch.reduceOnlyAll, notes:patch.notes }});
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ msg:"guard patch", plan:patch.planId }});
    }
  }

  run(gi: GuardInput): GuardPatch | { error: StdError } {
    try {
      const v = this.validate(gi); if (v) return this.err("VALIDATION_ERROR", v);

      // Başlangıç exec paramları
      let exec: ExecParams = { ...gi.selected.exec };
      const notes: string[] = [];
      const symbols: GuardedSymbolPatch[] = [];

      // Global sentinel/posture etkisi
      if (gi.risk.sentinel!=="NORMAL"){
        exec.childType = "POST_ONLY";
        exec.twapMs += 300; exec.iceberg += 0.04;
        exec = this.bound(exec);
      } else if (gi.risk.level==="AMBER" || gi.risk.posture==="RISK_OFF"){
        exec.twapMs += (gi.risk.posture==="RISK_OFF"?300:200);
        exec.iceberg += (gi.risk.posture==="RISK_OFF"?0.04:0.02);
        if (gi.risk.posture==="RISK_OFF"){
          exec.childType = "POST_ONLY";
          exec.limitOffsetBps += 2;
        }
        exec = this.bound(exec);
      }

      // Semboller bazında feasibility bulguları
      for (const s of gi.feas.symbols){
        const patch = this.guardOneSymbol(s, exec);
        symbols.push(patch);
        if (patch.reason?.length) notes.push(`${s.symbol}: ${patch.reason.join("; ")}`);
      }

      // Global reduce-only bayrağı
      const reduceOnlyAll =
        gi.risk.sentinel!=="NORMAL" ||
        gi.feas.summaryFindings.some(f=> f.type==="SENTINEL" || f.type==="REDUCE_ONLY" || f.type==="DENY");

      // Notları ve exec’i toparla
      exec = this.bound(exec);
      const out: GuardPatch = {
        corrId: gi.corrId,
        planId: gi.selected.id,
        variant: gi.selected.variant,
        exec,
        symbols,
        reduceOnlyAll,
        notes: Array.from(new Set(notes)).slice(0, 12)
      };
      return out;

    } catch (e:any){
      return this.err("GUARD_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private guardOneSymbol(s: any, exec: ExecParams): GuardedSymbolPatch {
    const reasons:string[] = [];
    let action: "KEEP"|"DROP"|"REDUCE_ONLY" = "KEEP";
    let notional = s.requestedNotionalUsd;

    const has = (t:string)=> s.findings.some((f:any)=>f.type===t);

    if (has("WHITELIST") || has("TARGET_PCT") || has("SYMBOL_STATUS")){
      action = "DROP"; reasons.push("policy/symbol status uygunsuz");
    }

    if (has("DENY")){
      action = "REDUCE_ONLY"; reasons.push("exposure=DENY");
    } else if (has("REDUCE_ONLY") || has("MAX_POSITION")){
      action = "REDUCE_ONLY"; reasons.push("reduce-only veya max position");
    }

    // TRIM
    const trimF = s.findings.find((f:any)=>f.type==="TRIM");
    if (trimF && s.adjustedNotionalUsd){
      notional = s.adjustedNotionalUsd;
      reasons.push(`TRIM→ ${notional} USD`);
    }

    // MIN_NOTIONAL (yukarı çıkarma yetkisi yoksa ele)
    if (has("MIN_NOTIONAL")){
      action = "DROP";
      reasons.push("minNotional altında");
    }

    // PERCENT_PRICE → POST_ONLY + offset ayarı
    if (has("PERCENT_PRICE")){
      exec.childType = "POST_ONLY";
      exec.limitOffsetBps = Math.max(exec.limitOffsetBps, 2);
      exec.twapMs += 200;
      exec.iceberg += 0.02;
      reasons.push("percent-price bandı: POST_ONLY + offset/TWAP/iceberg");
    }

    // BALANCE uyarısı → pro-rata azalt (yukarıda TRIM yoksa)
    if (has("BALANCE") && !trimF){
      notional = Math.max(0, Math.floor(notional * 0.9)); // kaba %10 kıs
      reasons.push("balance yetersiz: notional↓");
    }

    return { symbol: s.symbol, action, notionalUsd: notional, reason: reasons };
  }

  private bound(e: ExecParams): ExecParams {
    e.limitOffsetBps = clamp(e.limitOffsetBps, 0, 15);
    e.twapMs         = Math.round(clamp(e.twapMs, 400, 4000));
    e.iceberg        = round(clamp(e.iceberg, 0.05, 0.5), 2);
    return e;
  }

  private validate(gi: GuardInput): string | null {
    if (!gi?.corrId) return "corrId missing";
    if (!gi.selected || !gi.selected.exec) return "selected plan missing";
    if (!gi.feas || !Array.isArray(gi.feas.symbols)) return "feasibility missing";
    if (!gi.risk) return "risk missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/execGuardrailBridge.test.ts
import { describe,it,expect } from "vitest";
import { ExecGuardrailBridge } from "../execGuardrailBridge";
import type { GuardInput } from "../execGuardrailBridge.types";

function baseGI(): GuardInput {
  return {
    corrId:"corr-1",
    selected:{
      id:"A", title:"Plan A", variant:"BAL",
      symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}],
      exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }
    },
    feas:{
      planId:"A", variant:"BAL", score:78,
      symbols:[
        { symbol:"BTCUSDT", requestedNotionalUsd:8000, estimatedPrice:65000, estimatedQty:0.12, score:82,
          findings:[ {type:"TRIM",severity:"WARN",message:"notional>allowed"} ], adjustedNotionalUsd:6000
        },
        { symbol:"ETHUSDT", requestedNotionalUsd:4000, estimatedPrice:3000, estimatedQty:1.33, score:40,
          findings:[ {type:"PERCENT_PRICE",severity:"WARN",message:"band dışı"} ]
        }
      ],
      summaryFindings:[],
      recommend:"ADJUST"
    } as any,
    risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" }
  };
}

describe("VIVO-10 execGuardrailBridge", ()=>{
  it("applies TRIM and percent-price patches", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run(baseGI());
    const btc = out.symbols.find((s:any)=>s.symbol==="BTCUSDT");
    const eth = out.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(btc.notionalUsd).toBe(6000);
    expect(eth.reason.join(" ")).toMatch(/percent-price/);
    expect(out.exec.childType).toBe("POST_ONLY"); // percent-price tetiklemiş olmalı (AMBER + finding)
  });

  it("enforces reduce-only on sentinel halt", ()=>{
    const br = new ExecGuardrailBridge();
    const gi = baseGI();
    gi.risk.sentinel = "HALT_PARTIAL";
    const out:any = br.run(gi);
    expect(out.reduceOnlyAll).toBe(true);
    expect(out.exec.childType).toBe("POST_ONLY");
  });

  it("drops MIN_NOTIONAL symbols", ()=>{
    const br = new ExecGuardrailBridge();
    const gi = baseGI();
    (gi.feas.symbols[1] as any).findings.push({type:"MIN_NOTIONAL",severity:"ERROR",message:"too small"});
    const out:any = br.run(gi);
    const eth = out.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.action).toBe("DROP");
  });
});

Entegrasyon Akışı

VIVO-05/06 → varyant + feasibility hazır.

VIVO-09 → plan/variant atandı (corrId).

VIVO-10 (vivo.guard.request) → guard kurallarını uygular, ops.exec.patch yayınlar.

VIVO-02 → patch’i alır; tick/lot/notional & percent-price kurallarıyla kesin emirleri üretir.

GB-22/36 → TCA sonuçları → VIVO-09 uplift, VIVO-07 açıklama.
_________________________________________________________________________________________________________________
VIVO-11 · spotCashAllocator.ts

Amaç (tek cümle):
Toplam özsermaye (equity), bakiye ve piyasa koşullarına göre hedef spot payını korumak (%30 kuralı), whitelist & +%4 politika eşiğine uyan sembollerle rebalans alış/satış planı üretmek; sentinel/risk durumunda reduce-only moduna geçerek güvenli daraltma yapabilmek.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; analytics (expectedMovePct, R) kapanmış veriden gelmeli (VIVO-01/GB).

Politika: minTargetPct ≥ +%4 ve whitelist dışı sembol rebalansa alınmaz.

Spot payı kuralı: equity ≥ equityThresholdUsd ise hedef spotPayı = %30 (Policy’den). Altında ise 0–%30 arası esnek (opsiyonel DCA küçük dilimler).

Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER → yeni alım yok; yalnız reduce-only (fazla spotu azalt).

Borsa kuralları: MIN_NOTIONAL, LOT_SIZE, PRICE_FILTER, PERCENT_PRICE(_BY_SIDE) ön-kontrolü yapılır (kesin kuantizasyon VIVO-02).

Slipaj/komisyon muhasebesi: hedef notional ±%0.2 emniyet payı; komisyon + potansiyel slipaj kadar aşağı hedefle.

Idempotency: Aynı corrId ile ikinci plan yayınlanmaz.

Arayüzler (TypeScript / JSDoc)
// vivo/spotCashAllocator.types.ts
export type ISODate = string;
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Level = "GREEN"|"AMBER"|"RED";

export interface Policy {
  whitelist: string[];
  minTargetPct: number;           // ≥ 4 (yüzde)
  spot: { targetPct: number; equityThresholdUsd: number }; // ör: 0.30 ve 100_000
}

export interface AccountSnapshot {
  asOf: ISODate;
  equityUsd: number;              // toplam (spot+usdt+PNL)
  balances: Array<{ asset:string; free:number; locked:number }>;
}

export interface PriceMap {
  [symbol: string]: number;       // SYMBOL mid/last (USD cinsinden)
}

export interface AnalyticsRow { expectedMovePct:number; R_multiple:number; }
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface ExchangeRule {
  symbol:string; tickSize:number; stepSize:number; minNotional:number;
  percent?: { up:number; down:number; refMins?:number };
}

export interface RiskState { level:Level; sentinel:Sentinel; }

export interface RebalanceLeg {
  symbol: string;
  side: "BUY"|"SELL";
  notionalUsd: number;            // hedef notional (işlem büyüklüğü)
  estPrice: number;
  estQty: number;                 // stepSize’a yaklaşık yuvarlanmış (kesin VIVO-02'de)
  reason: string;                 // "reach_target", "reduce_only", "trim_overflow"
}

export interface RebalancePlan {
  corrId: string;
  asOf: ISODate;
  targetSpotUsd: number;
  currentSpotUsd: number;
  diffUsd: number;                // + ise alım, − ise satım ihtiyacı
  legs: RebalanceLeg[];
  execHints: { twapMs:number; iceberg:number; childType:"LIMIT"|"POST_ONLY";
               postOnlyForBuy?: boolean; slices?: number; };
  mode: "NORMAL"|"REDUCE_ONLY";   // sentinel’e göre
}

export interface AllocInput {
  policy: Policy;
  account: AccountSnapshot;
  prices: PriceMap;               // {"BTCUSDT":65000,...}
  analytics: AnalyticsMap;        // +%4 ve R eşiği için
  rules: Record<string, ExchangeRule>;
  risk: RiskState;
  // evren ve yönlendirme
  candidates?: string[];          // opsiyonel, yoksa policy.whitelist
  dominanceTilt?: Record<string, number>; // {"BTCUSDT":1.2,"ETHUSDT":1.1,...} ağırlık çarpanları
}

export interface AllocOutput extends RebalancePlan {}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus

Subscribe:

acct.snapshot (bakiye+equity)

risk.state

analytics.map (expectedMovePct, R)

prices.mid (bookTicker→mid)

exchange.rules (tick/step/minNotional)

policy.update

Publish:

vivo.spot.rebalance (RebalancePlan)

ops.actions.suggest (VIVO-02’nin child order üretmesi için öneri paket)

audit.log (hedef vs mevcut vs neden)

Varyantlandırma Mantığı (özet)

targetSpotUsd = equity ≥ threshold ? equity * targetPct : equity * (targetPct * 0.5)

currentSpotUsd = ∑(non-USDT spot pozisyon USD)

diffUsd = targetSpotUsd − currentSpotUsd

diffUsd > 0 & sentinel NORMAL → BUY ayakları (eşit/tilt ağırlıklarıyla)

diffUsd > 0 & sentinel ≠ NORMAL → bekle (BUY yok; plan REDUCE_ONLY)

diffUsd < 0 → SELL ayakları (reduce-only)

Seçim filtresi: sadece whitelist ∩ candidates ve expectedMovePct ≥ minTargetPct ve R ≥ 1.2.

Ağırlık dağıtımı: eşit veya dominanceTilt ile çarpanlanmış normalize paylar.

Küçük parçalar: MIN_NOTIONAL altına düşen leg → birleştir veya ele.

Exec hints: AMBER → twapMs +200, iceberg +0.02; BUY için postOnlyForBuy=true (cross risk’i azalt).

Kod İskeleti
// vivo/spotCashAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocInput, AllocOutput, RebalanceLeg, RebalancePlan,
  ExchangeRule, StdError
} from "./spotCashAllocator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const sum = (a:number[], z=0)=> a.reduce((x,y)=>x+y, z);

export class SpotCashAllocator extends EventEmitter {
  ver="1.0.0"; src="VIVO-11";
  private seen = new Set<string>();

  attach(){
    bus.on<AllocInput>("vivo.spot.request", (inp)=> this.safeRun(inp));
  }

  safeRun(inp: AllocInput){
    const out = this.run(inp);
    if ("error" in (out as any)) {
      logger.error(out, "VIVO-11 failed");
    } else {
      const plan = out as AllocOutput;
      bus.emit<AllocOutput>("vivo.spot.rebalance", plan);
      bus.emit("ops.actions.suggest", this.toOpsActions(plan));
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ target:plan.targetSpotUsd, current:plan.currentSpotUsd, diff:plan.diffUsd, legs:plan.legs.length }});
    }
  }

  run(inp: AllocInput): AllocOutput | { error: StdError } {
    try{
      const v = this.validate(inp); if (v) return this.err("VALIDATION_ERROR", v);

      const now = new Date().toISOString();
      const corrId = `spot-${Date.now()}`;
      if (this.seen.has(corrId)) return this.err("IDEMPOTENT","duplicate corrId");
      this.seen.add(corrId);

      const wl = new Set((inp.candidates && inp.candidates.length? inp.candidates: inp.policy.whitelist));
      const prices = inp.prices;

      // 1) Hedef spot
      const threshold = inp.policy.spot.equityThresholdUsd;
      const basePct   = inp.policy.spot.targetPct;
      const targetPct = inp.account.equityUsd >= threshold ? basePct : basePct*0.5;
      const targetSpotUsd = Math.round(inp.account.equityUsd * targetPct);

      // 2) Mevcut spot USD
      const isStable = (a:string)=> a==="USDT" || a==="BUSD" || a==="FDUSD" || a==="USDC";
      const spotAssets = inp.account.balances.filter(b=> !isStable(b.asset));
      let currentSpotUsd = 0;
      for (const b of spotAssets){
        const sym = `${b.asset}USDT`;
        const px = prices[sym] ?? 0;
        currentSpotUsd += px * (b.free + b.locked);
      }
      currentSpotUsd = Math.round(currentSpotUsd);

      const diffUsd = Math.round(targetSpotUsd - currentSpotUsd);
      const mode = (inp.risk.sentinel==="NORMAL") ? "NORMAL" : "REDUCE_ONLY";

      // 3) Uygun semboller (politika + analytics)
      const pool = Array.from(wl).filter(s=>{
        const an = inp.analytics[s];
        return !!an && an.expectedMovePct >= inp.policy.minTargetPct && (an.R_multiple??0) >= 1.2;
      });

      // 4) Ağırlıklar
      const weights = this.normalizeWeights(pool, inp.dominanceTilt);

      // 5) Leg üretimi
      const legs: RebalanceLeg[] = [];
      if (diffUsd > 0 && mode==="NORMAL"){
        // BUY paylaştır
        for (const s of pool){
          const alloc = Math.max(0, Math.round(diffUsd * (weights[s]||0)));
          if (alloc<=0) continue;
          const leg = this.mkLeg("BUY", s, alloc, prices[s], inp.rules[s], "reach_target");
          if (leg) legs.push(leg);
        }
      } else if (diffUsd < 0) {
        // SELL: en büyük USD değerli varlıklardan başlayarak azalt
        const valued = spotAssets
          .map(b=>({ symbol:`${b.asset}USDT`, usd:(prices[`${b.asset}USDT`]||0)*(b.free+b.locked), qty:(b.free+b.locked) }))
          .filter(x=> wl.has(x.symbol));
        valued.sort((a,b)=>b.usd-a.usd);

        let remain = Math.abs(diffUsd);
        for (const v of valued){
          if (remain<=0) break;
          const cut = Math.min(v.usd, remain);
          const leg = this.mkLeg("SELL", v.symbol, Math.round(cut), prices[v.symbol], inp.rules[v.symbol], "reduce_only");
          if (leg){ legs.push(leg); remain -= cut; }
        }
      }
      // MIN_NOTIONAL altındaki parçaları ele
      const filtered = legs.filter(l=> l.notionalUsd >= (inp.rules[l.symbol]?.minNotional ?? 10));

      // 6) Exec ipuçları (AMBER → korumacı)
      const hints = {
        twapMs: (inp.risk.level==="AMBER") ? 1600 : 1200,
        iceberg: (inp.risk.level==="AMBER") ? 0.16 : 0.12,
        childType: "LIMIT" as const,
        postOnlyForBuy: true,
        slices: Math.min(10, Math.max(2, Math.floor(filtered.length/2)+2))
      };

      const plan: RebalancePlan = {
        corrId, asOf: now,
        targetSpotUsd, currentSpotUsd, diffUsd,
        legs: filtered,
        execHints: hints,
        mode
      };
      return plan;

    } catch(e:any){
      return this.err("ALLOC_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private mkLeg(side:"BUY"|"SELL", symbol:string, notional:number, price:number|undefined, rule:ExchangeRule|undefined, reason:string): RebalanceLeg | null {
    if (!price || !rule) return null;
    const qty = Math.floor((notional / price) / rule.stepSize) * rule.stepSize;
    if (qty <= 0) return null;
    return { symbol, side, notionalUsd:notional, estPrice:price, estQty:qty, reason };
  }

  private normalizeWeights(pool:string[], tilt?:Record<string,number>){
    if (!pool.length) return {} as Record<string,number>;
    const raw = pool.map(s=> Math.max(0, tilt?.[s] ?? 1));
    const tot = sum(raw, 0) || 1;
    const out: Record<string,number> = {};
    pool.forEach((s,i)=> out[s] = raw[i]/tot);
    return out;
  }

  private validate(x: AllocInput): string | null {
    if (!x?.policy || !x?.account || !x?.prices || !x?.analytics || !x?.rules || !x?.risk) return "missing fields";
    if ((x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be ≥ 4";
    if (!Array.isArray(x.account.balances)) return "account.balances invalid";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e }});
    return { error: e };
  }

  private toOpsActions(plan: RebalancePlan){
    // VIVO-02’nin çocuk emir üretmesi için minimal öneri formatı
    const children = plan.legs.map(l=>({
      symbol:l.symbol,
      side:l.side,
      type: plan.execHints.childType,
      qty:l.estQty,
      reduceOnly: (plan.mode==="REDUCE_ONLY" || l.side==="SELL") ? true : false,
      postOnly: (l.side==="BUY" && plan.execHints.postOnlyForBuy) ? true : false,
      meta:{ twapMs:plan.execHints.twapMs, iceberg:plan.execHints.iceberg, slices:plan.execHints.slices }
    }));
    return { asOf:plan.asOf, planId:"C", children, comments:[`spot target ${plan.targetSpotUsd} / diff ${plan.diffUsd}`] };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/spotCashAllocator.test.ts
import { describe,it,expect } from "vitest";
import { SpotCashAllocator } from "../spotCashAllocator";
import type { AllocInput } from "../spotCashAllocator.types";

const base: AllocInput = {
  policy: { whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct:4,
            spot:{ targetPct:0.30, equityThresholdUsd:100_000 } },
  account: { asOf:new Date().toISOString(), equityUsd:120_000,
             balances:[ {asset:"USDT", free:70_000, locked:0}, {asset:"BTC", free:0.2, locked:0}, {asset:"ETH", free:1.0, locked:0} ] },
  prices: { BTCUSDT:65000, ETHUSDT:3000, OPUSDT:6.0, USDTUSDT:1 },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:7, R_multiple:1.4 } },
  rules: { BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.0001, minNotional:10 },
           ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001,  minNotional:10 },
           OPUSDT:{  symbol:"OPUSDT",  tickSize:0.001,stepSize:0.1,    minNotional:10 } },
  risk: { level:"GREEN", sentinel:"NORMAL" },
  dominanceTilt: { BTCUSDT:1.2, ETHUSDT:1.0, OPUSDT:0.8 }
};

describe("VIVO-11 spotCashAllocator", ()=>{
  it("builds BUY legs to reach 30% spot when equity ≥ threshold", ()=>{
    const alloc = new SpotCashAllocator();
    const out:any = alloc.run(base);
    expect(out.targetSpotUsd).toBe(36000); // 120k * 0.30
    expect(out.diffUsd).toBeGreaterThan(0);
    expect(out.legs.some((l:any)=>l.side==="BUY")).toBe(true);
  });

  it("switches to reduce-only under sentinel", ()=>{
    const alloc = new SpotCashAllocator();
    const inp = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = alloc.run(inp);
    // diff>0 olsa bile BUY üretmemeli
    expect(out.mode).toBe("REDUCE_ONLY");
    expect(out.legs.every((l:any)=>l.side==="SELL")).toBe(true);
  });

  it("filters symbols by +%4 and whitelist", ()=>{
    const alloc = new SpotCashAllocator();
    const inp = structuredClone(base);
    // ETH’i uygunsuz yap
    inp.analytics.ETHUSDT.expectedMovePct = 3.0;
    const out:any = alloc.run(inp);
    // ETH leg sayısı azalmalı veya sıfır olmalı
    expect(out.legs.filter((l:any)=>l.symbol==="ETHUSDT").length).toBe(0);
  });
});

Entegrasyon Akışı

acct.snapshot, prices.mid, analytics.map, exchange.rules, risk.state, policy.update olayları güncelken; vivo.spot.request tetiklenir.

VIVO-11 rebalans planını üretir → vivo.spot.rebalance ve VIVO-02 için ops.actions.suggest.

VIVO-02 çocuk emirleri (TWAP/iceberg/post-only) kesinleştirir; planFeasibilityChecker (VIVO-06) son kontrol.

GB-22/36 TCA sonuçları → VIVO-09 uplift & VIVO-04 hafıza ağırlıkları günceller.
_________________________________________________________________________________________________________________
tamam reis — birleşik (V2+V3) standardıyla VIVO-12 · sessionPacingPlanner.ts’ı çıkarıyorum. Bu modül; likidite/vol rejimi, risk/sentinel ve canlı TCA verisine göre seans bazlı işlem yoğunluğu ve risk pacing planı üretir. VIVO-02’ye “kaç yeni pozisyon / dakika başına kaç child / risk bütçesi / slipaj toleransı” gibi kotaları gönderir; VIVO-03’te kart olarak gösterilir.

VIVO-12 · sessionPacingPlanner.ts

Amaç (tek cümle):
Asia–EU–US seanslarında ve düşük likidite saatlerinde işlem frekansı ve risk bütçesini dinamik kotalarla düzenleyip, slipaj-şok anlarında yavaşlat/stop verebilen deterministik bir pacing katmanı üretmek.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok. Yalnız kapanmış barlardan gelen vol/ATR; canlı yürütme metrikleri (spread, depth, WS lag) anlık.

Risk/Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER → yeni pozisyon kota=0, yalnız reduce-only.

Likidite filtresi: avg spread↑, L2 depth↓, WS lag↑ ise kota lineer düşer.

TCA geri besleme: realized slipaj/mark-out kötüleşirse tolerans↓ ve kota↓.

Rate limit uyumu: child-per-minute, REQUEST_WEIGHT ve ORDERS limitleri aşılmayacak.

Overfit koruması: sabit eşik yok; üst/alt bant + EWMA ile tepki ver.

Arayüzler (TypeScript)
// vivo/sessionPacingPlanner.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface SessionWindow {
  id: "ASIA"|"EU"|"US"|"LOW_LIQ";
  startUtc: string;   // "00:00"
  endUtc:   string;   // "08:00"
  weight: number;     // 0..1 temel likidite katsayısı (örn: EU=1, ASIA=0.8, LOW_LIQ=0.4)
}

export interface PacingPolicy {
  baseMaxNewPositions: number;  // seans başı
  baseChildPerMin: number;      // dakikada child emir üst sınırı
  baseRiskBudgetUsd: number;    // seans başı risk bütçesi
  slipBpSoft: number;           // yumuşak slipaj tavanı (bps)
  slipBpHard: number;           // sert tavan; aşılırsa slowdown/stop
  markoutBp5sSoft: number;      // 5s mark-out yumuşak eşik
  ewmaAlpha: number;            // 0.05..0.3
}

export interface LiquidityMetrics {
  asOf: string;
  wsLagMs: number;                 // WS consumer gecikmesi
  avgSpreadBp: number;             // whitelist ortalama
  l2DepthUsd: number;              // top-of-book±N price toplam
  msgRatePerSec: number;           // diff stream hızı
}

export interface TcaSnapshot {
  asOf: string;
  slipBpEWMA: number;              // realized bps (EWMA)
  markoutBp5sEWMA: number;         // 5s mark-out (EWMA)
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface RateLimitBudget {
  // borsa limitlerini aşmamak için muhafazakâr pay
  requestWeightPerMin: number;   // ör: 4800 (6000 limitin %80’i)
  ordersPer10s: number;          // ör: 80 (limit 100’ün %80’i)
}

export interface PacingInput {
  nowIso: string;
  sessionWindows: SessionWindow[];
  policy: PacingPolicy;
  risk: RiskState;
  liq: LiquidityMetrics;
  tca: TcaSnapshot;
  rate: RateLimitBudget;
}

export interface PacingPlan {
  asOf: string;
  sessionId: SessionWindow["id"];
  factors: { session:number; liq:number; risk:number; tca:number };
  maxNewPositions: number;
  maxChildPerMin: number;
  riskBudgetUsd: number;
  slipSoftBp: number;
  slipHardBp: number;
  reduceOnly: boolean;
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: risk.state, gb.liquidity.metrics, gb.tca.summary, rate.limit.budget, clock.tick1m.

Publish: vivo.pacing.plan (PacingPlan), audit.log.

Pacing mantığı (özet)

Toplam katsayı = session × liq × risk × tca, her biri 0..1.

session: aktif pencerenin weight.

liq: spread↑ (kötü), depth↓, wsLag↑ → 1’den aşağı skala (örn. 0.4–1 arası).

risk: GREEN=1, AMBER=0.7, RED=0.4, sentinel≠NORMAL → 0.0 ve reduceOnly=true.

tca: slipEWMA ve markoutEWMA soft bandı aşarsa 0.6; hard band aşarsa slowdown/stop (0.2/0.0).

Kota = policy taban × toplam katsayı; rate limit koruma:

maxChildPerMin ≤ requestWeightPerMin ve ordersPer10s’den türetilen muhafazakâr üst sınır.

Kod İskeleti
// vivo/sessionPacingPlanner.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  PacingInput, PacingPlan, SessionWindow, StdError
} from "./sessionPacingPlanner.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const toMin = (iso:string)=> new Date(iso).toISOString().slice(11,16); // "HH:MM" UTC

export class SessionPacingPlanner extends EventEmitter {
  ver="1.0.0"; src="VIVO-12";
  private last:PacingInput | null = null;

  attach(){
    bus.on<PacingInput>("vivo.pacing.input", (x)=> this.safeRun(x));
    // periyodik tetik (1 dakikada bir yeniden üret)
    bus.on("clock.tick1m", ()=> { if (this.last) this.safeRun(this.last); });
  }

  safeRun(x:PacingInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-12 failed");
    } else {
      const plan = res as PacingPlan;
      bus.emit<PacingPlan>("vivo.pacing.plan", plan);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ session:plan.sessionId, maxNew:plan.maxNewPositions, childPerMin:plan.maxChildPerMin, reduceOnly:plan.reduceOnly }});
      this.last = x;
    }
  }

  run(x:PacingInput): PacingPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const session = this.pickSession(x.nowIso, x.sessionWindows);
      const fSession = session.weight;

      // likidite faktörü (0.4..1): spread↑, depth↓, wsLag↑ → düşür
      const fLiq = this.liqFactor(x);

      // risk/sentinel faktörü
      const { factor: fRisk, reduceOnly } = this.riskFactor(x);

      // TCA faktörü (slip/markout)
      const fTca = this.tcaFactor(x);

      const factor = clamp(fSession * fLiq * fRisk * fTca, 0, 1);

      // taban kotalar
      const baseNew = x.policy.baseMaxNewPositions;
      const baseChild = x.policy.baseChildPerMin;
      const baseRisk = x.policy.baseRiskBudgetUsd;

      // rate limit koruma: child-per-min üst sınırı
      const rlChildCap = Math.floor(Math.min(
        x.rate.requestWeightPerMin * 0.9, // muhafazakâr
        x.rate.ordersPer10s * 6 * 0.9     // 10s pencereden dakikaya
      ));

      const plan:PacingPlan = {
        asOf: new Date().toISOString(),
        sessionId: session.id,
        factors:{ session:fSession, liq:fLiq, risk:fRisk, tca:fTca },
        maxNewPositions: Math.max( reduceOnly ? 0 : Math.floor(baseNew * factor), 0 ),
        maxChildPerMin: Math.max( reduceOnly ? 5 : Math.floor(baseChild * factor), 0 ), // reduceOnly’da küçük bir teknik limit bırak
        riskBudgetUsd: Math.max( reduceOnly ? Math.floor(baseRisk*0.25) : Math.floor(baseRisk * factor), 0 ),
        slipSoftBp: Math.round(x.policy.slipBpSoft * (1/fTca)), // kötü TCA’da daha sıkı
        slipHardBp: x.policy.slipBpHard,
        reduceOnly,
        notes:[]
      };

      // rate limit üst sınırına uygula
      plan.maxChildPerMin = Math.min(plan.maxChildPerMin, rlChildCap);

      // notlar
      if (reduceOnly) plan.notes?.push("sentinel aktif: yeni pozisyon yok; reduce-only");
      if (fLiq<0.7)   plan.notes?.push("likidite zayıf: kota düşürüldü");
      if (fTca<0.7)   plan.notes?.push("TCA kötü: slipaj/mark-out nedeniyle yavaşlatıldı");

      return plan;

    } catch (e:any){
      return this.err("PACING_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private pickSession(nowIso:string, windows:SessionWindow[]): SessionWindow {
    const hhmm = toMin(nowIso); // UTC HH:MM
    const asMin = (s:string)=> Number(s.slice(0,2))*60 + Number(s.slice(3,5));
    const nowM = asMin(hhmm);

    // kapsayan pencere(ler)i bul; çakışma varsa weight en yüksek olanı seç
    const cand = windows.filter(w=>{
      const a=asMin(w.startUtc), b=asMin(w.endUtc);
      return a<=b ? (nowM>=a && nowM<b) : (nowM>=a || nowM<b); // gece devri
    });
    if (cand.length===0) return { id:"LOW_LIQ", startUtc:"00:00", endUtc:"23:59", weight:0.5 };
    return cand.sort((p,q)=> q.weight - p.weight)[0];
  }

  private liqFactor(x:PacingInput){
    // normalize: spread 2–20bp → 1..0.5, depth 50k–1M → 0.5..1, wsLag 0–400ms → 1..0.6
    const s = clamp(1 - (x.liq.avgSpreadBp-2)/(20-2)*0.5, 0.5, 1);
    const d = clamp((x.liq.l2DepthUsd-50_000)/(1_000_000-50_000), 0, 1)*0.5 + 0.5;
    const l = clamp(1 - (x.liq.wsLagMs/400)*0.4, 0.6, 1);
    return clamp(s * d * l, 0.4, 1);
  }

  private riskFactor(x:PacingInput){
    let f = 1, reduceOnly = false;
    if (x.risk.sentinel!=="NORMAL"){ f = 0; reduceOnly = true; }
    else if (x.risk.level==="RED"){ f = 0.4; }
    else if (x.risk.level==="AMBER"){ f = 0.7; }
    return { factor:f, reduceOnly };
  }

  private tcaFactor(x:PacingInput){
    let f = 1;
    if (x.tca.slipBpEWMA > x.policy.slipBpHard || x.tca.markoutBp5sEWMA > x.policy.markoutBp5sSoft*2){
      f = 0.2; // neredeyse stop
    } else if (x.tca.slipBpEWMA > x.policy.slipBpSoft || x.tca.markoutBp5sEWMA > x.policy.markoutBp5sSoft){
      f = 0.6; // slowdown
    }
    return f;
    }

  private validate(x:PacingInput): string | null {
    if (!x?.policy || !x?.risk || !x?.liq || !x?.tca || !x?.rate) return "missing fields";
    if ((x.policy.ewmaAlpha??0) <= 0 || x.policy.ewmaAlpha > 0.5) return "ewmaAlpha invalid";
    if (!Array.isArray(x.sessionWindows) || x.sessionWindows.length===0) return "session windows missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Örnek Konfig (24/7 kriptoda seans pencereleri)
// config/session.windows.ts
export const SESSION_WINDOWS = [
  { id:"ASIA", startUtc:"00:00", endUtc:"08:00", weight:0.8 },
  { id:"EU",   startUtc:"07:00", endUtc:"15:30", weight:1.0 },
  { id:"US",   startUtc:"13:00", endUtc:"21:00", weight:0.95 },
  { id:"LOW_LIQ", startUtc:"21:00", endUtc:"00:00", weight:0.6 } // gece geç saatler
];

Test İskeleti (Vitest)
// vivo/__tests__/sessionPacingPlanner.test.ts
import { describe,it,expect } from "vitest";
import { SessionPacingPlanner } from "../sessionPacingPlanner";

const base = {
  nowIso: new Date(Date.UTC(2025,0,1,12,0,0)).toISOString(), // 12:00 UTC
  sessionWindows: [
    { id:"EU", startUtc:"07:00", endUtc:"15:30", weight:1.0 },
    { id:"US", startUtc:"13:00", endUtc:"21:00", weight:0.95 },
    { id:"ASIA", startUtc:"00:00", endUtc:"08:00", weight:0.8 }
  ],
  policy:{ baseMaxNewPositions:12, baseChildPerMin:90, baseRiskBudgetUsd:100_000,
    slipBpSoft:8, slipBpHard:20, markoutBp5sSoft:6, ewmaAlpha:0.15 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" },
  liq:{ asOf:new Date().toISOString(), wsLagMs:120, avgSpreadBp:5, l2DepthUsd:300_000, msgRatePerSec:800 },
  tca:{ asOf:new Date().toISOString(), slipBpEWMA:6, markoutBp5sEWMA:4 },
  rate:{ requestWeightPerMin:4800, ordersPer10s:80 }
};

describe("VIVO-12 sessionPacingPlanner", ()=>{
  it("produces scaled quotas under AMBER risk", ()=>{
    const m = new SessionPacingPlanner();
    const out:any = m.run(base as any);
    expect(out.sessionId).toBe("EU");
    expect(out.maxNewPositions).toBeGreaterThan(0);
    expect(out.maxChildPerMin).toBeGreaterThan(0);
  });

  it("forces reduce-only when sentinel active", ()=>{
    const m = new SessionPacingPlanner();
    const inp:any = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = m.run(inp);
    expect(out.reduceOnly).toBe(true);
    expect(out.maxNewPositions).toBe(0);
  });

  it("slowdowns when TCA is bad", ()=>{
    const m = new SessionPacingPlanner();
    const inp:any = structuredClone(base);
    inp.tca.slipBpEWMA = 12; // soft üstü
    const out:any = m.run(inp);
    expect(out.factors.tca).toBeLessThan(1);
  });
});

Entegrasyon Akışı

Aggregator per dakika vivo.pacing.input (risk.state, liq.metrics, tca.summary, rate.budget ile).

VIVO-12 vivo.pacing.plan yayınlar → VIVO-02 emir üretirken kotalara uyar (child/dakika, yeni pozisyon sayısı, risk bütçesi, slip toleransı).

VIVO-03 kartta “Seans: EU | maxNew=… | child/min=… | reduceOnly=…” özetini gösterir.

GB-22/36 sonuçlandıkça TCA EWMA güncellenir; bir sonraki dakikada pacing otomatik adaptasyon sağlar.
_________________________________________________________________________________________________________________
VIVO-13 · riskBudgetAllocator.ts

Amaç (tek cümle):
Seans bazında tanımlı risk bütçesini, canlı edge (PF/hit/R), volatilite ve korrelasyona göre adil, emniyetli ve yürütülebilir şekilde strateji/cluster/simgelere dağıtmak.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; yalnız kapanmış bar/son TCA (GB-22/36), pace (VIVO-12), portföy ve borsa kuralları kullanılır.

Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER → yeni risk 0; yalnız reduce-only tahsis (mevcut pozisyon küçültme önerisi).

Binance filtreleri: PRICE_FILTER, PERCENT_PRICE(_BY_SIDE), LOT_SIZE, MIN/NOTIONAL, MAX_POSITION.

Kelly-light: ¼-Kelly tavanı; seri kayıpta (LIVIA) risk damping (örn. ×0.5).

Politika: whitelist ve minTargetPct ≥ +%4 eşiği; altı kalan simgeler tahsisten çıkarılır.

Eşzamanlılık/Idempotency: Tek corrId içinde bir tahsis planı; aynı corr tekrarlanmaz.

Arayüzler (TypeScript)
// vivo/riskBudgetAllocator.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface PacingPlan {
  asOf: string;
  sessionId: "ASIA"|"EU"|"US"|"LOW_LIQ";
  maxNewPositions: number;
  riskBudgetUsd: number;         // seanslık risk bütçesi (VIVO-12)
  reduceOnly: boolean;
}

export interface PolicyAlloc {
  whitelist: string[];
  minTargetPct: number;          // ≥ +4
  maxPerSymbolRiskPct: number;   // equity başına risk tavanı (örn. 0.8%)
  maxPerClusterRiskPct: number;  // equity başına cluster tavanı (örn. 2.5%)
  kellyLightFactor: number;      // 0.25 (¼ Kelly)
}

export interface PortfolioSnapshot {
  asOf: string;
  equityUsd: number;
  spotUsd: number;
  perpsNetUsd: number;
  exposureUsdBySymbol: Record<string, number>;   // mevcut maruz kalım (mutlak)
}

export interface TcaLite {
  slipBpEWMA: number;
  markoutBp5sEWMA: number;
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
  lossStreak?: number;           // üst üste SL sayısı (LIVIA bildirir)
}

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  status?: "TRADING"|"HALT"|"BREAK";
}

export interface BookTicker { symbol:string; bid:number; ask:number; mid:number; asOf:string; }

/** Edge/Vol girişleri (Grafik Beyni + Denetim Asistanı) */
export interface SymbolStat {
  symbol: string;
  cluster: string;               // ör: "breakout", "meanreversion", "trend"
  pf: number;                    // profit factor (≤ 3 ile clamp)
  hit: number;                   // 0..1
  avgR: number;                  // ortalama R (kâr/zarar oranı, negatifte clamp)
  volAtrPct: number;             // ATR/Price (%)
  stopFrac: number;              // planlanan SL uzaklığı (fiyatın %’si, ör: 0.008)
}
export interface CorrelationMatrix {
  // sembol bazlı korelasyon (−1..1), simetrik, diyagonal 1
  symbols: string[];
  rho: number[][];
}

export interface AllocatorInput {
  corrId: string;
  pacing: PacingPlan;
  policy: PolicyAlloc;
  portfolio: PortfolioSnapshot;
  tca: TcaLite;
  risk: RiskState;
  stats: SymbolStat[];                  // yalnız whitelist içi ve uygun sinyaller
  corr: CorrelationMatrix;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
}

export interface RiskLeg {
  symbol: string;
  cluster: string;
  targetRiskUsd: number;               // $ risk (SL’e kadar kayıp)
  estNotionalUsd: number;              // tahmini notional (risk/stopFrac)
  kellyCapUsd: number;                 // Kelly-light tavanı
  reasons: string[];
}

export interface ClusterSum {
  cluster: string;
  riskUsd: number;
}

export interface RiskAllocPlan {
  asOf: string;
  sessionId: PacingPlan["sessionId"];
  corrId: string;
  reduceOnly: boolean;
  totalRiskUsd: number;                // fiilen dağıtılan risk
  legs: RiskLeg[];
  byCluster: ClusterSum[];
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.pacing.plan, portfolio.snapshot, policy.alloc, gb.tca.summary, risk.state, gb.stats.edgevol, gb.corr.matrix, ex.rules, ex.tickers.

Publish: vivo.risk.alloc.plan (RiskAllocPlan), vivo.risk.alloc.delta (mevcut maruziyet → hedef farkı), audit.log.

Tahsis Heuristiği (özet)

Uygunluk filtresi: status=TRADING, whitelist, minTargetPct ≥ +%4 (statlar bu barajı geçmiş olmalı).

Edge skoru:

𝑒
𝑑
𝑔
𝑒
𝑖
=
𝑐
𝑙
𝑎
𝑚
𝑝
(
𝑃
𝐹
𝑖
,
1
,
3
)
×
𝑐
𝑙
𝑎
𝑚
𝑝
(
ℎ
𝑖
𝑡
𝑖
,
0.35
,
0.75
)
×
𝑐
𝑙
𝑎
𝑚
𝑝
(
𝑎
𝑣
𝑔
𝑅
𝑖
,
0.2
,
2
)
edge
i
	​

=clamp(PF
i
	​

,1,3)×clamp(hit
i
	​

,0.35,0.75)×clamp(avgR
i
	​

,0.2,2)

Vol penalizasyonu: volPenalty_i = 1 / sqrt(1 + (volAtrPct_i / v0)^2) (v0 ≈ 2.5).

Korrelasyon indirgeme: her sembol için

𝑐
𝑜
𝑟
𝑟
𝑃
𝑒
𝑛
𝑎
𝑙
𝑡
𝑦
𝑖
=
1
1
+
∑
𝑗
≠
𝑖
𝑤
𝑗
𝑝
𝑟
𝑒
⋅
max
⁡
(
𝜌
𝑖
𝑗
,
0
)
corrPenalty
i
	​

=
1+∑
j

=i
	​

w
j
pre
	​

⋅max(ρ
ij
	​

,0)
	​

1
	​


(iteratif; önce w^{pre} = edge×volPen ile başla).

Damping: lossStreak ≥ 3 ise tüm skorlar ×0.5 (LIVIA).

Ham ağırlık: w_i = edge_i × volPenalty_i × corrPenalty_i, normalize et.

Risk bütçesi: risk_i = w_i × pacing.riskBudgetUsd.

Kelly-light tavanı: kellyCap_i = equity × kellyLight × (edge_i / volScale) (basitleşmiş tavan); risk_i = min(risk_i, kellyCap_i).

Cluster & sembol tavanları: ≤ maxPerClusterRiskPct×equity ve ≤ maxPerSymbolRiskPct×equity.

Notional dönüşümü: notional_i = risk_i / stopFrac_i. Binance filter/step ile yuvarla; minNotional altını düş.

Kod İskeleti
// vivo/riskBudgetAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocatorInput, RiskAllocPlan, RiskLeg, StdError, SymbolStat
} from "./riskBudgetAllocator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=2)=> Number(x.toFixed(n));

export class RiskBudgetAllocator extends EventEmitter {
  ver="1.0.0"; src="VIVO-13";
  private seen = new Set<string>();

  attach(){
    bus.on<AllocatorInput>("vivo.risk.alloc.input", (x)=> this.safeRun(x));
  }

  safeRun(x: AllocatorInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-13 failed");
    } else {
      const plan = res as RiskAllocPlan;
      bus.emit<RiskAllocPlan>("vivo.risk.alloc.plan", plan);
      // delta: hedef notional vs mevcut maruziyet → VIVO-02 için rehber
      const delta = this.toDelta(plan, x.portfolio.exposureUsdBySymbol);
      bus.emit("vivo.risk.alloc.delta", delta);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ session:plan.sessionId, totalRisk:plan.totalRiskUsd, legs:plan.legs.length, reduceOnly:plan.reduceOnly }});
    }
  }

  run(x: AllocatorInput): RiskAllocPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      if (this.seen.has(x.corrId)) return this.err("IDEMPOTENT","corrId already allocated",{corrId:x.corrId});
      const asOf = new Date().toISOString();

      // Sentinel → yeni risk yok, reduce-only plan
      if (x.pacing.reduceOnly || x.risk.sentinel!=="NORMAL"){
        const plan: RiskAllocPlan = { asOf, sessionId:x.pacing.sessionId, corrId:x.corrId,
          reduceOnly:true, totalRiskUsd:0, legs:[], byCluster:[], notes:["sentinel/reduce-only"] };
        this.seen.add(x.corrId);
        return plan;
      }

      // 1) uygun semboller
      const ok = this.eligible(x);

      // 2) skorlar
      const preW = ok.map(s=> ({ s, w: this.edgeScore(s) * this.volPenalty(s) }));
      // 3) corr penalty (tek iterasyon pragmatik)
      const withCorr = this.applyCorrPenalty(preW, x);

      // 4) damping (LIVIA)
      const damp = (x.risk.lossStreak ?? 0) >= 3 ? 0.5 : 1;
      for (const r of withCorr) r.w *= damp;

      // normalize
      const sumW = withCorr.reduce((a,b)=>a+b.w,0) || 1;
      const budget = Math.max(0, x.pacing.riskBudgetUsd);
      // 5) risk_i ve tavanlar
      const legs = [] as RiskLeg[];
      const clusterAgg: Record<string, number> = {};
      for (const r of withCorr){
        let riskUsd = budget * (r.w / sumW);
        const kCap = this.kellyCapUsd(r.s, x);
        riskUsd = Math.min(riskUsd, kCap);

        // cluster/ symbol tavanları
        const symCap = x.portfolio.equityUsd * x.policy.maxPerSymbolRiskPct;
        const clCap = x.portfolio.equityUsd * x.policy.maxPerClusterRiskPct;
        riskUsd = Math.min(riskUsd, symCap);

        // notional dönüşüm
        const px = x.tickers[r.s.symbol]?.mid;
        const rule = x.rules[r.s.symbol];
        if (!px || !rule || rule.status!=="TRADING") continue;

        const estNotional = riskUsd / Math.max(1e-6, r.s.stopFrac) ;
        const fitted = this.fitNotional(estNotional, px, rule);
        if (fitted < rule.minNotional) continue;

        // cluster kısıtı (post-check)
        const sumCl = (clusterAgg[r.s.cluster] || 0) + riskUsd;
        if (sumCl > clCap) continue;
        clusterAgg[r.s.cluster] = sumCl;

        legs.push({
          symbol:r.s.symbol, cluster:r.s.cluster,
          targetRiskUsd: round(riskUsd), estNotionalUsd: round(fitted),
          kellyCapUsd: round(kCap),
          reasons: this.reasons(r.s)
        });
      }

      const plan: RiskAllocPlan = {
        asOf, sessionId:x.pacing.sessionId, corrId:x.corrId,
        reduceOnly:false,
        totalRiskUsd: round(legs.reduce((a,b)=>a+b.targetRiskUsd,0)),
        legs,
        byCluster: Object.entries(clusterAgg).map(([cluster,riskUsd])=>({ cluster, riskUsd: round(riskUsd) })),
        notes:[]
      };
      this.seen.add(x.corrId);
      return plan;

    } catch (e:any){
      return this.err("ALLOC_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- yardımcılar ---

  private eligible(x: AllocatorInput){
    const w = new Set(x.policy.whitelist);
    return x.stats.filter(s=>{
      const ok = w.has(s.symbol) && (x.rules[s.symbol]?.status==="TRADING")
        && (s.stopFrac>0) && isFinite(s.stopFrac);
      return ok;
    });
  }

  private edgeScore(s: SymbolStat){
    const pf = clamp(s.pf, 1, 3);
    const hit = clamp(s.hit, 0.35, 0.75);
    const r = clamp(s.avgR, 0.2, 2);
    return pf * hit * r;
  }

  private volPenalty(s: SymbolStat){
    const v0 = 2.5; // ATR% ölçeği
    return 1 / Math.sqrt(1 + Math.pow(s.volAtrPct / v0, 2));
  }

  private applyCorrPenalty(pre: Array<{s:SymbolStat; w:number}>, x: AllocatorInput){
    const idx = new Map(x.corr.symbols.map((k,i)=>[k,i] as const));
    return pre.map(row=>{
      const i = idx.get(row.s.symbol); if (i===undefined) return row;
      let acc = 0;
      for (const other of pre){
        if (other.s.symbol===row.s.symbol) continue;
        const j = idx.get(other.s.symbol); if (j===undefined) continue;
        const rho = x.corr.rho[i][j];
        acc += Math.max(0, rho) * other.w; // yalnız pozitif korelasyonu cezalandır
      }
      const corrPenalty = 1 / Math.sqrt(1 + acc);
      return { s:row.s, w: row.w * corrPenalty };
    });
  }

  private kellyCapUsd(s: SymbolStat, x: AllocatorInput){
    // basitleştirilmiş Kelly ~ edge / variance; burada edgeScore ≈ getiri beklentisi proxy’si
    const edge = this.edgeScore(s);
    const varScale = Math.max(0.5, s.volAtrPct); // proxy
    const kelly = edge / (varScale*4); // kaba ölçek
    const kLight = x.policy.kellyLightFactor; // 0.25
    return Math.max(0, x.portfolio.equityUsd * kelly * kLight);
  }

  private fitNotional(targetUsd:number, px:number, rule:{ stepSize:number } & { minNotional:number }){
    // yalnız notional ve adım uyarlaması (fiyat/qty ayrışması VIVO-02’de yapılır)
    // stepSize → qty adımı; burada yalnız dolar notional’ı aşağı yuvarlıyoruz
    const notion = Math.floor(targetUsd / (rule.minNotional)) * rule.minNotional;
    return Math.max(rule.minNotional, Math.min(targetUsd, notion));
  }

  private reasons(s: SymbolStat){
    const arr = [];
    arr.push(`PF=${s.pf.toFixed(2)}`, `hit=${(s.hit*100).toFixed(0)}%`, `avgR=${s.avgR.toFixed(2)}`);
    arr.push(`ATR%=${s.volAtrPct.toFixed(2)}`, `SL=${(s.stopFrac*100).toFixed(2)}%`);
    return arr;
  }

  private toDelta(plan: RiskAllocPlan, current: Record<string,number>){
    // basit delta: hedef notional - mevcut notional (proxy olarak risk/stopFrac yok; VIVO-02 netleştirir)
    return {
      asOf: plan.asOf,
      corrId: plan.corrId,
      symbols: plan.legs.map(l=>{
        const cur = current[l.symbol] || 0;
        return { symbol:l.symbol, targetNotionalUsd:l.estNotionalUsd, currentUsd:cur, deltaUsd: round(l.estNotionalUsd - cur) };
      })
    };
  }

  private validate(x: AllocatorInput): string | null {
    if (!x?.corrId) return "corrId missing";
    if (!x?.pacing || !x?.portfolio || !x?.policy || !x?.stats || !x?.corr) return "missing fields";
    if ((x.policy.minTargetPct ?? 0) < 4) return "policy.minTargetPct must be ≥ 4";
    if (x.portfolio.equityUsd <= 0) return "equity invalid";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/riskBudgetAllocator.test.ts
import { describe,it,expect } from "vitest";
import { RiskBudgetAllocator } from "../riskBudgetAllocator";
import type { AllocatorInput } from "../riskBudgetAllocator.types";

const base: AllocatorInput = {
  corrId:"alloc-1",
  pacing:{ asOf:new Date().toISOString(), sessionId:"EU", maxNewPositions:6, riskBudgetUsd: 25_000, reduceOnly:false },
  policy:{ whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct:4, maxPerSymbolRiskPct:0.008, maxPerClusterRiskPct:0.025, kellyLightFactor:0.25 },
  portfolio:{ asOf:new Date().toISOString(), equityUsd: 200_000, spotUsd: 60_000, perpsNetUsd: 10_000, exposureUsdBySymbol:{ BTCUSDT: 8_000 } },
  tca:{ slipBpEWMA:7, markoutBp5sEWMA:5 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL", lossStreak:1 },
  stats:[
    { symbol:"BTCUSDT", cluster:"trend", pf:1.6, hit:0.52, avgR:0.45, volAtrPct:2.3, stopFrac:0.01 },
    { symbol:"ETHUSDT", cluster:"breakout", pf:1.4, hit:0.5, avgR:0.5, volAtrPct:2.8, stopFrac:0.012 },
    { symbol:"OPUSDT",  cluster:"meanrev", pf:1.2, hit:0.48, avgR:0.35, volAtrPct:3.5, stopFrac:0.009 }
  ],
  corr:{
    symbols:["BTCUSDT","ETHUSDT","OPUSDT"],
    rho:[
      [1, 0.65, 0.35],
      [0.65, 1, 0.30],
      [0.35, 0.30, 1]
    ]
  },
  rules:{
    BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, status:"TRADING" },
    ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10, status:"TRADING" },
    OPUSDT:{ symbol:"OPUSDT", tickSize:0.001, stepSize:1, minNotional:10, status:"TRADING" }
  },
  tickers:{
    BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
    ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() },
    OPUSDT:{ symbol:"OPUSDT", bid:2.5,     ask:2.51,  mid:2.505,  asOf:new Date().toISOString() }
  }
};

describe("VIVO-13 riskBudgetAllocator", ()=>{
  it("allocates positive totalRisk within caps", ()=>{
    const m = new RiskBudgetAllocator();
    const out:any = m.run(base);
    expect(out.totalRiskUsd).toBeGreaterThan(0);
    // symbol tavanı: ≤ equity*0.8% = 1600$
    for (const l of out.legs) expect(l.targetRiskUsd).toBeLessThanOrEqual(1600+1e-6);
  });

  it("goes reduce-only under sentinel", ()=>{
    const m = new RiskBudgetAllocator();
    const inp:any = structuredClone(base);
    inp.pacing.reduceOnly = true;
    const out:any = m.run(inp);
    expect(out.reduceOnly).toBe(true);
    expect(out.totalRiskUsd).toBe(0);
  });

  it("is idempotent on corrId", ()=>{
    const m:any = new RiskBudgetAllocator();
    const r1:any = m.run(structuredClone(base));
    const r2:any = m.run(structuredClone(base));
    expect(r2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon Akışı

VIVO-12 vivo.pacing.plan → seanslık riskBudgetUsd.

Grafik Beyni/Denetim gb.stats.edgevol (PF/hit/avgR/ATR%) + gb.corr.matrix.

Aggregator portfolio.snapshot, ex.rules, ex.tickers, risk.state, policy.alloc.

VIVO-13 → vivo.risk.alloc.plan (legs + byCluster) ve vivo.risk.alloc.delta.

VIVO-02 delta’ya göre çocuk emir planlar (LOT_SIZE, PERCENT_PRICE, TWAP/iceberg, POST_ONLY vs.).

GB-22/36 sonuçlandıkça TCA güncellenir; bir sonraki seans VIVO-13 edge/vol/corr ağırlıklarını otomatik adapt eder.
_________________________________________________________________________________________________________________
VIVO-14 · driftGuard.ts
Amaç (tek cümle)

Tahsis edilen hedef notional/risk ile canlı gerçekleşen maruziyet arasındaki sapmayı (drift) dakikalık döngüde ölçmek ve otomatik düzeltme eylem planı üretmek.

Gerçek dünya kuralları (latency-safe)

Kapanmamış bar yok; yalnız fills, account/position snapshot, bookTicker, rate-limit metrikleri kullanılır.

Sentinel ≠ NORMAL ⇒ yeni risk ekleme yok; yalnız reduce-only trim ve iptal/tırpan önerilir.

Binance filtreleri: PRICE_FILTER, PERCENT_PRICE(_BY_SIDE), LOT_SIZE, MIN/NOTIONAL, MAX_POSITION kontrolü yapılır.

Drift toleransı: varsayılan ±5% (plan bacak hedef notional’ı üzerinden) + mutlak min $ (örn. ≥ 25 USDT).

Idempotency: aynı plan corrId + legId için tekrar eylem üretilmez (state tutulur).

Failover: POST_ONLY 3 kez reddedildiyse ⇒ LIMIT (offset↑) → sürede dolmazsa IOC/MARKET (risk kuralı izin verirse).

Pacing/Rate-limit: VIVO-12 kotaları ve rate budget aşılmaz; child/min üst sınırı uygulanır.

Arayüzler (TypeScript)
// vivo/driftGuard.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Side     = "BUY"|"SELL";
export type ChildType= "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface PacingPlan {
  asOf: string;
  sessionId: "ASIA"|"EU"|"US"|"LOW_LIQ";
  maxChildPerMin: number;
  reduceOnly: boolean;
}

export interface RiskAllocPlanLeg {
  symbol: string;
  cluster: string;
  targetRiskUsd: number;
  estNotionalUsd: number;     // hedef notional (VIVO-13)
  reasons: string[];
}

export interface RiskAllocPlan {
  asOf: string;
  sessionId: PacingPlan["sessionId"];
  corrId: string;
  reduceOnly: boolean;
  legs: RiskAllocPlanLeg[];
}

export interface PortfolioExposure {
  asOf: string;
  bySymbolUsd: Record<string, number>; // gerçekleşen notional proxy (abs)
}

export interface ExecReport {
  // child emirler için özet rapor (VIVO-02 → router)
  orderId: string;
  symbol: string;
  side: Side;
  childType: ChildType;
  status: "NEW"|"PARTIALLY_FILLED"|"FILLED"|"CANCELED"|"REJECTED"|"EXPIRED";
  reason?: "POST_ONLY_REJECT"|"PERCENT_PRICE"|"INSUFFICIENT_BAL"|"MAX_POSITION"|"UNKNOWN";
  filledNotionalUsd?: number;
  ts: string;
  corrId?: string;
  legId?: string;
}

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  status?: "TRADING"|"HALT"|"BREAK";
  percent?: { up:number; down:number; refMins?:number };
  maxPositionQty?: number;
}

export interface BookTicker { symbol:string; bid:number; ask:number; mid:number; asOf:string; }

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface DriftPolicy {
  driftTolerancePct: number;   // 0.05 = ±5%
  minActionUsd: number;        // 25
  maxTopUpRetries: number;     // 3
  widenOffsetBps: number;      // +4..8 bps
  iocFailoverMs: number;       // 1200..3000
}

export interface GuardInput {
  plan: RiskAllocPlan;                         // hedefler
  exposure: PortfolioExposure;                 // gerçekleşen
  pacing: PacingPlan;                          // child/min ve reduceOnly
  risk: RiskState;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  policy: DriftPolicy;
}

export type ActionKind = "TOP_UP"|"TRIM"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY"|"NOOP";

export interface DriftAction {
  corrId: string;
  legId: string;               // symbol+index
  symbol: string;
  side: Side;                  // hedef yön (topUp=plan.side varsayımı)
  kind: ActionKind;
  deltaNotionalUsd: number;    // tamamlanacak/azaltılacak dolar
  execHint: {
    childType: ChildType;
    limitOffsetBps: number;
    twapMs: number;
    iceberg: number;
    reduceOnly?: boolean;
    postOnly?: boolean;
  };
  reasons: string[];           // “underfill 12%”, “post_only_reject x3”, “percent_price band”
}

export interface DriftPlan {
  asOf: string;
  corrId: string;
  actions: DriftAction[];
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe:

vivo.risk.alloc.plan (VIVO-13)

portfolio.exposure (aggregator)

router.exec.report (VIVO-02 yürütme raporları)

vivo.pacing.plan (VIVO-12)

risk.state, ex.rules, ex.tickers

Publish:

vivo.driftguard.plan (DriftPlan)

vivo.driftguard.action (DriftAction) — VIVO-02’nin çocuk emir üretimi için

audit.log

Mantık (özet)

Plan bacakları için mevcut maruziyeti oku → delta = targetNotionalUsd - realizedUsd.

|delta| < max(minActionUsd, target×driftTolerancePct) ⇒ NOOP.

delta>0 ⇒ TOP_UP; delta<0 ⇒ TRIM.

Hata bağlamı (exec reports):

POST_ONLY_REJECT ×3 ⇒ CANCEL_REPLACE (LIMIT + offset↑)

PERCENT_PRICE ⇒ CANCEL_REPLACE (limit price yeniden bant içine)

EXPIRED/IOC 2× ⇒ SWITCH_CHILD (LIMIT→IOC veya →MARKET, risk izin verirse)

WS lag↑ (pacing’dan türev/liq metrikleriyle) ⇒ WAIT_RETRY (kısa gecikme)

Sentinel ≠ NORMAL ⇒ yalnız TRIM / CANCEL_REPLACE reduce-only; TOP_UP yok.

Rate limit/pacing ⇒ max actions per minute sınırı.

Kod iskeleti
// vivo/driftGuard.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  GuardInput, DriftPlan, DriftAction, StdError, ExecReport, RiskAllocPlanLeg
} from "./driftGuard.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=2)=> Number(x.toFixed(n));

interface LegState {
  retries: number;
  postOnlyRejects: number;
  lastChildType?: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
}

export class DriftGuard extends EventEmitter {
  ver="1.0.0"; src="VIVO-14";
  private legState = new Map<string, LegState>(); // key: corrId|legId

  attach(){
    bus.on<GuardInput>("vivo.drift.input", (x)=> this.safeRun(x));
    bus.on<ExecReport>("router.exec.report", (r)=> this.trackExec(r));
  }

  private key(corrId:string, legId:string){ return `${corrId}|${legId}`; }

  private trackExec(r: ExecReport){
    if (!r?.corrId || !r?.legId) return;
    const k = this.key(r.corrId, r.legId);
    const st = this.legState.get(k) ?? { retries:0, postOnlyRejects:0 };
    st.lastChildType = r.childType;
    if (r.reason==="POST_ONLY_REJECT") st.postOnlyRejects += 1;
    this.legState.set(k, st);
  }

  safeRun(x: GuardInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-14 failed");
    } else {
      const plan = res as DriftPlan;
      bus.emit<DriftPlan>("vivo.driftguard.plan", plan);
      for (const a of plan.actions) bus.emit<DriftAction>("vivo.driftguard.action", a);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ corrId:plan.corrId, actions:plan.actions.length }});
    }
  }

  run(x: GuardInput): DriftPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      const { plan, exposure, pacing, risk, rules, tickers, policy } = x;

      const actions: DriftAction[] = [];
      for (let i=0;i<plan.legs.length;i++){
        const leg = plan.legs[i];
        const legId = `${leg.symbol}#${i}`;
        const realized = Math.abs(exposure.bySymbolUsd[leg.symbol] || 0);
        const target  = Math.abs(leg.estNotionalUsd);
        const delta   = target - realized; // >0 underfill, <0 overfill

        const tol = Math.max(policy.minActionUsd, target * policy.driftTolerancePct);
        if (Math.abs(delta) < tol) continue;

        const rs = rules[leg.symbol]; const tk = tickers[leg.symbol];
        if (!rs || !tk || rs.status!=="TRADING") continue;

        // Sentinel: sadece trim/cancel
        if (risk.sentinel!=="NORMAL" && delta>0) continue;

        const baseHint = this.execHint(pacing, risk);
        const k = this.key(plan.corrId, legId);
        const st = this.legState.get(k) ?? { retries:0, postOnlyRejects:0 };

        // bağlamsal düzeltme türü
        const ctx = this.pickContext(st, rs);
        const kind = this.pickActionKind(delta, ctx, risk);

        const final = this.fitNotional(Math.abs(delta), tk, rs);
        if (final < rs.minNotional) continue;

        const side = delta>0 ? "BUY" : "SELL";
        const reduceOnly = (risk.sentinel!=="NORMAL") || (kind==="TRIM");

        const act: DriftAction = {
          corrId: plan.corrId, legId, symbol: leg.symbol, side,
          kind, deltaNotionalUsd: round(final),
          execHint: { ...baseHint, reduceOnly, postOnly: baseHint.postOnly },
          reasons: this.reasons(delta, tol, ctx, st)
        };

        // failover ayarları
        if (ctx==="POST_ONLY_STUCK"){
          act.execHint.childType = "LIMIT";
          act.execHint.limitOffsetBps += x.policy.widenOffsetBps;
          act.reasons.push("switch POST_ONLY→LIMIT + widen");
        } else if (ctx==="PERCENT_BAND"){
          act.kind = "CANCEL_REPLACE";
          act.reasons.push("percent-price band reprice");
        } else if (ctx==="IOC_MARKET"){
          act.execHint.childType = "IOC";
          act.reasons.push("IOC failover");
        }

        // pacing/rate limit: reduceOnly’da child/min küçük kalsın
        // (sert enforcement VIVO-02’de)
        actions.push(act);

        // retry sayacı
        st.retries += 1;
        this.legState.set(k, st);
        if (st.retries > policy.maxTopUpRetries && act.kind==="TOP_UP"){
          act.kind = "WAIT_RETRY";
          act.reasons.push("retry cap reached");
        }
      }

      return { asOf:new Date().toISOString(), corrId:plan.corrId, actions };

    } catch (e:any){
      return this.err("DRIFT_EVAL_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private pickContext(st: LegState, rs: any): "OK"|"POST_ONLY_STUCK"|"PERCENT_BAND"|"IOC_MARKET" {
    if (st.postOnlyRejects >= 3) return "POST_ONLY_STUCK";
    // Daha gelişmiş band kontrolü: rs.percent ve son fiyatlara göre yapılabilir
    return "OK";
  }

  private pickActionKind(delta:number, ctx: string, risk: GuardInput["risk"]): "TOP_UP"|"TRIM"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY" {
    if (delta>0) {
      if (risk.sentinel!=="NORMAL") return "WAIT_RETRY";
      if (ctx==="POST_ONLY_STUCK" || ctx==="PERCENT_BAND") return "CANCEL_REPLACE";
      return "TOP_UP";
    } else {
      return "TRIM";
    }
  }

  private execHint(pacing: GuardInput["pacing"], risk: GuardInput["risk"]){
    // pacing’e göre çocuk/dk muhafazakâr; risk AMBER/RED’de biraz daha yumuşat
    const postOnly = (risk.posture!=="RISK_ON");
    let limitOffsetBps = 6, twapMs = 1200, iceberg = 0.12;
    if (risk.level==="AMBER"){ twapMs += 300; iceberg += 0.02; }
    if (risk.level==="RED"){ twapMs += 600; iceberg += 0.05; }
    return {
      childType: postOnly ? "POST_ONLY" : "LIMIT",
      limitOffsetBps: clamp(limitOffsetBps,0,15),
      twapMs: clamp(twapMs,800,3000),
      iceberg: clamp(iceberg,0.05,0.3),
      postOnly
    };
  }

  private fitNotional(targetUsd:number, t:GuardInput["tickers"][string], r:GuardInput["rules"][string]){
    // Dolar bazlı minNotional’a ve qty adımına göre aşağı yuvarla (detay qty/price VIVO-02’de)
    const px = t.mid;
    const qtyRaw = targetUsd / px;
    const qty = Math.floor(qtyRaw / r.stepSize) * r.stepSize;
    const notion = qty * px;
    return notion;
  }

  private reasons(delta:number, tol:number, ctx:string, st:LegState){
    const arr = [];
    arr.push(delta>0 ? `underfill ${(Math.abs(delta)/1).toFixed(2)}$` : `overfill ${(Math.abs(delta)/1).toFixed(2)}$`);
    arr.push(`tolerance ${tol.toFixed(2)}$`);
    if (ctx!=="OK") arr.push(`ctx=${ctx}`);
    if (st.postOnlyRejects) arr.push(`postOnlyRejects=${st.postOnlyRejects}`);
    return arr;
  }

  private validate(x: GuardInput): string | null {
    if (!x?.plan || !x?.exposure || !x?.pacing || !x?.risk || !x?.rules || !x?.tickers || !x?.policy)
      return "missing fields";
    if (!x.plan.corrId) return "plan.corrId missing";
    if (x.policy.driftTolerancePct<=0 || x.policy.driftTolerancePct>0.2) return "driftTolerancePct out of range";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test iskeleti (Vitest)
// vivo/__tests__/driftGuard.test.ts
import { describe,it,expect } from "vitest";
import { DriftGuard } from "../driftGuard";
import type { GuardInput } from "../driftGuard.types";

const base: GuardInput = {
  plan:{
    asOf:new Date().toISOString(), sessionId:"EU", corrId:"c-1", reduceOnly:false,
    legs:[ { symbol:"BTCUSDT", cluster:"trend", targetRiskUsd:800, estNotionalUsd: 80_000, reasons:[] } ]
  },
  exposure:{ asOf:new Date().toISOString(), bySymbolUsd:{ BTCUSDT: 70_000 } }, // 10k underfill
  pacing:{ asOf:new Date().toISOString(), sessionId:"EU", maxChildPerMin:80, reduceOnly:false },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" },
  rules:{ BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, status:"TRADING" } },
  tickers:{ BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() } },
  policy:{ driftTolerancePct:0.05, minActionUsd:25, maxTopUpRetries:3, widenOffsetBps:6, iocFailoverMs:1500 }
};

describe("VIVO-14 driftGuard", ()=>{
  it("creates TOP_UP when underfilled beyond tolerance", ()=>{
    const m = new DriftGuard();
    const out:any = m.run(base);
    expect(out.actions[0].kind).toBe("TOP_UP");
    expect(out.actions[0].symbol).toBe("BTCUSDT");
  });

  it("creates TRIM when overfilled", ()=>{
    const m = new DriftGuard();
    const inp:any = structuredClone(base);
    inp.exposure.bySymbolUsd.BTCUSDT = 95_000; // 15k overfill
    const out:any = m.run(inp);
    expect(out.actions[0].kind).toBe("TRIM");
  });

  it("blocks top-up under sentinel", ()=>{
    const m = new DriftGuard();
    const inp:any = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = m.run(inp);
    expect(out.actions.length).toBe(0); // only trim allowed; here delta>0 so no action
  });
});

Entegrasyon akışı

VIVO-13 tahsis → vivo.risk.alloc.plan

Aggregator → portfolio.exposure (perps+spot net/abs proxy)

VIVO-02 yürütme raporları → router.exec.report

VIVO-14 drift analizi → vivo.driftguard.plan & vivo.driftguard.action

VIVO-02 bu eylemleri çocuk emir planına çevirir (LOT_SIZE, percent-price band, TWAP/POST_ONLY/IOC/MKT)

GB-22/36 TCA/mark-out → VIVO-12 pacing ve diğer katmanlar adaptasyon sağlar
_________________________________________________________________________________________________________________
VIVO-15 · operatorPlaybookBridge.ts

Amaç (tek cümle):
Uçtan uca sistemin önerdiği tüm operasyonel aksiyonları tek yerde kartlaştırıp operatörden emin onay almak; onay/ret/partial/timeout kararlarını güvenli ve izlenebilir şekilde VIVO-02’ye iletmek.

Gerçek Dünya Kuralları (latency-safe)

Kapanmamış bar yok; yalnız eylem/plan özetleri, anlık risk/sentinel ve yürütme metrikleri kullanılır.

Sentinel ≠ NORMAL → operatör onayı dahi olsa yeni risk (top-up) bloklanır; yalnız reduce-only / trim / iptal önerileri kartlaşır.

Timeout (örn. 12 sn): Korumacı Default uygulanır → yeni risk içeriyorsa REJECT, reduce-only ise ACCEPT.

Idempotency: her kart cardId ile tekilleştirilir; aynı cardId+decisionSeq ikinci kez işlenmez.

Rate-limit/pacing saygısı: onaylanan aksiyonlar vivo.pacing.plan kotalarına uymak zorunda (kontrol VIVO-02’de tekrar yapılır).

Tam izlenebilirlik: tüm kararlar audit.log’a gider; kart içeriği ve seçilen butonlar kayda alınır.

Arayüzler (TypeScript / JSDoc)
// vivo/operatorPlaybookBridge.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export type Origin =
  | "UPLIFT"        // VIVO-09 uplift assign sonrası yürütme varyantı
  | "SPOT_REBAL"    // VIVO-11 cashSpotAllocator legs
  | "PACING"        // VIVO-12 pacing throttles (bilgilendirme)
  | "RISK_ALLOC"    // VIVO-13 riskBudgetAllocator legs
  | "DRIFT_FIX";    // VIVO-14 driftGuard actions

export type ActionKind = "OPEN"|"INCREASE"|"REDUCE"|"TRIM"|"TOP_UP"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY";

export interface ActionProposal {
  origin: Origin;
  corrId: string;            // sürecin korelasyon id’si
  legId: string;             // alt-bacak id'si (symbol#index)
  symbol: string;
  side: "BUY"|"SELL";
  kind: ActionKind;
  notionalUsd: number;       // etkilenecek notional
  execHint?: {
    childType: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
    limitOffsetBps?: number;
    twapMs?: number;
    iceberg?: number;
    reduceOnly?: boolean;
    postOnly?: boolean;
  };
  reasons?: string[];
}

export type CardSeverity = "INFO"|"WARN"|"CRITICAL";

export interface PlaybookCard {
  cardId: string;                // deterministic: `${origin}|${corrId}|${legId}`
  origin: Origin;
  title: string;                 // kart başlığı
  severity: CardSeverity;
  proposals: ActionProposal[];   // 1..N öneri
  meta: {
    risk: RiskState;
    expiresAt: string;           // timeout için ISO
    createdAt: string;
    sessionId?: "ASIA"|"EU"|"US"|"LOW_LIQ";
    paceHint?: { maxChildPerMin:number };
  };
}

export interface OperatorDecision {
  cardId: string;
  decidedAt: string;
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decisionSeq: number;           // aynı cardId’ye birden fazla partial varsa artar
  choice: "ACCEPT_ALL"|"REJECT_ALL"|"PARTIAL";
  acceptLegs?: Array<{ legId:string }>;  // PARTIAL için
  notes?: string;
}

export interface BridgePolicy {
  timeoutMs: number;              // 8000..20000
  reduceOnlyOnSentinel: boolean;  // true
  maxProposalsPerCard: number;    // 20
  groupBySymbol: boolean;         // kartta grupla
}

export interface ApplyCommand {
  cardId: string;
  seq: number;
  corrId: string;
  legId: string;
  symbol: string;
  side: "BUY"|"SELL";
  kind: ActionKind;
  notionalUsd: number;
  execHint?: ActionProposal["execHint"];
  acceptedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe

vivo.uplift.assign / vivo.rebalance.suggest / vivo.risk.alloc.plan / vivo.driftguard.action

vivo.pacing.plan, risk.state

vivo.operator.input (VIVO-03: operatörün buton seçimleri)

Publish

vivo.operator.card (PlaybookCard) – VIVO-03’te görsel kart

vivo.operator.decision (OperatorDecision) – normalize edilmiş karar

vivo.apply.command (ApplyCommand) – VIVO-02’nin doğrudan uygulayacağı komut akışı

audit.log

Kart Üretim Mantığı (özet)

Kaynak → Kart: gelen önerileri symbol bazlı grupla (opsiyonel), cardId = \${origin}|${corrId}|${legId}`veya grup kart içinlegId="*"` kullan.

Sentinel filtresi: reduceOnlyOnSentinel true ve sentinel≠NORMAL ise TOP_UP/OPEN/INCREASE içeren önerileri kart dışı bırak veya bilgilendirme kartına çevir.

Zehirli kombinasyon (aynı symbol için aynı anda TOP_UP ve TRIM) → WARN şiddeti ve operatör uyarısı.

Timeout: expiresAt = now + timeoutMs. Operatör kararı gelmezse DEFAULT:

yeni risk içeriyorsa → REJECT_ALL

yalnız reduce-only ise → ACCEPT_ALL.

Idempotency: aynı cardId ikinci kez üretilmez (versiyonlamak gerekirse cardId#v2).

Kota notu: paceHint.maxChildPerMin VIVO-02’ye yol gösterir (sert enforce orada).

Kod İskeleti (TypeScript)
// vivo/operatorPlaybookBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  PlaybookCard, BridgePolicy, OperatorDecision, ActionProposal, ApplyCommand,
  RiskState, StdError
} from "./operatorPlaybookBridge.types";

const nowISO = ()=> new Date().toISOString();
const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class OperatorPlaybookBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-15";
  private policy: Required<BridgePolicy>;
  private risk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  private pending = new Map<string, PlaybookCard>();   // cardId -> card
  private decided = new Set<string>();                 // cardId#seq

  constructor(p?: Partial<BridgePolicy>){
    super();
    this.policy = {
      timeoutMs: 12000,
      reduceOnlyOnSentinel: true,
      maxProposalsPerCard: 20,
      groupBySymbol: true,
      ...p
    };
  }

  attach(){
    // kaynak akışlar
    bus.on<ActionProposal>("vivo.driftguard.action", (a)=> this.ingest([a], "DRIFT_FIX"));
    bus.on<any>("vivo.rebalance.suggest", (plan)=> {
      const arr: ActionProposal[] = (plan?.legs||[]).map((l:any, i:number)=>({
        origin:"SPOT_REBAL", corrId: plan.asOf, legId:`${l.symbol}#${i}`,
        symbol:l.symbol, side:l.side, kind: l.side==="BUY"?"INCREASE":"TRIM",
        notionalUsd:l.notionalUsd, execHint:l.execHint, reasons:l.reasons
      }));
      this.ingest(arr, "SPOT_REBAL");
    });
    bus.on<any>("vivo.risk.alloc.plan", (plan)=> {
      const arr: ActionProposal[] = (plan?.legs||[]).map((l:any, i:number)=>({
        origin:"RISK_ALLOC", corrId: plan.corrId, legId:`${l.symbol}#${i}`,
        symbol:l.symbol, side: l.targetRiskUsd>=0?"BUY":"SELL",
        kind: l.targetRiskUsd>=0?"OPEN":"REDUCE",
        notionalUsd: Math.abs(l.estNotionalUsd),
        execHint:{ childType:"LIMIT", limitOffsetBps:6, twapMs:1400, iceberg:0.12 },
        reasons:l.reasons
      }));
      this.ingest(arr, "RISK_ALLOC");
    });
    // risk/pacing
    bus.on<RiskState>("risk.state", r=> this.risk = r);
    // operatör girişi
    bus.on<OperatorDecision>("vivo.operator.input", d=> this.onDecision(d));
  }

  /** Önerileri kartlaştırır ve yayınlar */
  ingest(proposals: ActionProposal[], origin?: string){
    try{
      if (!proposals?.length) return;
      // sentinel filtresi
      const filtered = this.filterBySentinel(proposals);

      // grupla
      const groups = this.policy.groupBySymbol
        ? this.groupBy(filtered, p=> `${p.origin}|${p.corrId}|${p.symbol}`)
        : this.groupBy(filtered, p=> `${p.origin}|${p.corrId}|${p.legId}`);

      for (const [key, arr] of groups.entries()){
        if (!arr.length) continue;
        const cardId = this.policy.groupBySymbol ? `${arr[0].origin}|${arr[0].corrId}|${arr[0].symbol}` : `${arr[0].origin}|${arr[0].corrId}|${arr[0].legId}`;
        if (this.pending.has(cardId)) continue; // idempotent

        const severity = this.pickSeverity(arr);
        const card: PlaybookCard = {
          cardId,
          origin: arr[0].origin,
          title: this.makeTitle(arr),
          severity,
          proposals: arr.slice(0, this.policy.maxProposalsPerCard),
          meta:{
            risk: this.risk,
            createdAt: nowISO(),
            expiresAt: new Date(Date.now()+this.policy.timeoutMs).toISOString()
          }
        };
        this.pending.set(cardId, card);
        bus.emit<PlaybookCard>("vivo.operator.card", card);
        bus.emit("audit.log", { asOf: card.meta.createdAt, ver:this.ver, src:this.src, payload:{ msg:"card", cardId, n:card.proposals.length, severity }});

        // timeout planla
        setTimeout(()=> this.onTimeout(cardId), this.policy.timeoutMs);
      }
    } catch(e:any){
      logger.error({e}, "VIVO-15 ingest failed");
    }
  }

  private filterBySentinel(arr: ActionProposal[]){
    if (!this.policy.reduceOnlyOnSentinel) return arr;
    if (this.risk.sentinel==="NORMAL") return arr;
    // sentinel aktif → yeni risk içerenler (OPEN/INCREASE/TOP_UP) düşer
    return arr.filter(p=> !["OPEN","INCREASE","TOP_UP"].includes(p.kind));
  }

  private groupBy<T>(arr:T[], key:(t:T)=>string){
    const m = new Map<string,T[]>();
    for (const x of arr){ const k = key(x); (m.get(k) || m.set(k,[]).get(k)!).push(x); }
    return m;
  }

  private pickSeverity(arr: ActionProposal[]): "INFO"|"WARN"|"CRITICAL"{
    const hasReduce = arr.some(a=> ["TRIM","REDUCE"].includes(a.kind));
    const hasOpen   = arr.some(a=> ["OPEN","INCREASE","TOP_UP"].includes(a.kind));
    if (this.risk.sentinel!=="NORMAL") return "CRITICAL";
    if (hasReduce && hasOpen) return "WARN";
    return "INFO";
  }

  private makeTitle(arr: ActionProposal[]){
    const s = arr[0].symbol ?? arr[0].origin;
    const kinds = Array.from(new Set(arr.map(a=>a.kind))).join(",");
    return `${s} · ${kinds}`;
  }

  /** Operatör kararı (VIVO-03) */
  onDecision(d: OperatorDecision){
    try{
      const card = this.pending.get(d.cardId); if (!card) return;
      const sig = `${d.cardId}#${d.decisionSeq}`;
      if (this.decided.has(sig)) return; // idempotent

      const accepted = new Set( (d.choice==="PARTIAL" ? (d.acceptLegs||[]).map(x=>x.legId) : card.proposals.map(p=>p.legId)) );
      const cmds: ApplyCommand[] = [];

      if (d.choice==="REJECT_ALL"){
        // hiçbir şey yayma, sadece audit
      } else {
        for (const p of card.proposals){
          if (d.choice==="PARTIAL" && !accepted.has(p.legId)) continue;
          cmds.push({
            cardId: card.cardId, seq: d.decisionSeq,
            corrId: p.corrId, legId: p.legId, symbol: p.symbol,
            side: p.side, kind: p.kind, notionalUsd: p.notionalUsd,
            execHint: p.execHint, acceptedBy: d.decidedBy
          });
        }
      }

      // publish
      if (cmds.length){
        for (const c of cmds) bus.emit<ApplyCommand>("vivo.apply.command", c);
      }
      bus.emit<OperatorDecision>("vivo.operator.decision", d);
      bus.emit("audit.log", { asOf: nowISO(), ver:this.ver, src:this.src,
        payload:{ msg:"decision", cardId:d.cardId, choice:d.choice, seq:d.decisionSeq, cmds:cmds.length }});

      // kartı kapat
      this.pending.delete(d.cardId);
      this.decided.add(sig);

    } catch(e:any){
      logger.error({e}, "VIVO-15 decision failed");
    }
  }

  /** Timeout → korumacı default */
  private onTimeout(cardId:string){
    const card = this.pending.get(cardId); if (!card) return;
    // yeni risk içeriyorsa REJECT, yalnız reduce-only içeriyorsa ACCEPT
    const hasNewRisk = card.proposals.some(p=> ["OPEN","INCREASE","TOP_UP"].includes(p.kind));
    const d: OperatorDecision = {
      cardId, decidedAt: nowISO(), decidedBy:"TIMEOUT_DEFAULT", decisionSeq: 0,
      choice: hasNewRisk ? "REJECT_ALL" : "ACCEPT_ALL",
      notes: "auto-timeout default"
    };
    this.onDecision(d);
  }
}

Test İskeleti (Vitest)
// vivo/__tests__/operatorPlaybookBridge.test.ts
import { describe,it,expect,vi } from "vitest";
import { OperatorPlaybookBridge } from "../operatorPlaybookBridge";
import type { ActionProposal, OperatorDecision } from "../operatorPlaybookBridge.types";

const mk = (p:Partial<ActionProposal>): ActionProposal => ({
  origin:"DRIFT_FIX", corrId:"c1", legId:"BTC#0", symbol:"BTCUSDT",
  side:"BUY", kind:"TOP_UP", notionalUsd:5000, execHint:{ childType:"LIMIT" },
  ...p
});

describe("VIVO-15 operatorPlaybookBridge", ()=>{
  it("emits a card and applies ACCEPT_ALL", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 5000 });
    const cards:any[] = []; const cmds:any[] = [];
    b.attach?.(); // not strictly needed in this unit
    // mock bus
    const origEmit = (b.constructor as any).prototype.emit;
    b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); if (ev==="vivo.apply.command") cmds.push(payload); return true; };

    b.ingest([mk({ kind:"TRIM", side:"SELL" })]);
    expect(cards.length).toBe(1);
    const d: OperatorDecision = { cardId: cards[0].cardId, decidedAt:new Date().toISOString(), decidedBy:"OPERATOR", decisionSeq:1, choice:"ACCEPT_ALL" };
    b.onDecision(d);
    expect(cmds.length).toBeGreaterThan(0);
  });

  it("defaults to REJECT when card has new risk and timeout occurs", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 10 });
    const cards:any[] = []; const cmds:any[] = [];
    b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); if (ev==="vivo.apply.command") cmds.push(payload); return true; };
    b.ingest([mk({ kind:"OPEN", side:"BUY" })]);
    expect(cards.length).toBe(1);
    // wait ~20ms and check that no cmds published (REJECT_ALL)
    return new Promise<void>(res=> setTimeout(()=>{ expect(cmds.length).toBe(0); res(); }, 25));
  });

  it("filters new risk when sentinel active", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 50 });
    b["risk"] = { level:"RED", sentinel:"HALT_PARTIAL", posture:"RISK_OFF" };
    const cards:any[] = []; b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); return true; };
    b.ingest([mk({ kind:"TOP_UP" }), mk({ kind:"TRIM", side:"SELL" })]);
    expect(cards[0].proposals.every((p:any)=> p.kind!=="TOP_UP")).toBe(true);
  });
});

Entegrasyon Akışı

Kaynak modüller (VIVO-09/11/13/14) ve pacing/risk; önerileri ActionProposal olarak yayınlar.

VIVO-15 bu önerileri PlaybookCard’a çevirir → vivo.operator.card.

VIVO-03 operatorDialog kartı Telegram/CLI’de butonlarla gösterir (ACCEPT/REJECT/PARTIAL).

Operatör seçimi → vivo.operator.input → VIVO-15 vivo.apply.command üretir.

VIVO-02 komutları gerçek emirlere çevirir (LOT_SIZE, percent-price, TWAP/IOC/POST_ONLY, rate-limit, drift guard ile uyum).

Audit: tüm kart/karar/komut akışı audit.log’da tutulur; idempotency korunur.
_________________________________________________________________________________________________________________

VIVO-16 · signalDecisionRouter.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama promptu)
Amaç

Aynı enstrüman ve yönde birden çok sinyal geldiğinde tek karar üretmek.

VIVO’nun rol sözleşmesine uygun şekilde confirmationThreshold, signalVariant, biasWeightedTune değerlerini nihai karara bağlamak.

Tekilleştirme, çakışma çözümü, cooldown, pencere yönetimi, tekrar giriş (re-entry) kuralları ve duplicated/contradicting sinyaller için politika uygulamak.

Çıktıyı Event Bus üzerinden execution.intent.proposed kanalına göndermek; reddedilenleri execution.intent.rejected ile raporlamak.

Girdiler (JSON Şeması)
{
  "timestamp": "iso8601",
  "symbol": "string", 
  "side": "long|short",
  "timeframe": "string",
  "source": "string", 
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number"
  },
  "vivoHints": {
    "confirmationThreshold": "number",
    "signalVariant": "base|aggressive|conservative",
    "biasWeightedTune": {
      "trend": "number",
      "orderflow": "number",
      "formation": "number"
    }
  },
  "liviaGate": {
    "safetyGate": "pass|hold",
    "riskLimitAdvice": "tight|normal|relaxed",
    "cooldownActive": "boolean"
  },
  "otobilinc": {
    "psychologyStability": "0..1",
    "fatigueScore": "0..1",
    "biasFlags": ["string"]
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number"
  }
}

Çıktılar (JSON Şeması)
{
  "decision": "approve|reject|defer",
  "reasonCodes": ["string"],
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "routing": {
    "busTopic": "execution.intent.proposed|execution.intent.rejected|execution.intent.deferred",
    "correlationId": "string"
  },
  "constraints": {
    "cooldownMs": "number",
    "maxConcurrentPositions": "number",
    "riskProfile": "tight|normal|relaxed"
  },
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "audit": {
    "symbol": "string",
    "side": "long|short",
    "receivedAt": "iso8601",
    "processedAt": "iso8601",
    "upstream": {"source": "string", "signalId":"string"}
  }
}

TypeScript Arayüzleri (AI’den üretmesini iste)

SignalEnvelope, LiviaGate, OtobilincHints, VivoHints, RouterDecision, ReasonCode.

Tüm giriş/çıkışlara runtime Zod validasyonu ekle; hatalı veri reject(reason: "invalid_payload").

Event Bus Konuları

In: signal.envelope (Grafik Beyni), livia.gate, psy.state (Otobilinç).

Out: execution.intent.proposed, execution.intent.rejected, execution.intent.deferred.

Telemetry: vivo.router.metrics (p99_latency, approve_rate, reject_rate, dup_drop_rate).

Konfig & Varsayılanlar
{
  decisionWindowMs: 1500,     // aynı sembol-yön için pencere
  duplicateKey: ["symbol","side","timeframe"], 
  minConfidence: 0.62,
  defaultVariant: "base",
  cooldownMs: {
    approve: 30000,
    reject: 10000,
    defer: 15000
  },
  conflictPolicy: "higherConfidenceWins|latestWins",
  maxConcurrentPerSymbol: 1
}

Ön-İşleme

Pencere anahtarı: symbol+side+timeframe. Bu pencerede gelen sinyalleri kuyruğa al.

Tekilleştirme: aynı signalId → drop (reason: "duplicate_id").

Zaman doğrulama: timestamp drift > 2s ise reason: "clock_skew", not et ama tamamen atma; confidence-0.05 uygula.

LIVIA gate = hold → defer (cooldown=cfg.cooldownMs.defer).

Otobilinç fatigueScore>0.7 → confidence-0.08; psychologyStability<0.4 → variant conservative.

Skorlama & Karar Ağacı

BaseScore = 0.4*trendStrength + 0.3*rrScore + 0.3*orderflowBias.

VolAdj: volatility aşırı yüksekse (z>1.5) → +0.03; çok düşükse → −0.03.

BiasWeightedTune uygula:
Adj = w_trend*trendStrength + w_of*orderflowBias + w_form*(formationPresence?0.05:0), toplam skora +Adj*0.1.

Variant seçimi:

rrScore≥0.65 & trendStrength≥0.6 & psychologyStability≥0.5 → aggressive

psychologyStability<0.4 or livia.riskLimitAdvice=="tight" → conservative

aksi → base

Onay:

livia.safetyGate=="pass" ve finalScore≥minConfidence → approve

livia.safetyGate=="hold" → defer

aksi → reject

Çakışma çözümü: aynı pencere içinde birden fazla approve adayı → conflictPolicy uygula (varsayılan: daha yüksek finalScore kazanır; eşitse latestWins).

Kurallar (Gerçek Dünya)

Bar kapanışı kuralı: kapanmamış mumdan gelen sinyallerde reason:"open_bar" etiketi; confidence-0.04.

Günlük işlem sınırı kontrolü üst katmanda; ancak burada maxConcurrentPerSymbol enforced → aksi reject("limit_hit").

Seri kayıp sonrası LIVIA cooldownActive==true → defer + cooldown uzat (cfg.defer*1.5).

Latency-safe: latencyMs>1000 → reason:"stale_signal" confidence-0.03.

Çıktı Yönlendirme

approve → execution.intent.proposed (ek alanlar: selectedVariant, riskProfile, tpSlStyle).

reject → execution.intent.rejected (nedenlerle).

defer → execution.intent.deferred (ne zaman tekrar değerlendirileceği cooldownMs ile).

Kodlama Yönlendirmesi (AI’ye talimat)

Dosya yapısı: src/vivo/signalDecisionRouter.ts + __tests__/signalDecisionRouter.test.ts.

Validasyon: Zod şemaları, parseOrThrow. Hata → structured ReasonCode.

Durum: pencere başına InMemoryWindowStore (Map). TTL = decisionWindowMs.

Algoritma: Fonksiyonel, saf core + event adapter. Yan etkiler only bus publish.

Konfig: config/vivo.router.json yükle, env override destekle.

Log/Telemetry: p99 hesapla; metrikleri bus’a per 10s publish.

Tip Güvenliği: interface’ler + Readonly alanlar; as const ile sabitle.

Hata Yönetimi: unknown alanlar warn + drop değil; confidence penalize et.

Test İskeleti: Jest ile

duplicate drop,

conflict resolution,

livia hold → defer,

psychology low → conservative,

final approve path publishes to execution.intent.proposed.

Runtime Guard: maxConcurrentPerSymbol ihlalinde publish etme; sadece rejected.

Örnek Girdi
{
  "timestamp": "2025-09-01T08:10:05Z",
  "symbol": "AVAXUSDT",
  "side": "long",
  "timeframe": "M15",
  "source": "formation.breakout",
  "features": {"trendStrength":0.66,"rrScore":0.7,"volatility":0.9,"orderflowBias":0.55},
  "vivoHints": {
    "confirmationThreshold":0.62,
    "signalVariant":"base",
    "biasWeightedTune":{"trend":0.5,"orderflow":0.3,"formation":0.2}
  },
  "liviaGate":{"safetyGate":"pass","riskLimitAdvice":"normal","cooldownActive":false},
  "otobilinc":{"psychologyStability":0.58,"fatigueScore":0.32,"biasFlags":[]},
  "meta":{"signalId":"sig-234","formationTag":"ascendingTriangle","latencyMs":420}
}

Beklenen Çıktı (özet)
{
  "decision":"approve",
  "reasonCodes":["score_ok","livia_pass"],
  "selectedVariant":"aggressive",
  "confidence":0.71,
  "routing":{"busTopic":"execution.intent.proposed","correlationId":"AVAXUSDT-long-M15-169356"},
  "constraints":{"cooldownMs":30000,"maxConcurrentPositions":1,"riskProfile":"normal"},
  "tuning":{"entryNudge":3,"tpSlStyle":"ATR","positionScaling":"laddered"},
  "audit":{"symbol":"AVAXUSDT","side":"long","receivedAt":"...","processedAt":"...","upstream":{"source":"formation.breakout","signalId":"sig-234"}}
}

Notlar (Entegrasyon)

VIVO → Sinyal Yönetim Merkezi ile aynı sözleşme: tüm modüller bu RouterDecision çıktısını tüketebilir.

Çakışma ve pencere mantığı, ileri aşamada Sinyal Yönetim Merkezine taşınırsa, bu modül “policy client” olarak çalacak şekilde soyutla.
_________________________________________________________________________________________________________________
VIVO-17 · executionFeedbackLooper.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama promptu)
Amaç

Gerçekleşen işlemler, PnL ve slippage verisine bakarak VIVO’nun confirmationThreshold, biasWeightedTune ve variant (base/aggressive/conservative) tercihlerini dinamik ayarlamak.

Öğrenmeyi sembol × timeframe × variant × formationTag kırılımında yapıp, küresel politika sınırlarına (risk, günlük işlem sayısı, Kelly-light, seans filtresi) asla taşmamak.

Sonuçları Event Bus üstünden politikaya öneri olarak yayınlamak (otorite her zaman merkezî Policy Engine/LIVIA’dadır).

Girdiler (Event/JSON Şemaları)
// execution.fill — pozisyon açılışı/ekleme
{
  "event": "execution.fill",
  "timestamp": "iso8601",
  "tradeId": "string",
  "orderId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "price": "number",
  "qty": "number",
  "fees": "number",
  "slippageBps": "number",
  "latencyMs": "number",
  "signalMeta": {
    "signalId": "string",
    "formationTag": "string|null",
    "rrPlanned": "number",
    "tpSlStyle": "ATR|range|hybrid"
  }
}

// execution.close — pozisyon kapanışı (TP/SL/manuel)
{
  "event": "execution.close",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "pnl": "number",            // realized PnL (quote cinsinden)
  "rMultiple": "number",      // realize R
  "holdingMins": "number",
  "exitReason": "tp|sl|timeout|manual|rule",
  "fees": "number",
  "slippageBps": "number",
  "drawdownBps": "number"
}

// telemetry.market — yürütme ortamı metrikleri (opsiyonel)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",        // volatilite z
  "liquidityClass": "low|mid|high"
}

// policy.snapshot — üst politika sınırları (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",  // 0.5–1 aralığında
  "dailyMaxTrades": "number",   // 2–3
  "kellyCap": "number",         // 0.25 Kelly
  "maxConcurrentPerSymbol": 1,
  "confirmationBounds": {"min":0.55,"max":0.72}
}

Çıktılar (Politika Önerisi / Güncelleme Olayı)
{
  "event": "vivo.hints.update",
  "timestamp": "iso8601",
  "scope": {
    "symbol": "string",
    "timeframe": "string",
    "variant": "base|aggressive|conservative",
    "formationTag": "string|null"
  },
  "proposed": {
    "confirmationThreshold": "number",
    "biasWeightedTune": { "trend": "number", "orderflow": "number", "formation": "number" },
    "entryNudgeBps": "number",
    "cooldownMsAdjust": "number",
    "allowedVariants": ["base","aggressive","conservative"],
    "positionSizingHint": "single|laddered"
  },
  "reasonCodes": ["string"],
  "audit": {
    "dataWindow": {"trades":"int","days":"int"},
    "kpis": {"hitRate":"number","profitFactor":"number","avgR":"number","slippageBps":"number"},
    "guardsApplied": ["string"]
  }
}

TypeScript Arayüzleri (ürettir)

ExecFill, ExecClose, MarketTelemetry, PolicySnapshot, VivoHintsUpdate

FeedbackKey = {symbol, timeframe, variant, formationTag?}

FeedbackStats = metrikler (EWMA/EMA alanları, sample sayıları, half-life bilgisi)

Zod ile tüm giriş/çıkışlar için runtime validasyon.

Event Bus Konuları

In: execution.fill, execution.close, telemetry.market, policy.snapshot

Out: vivo.hints.update, vivo.feedback.metrics (telemetri)

Keying: symbol.timeframe.variant[.formationTag]

Konfig & Varsayılanlar
{
  // öğrenme pencereleri
  maxTradesWindow: 50,
  maxDaysWindow: 14,

  // EWMA half-life (trade adedi cinsinden)
  hl: { hitRate: 12, pf: 18, avgR: 12, slip: 10 },

  // sınırlar (policy.snapshot ile clamp edilir)
  confirmation: { base: 0.62, lo: 0.55, hi: 0.72, step: 0.01 },
  biasWeightsDefault: { trend: 0.5, orderflow: 0.3, formation: 0.2 },
  biasWeightsClamp: { min: 0.1, max: 0.7 },

  // slippage → giriş ayarı
  slipToNudgeFactor: 0.35,   // slip bps * factor → entryNudgeBps

  // rejimler
  poorPerfThresholds: { pf: 1.0, hitRate: 0.35, avgR: 0.15 },
  goodPerfThresholds: { pf: 1.35, hitRate: 0.5,  avgR: 0.35 },

  // cooldown adaptasyonu
  cooldown: { baseMs: 30000, poorMult: 1.5, goodMult: 0.8 },

  // güvenlik
  minSamplesForChange: 12,
  maxDeltaPerUpdate: { confirmation: 0.02, weight: 0.1, nudgeBps: 4 }
}

Ön-İşleme ve Durum Yönetimi

FeedbackStateStore (in-memory + periyodik kalıcı: data/feedback.json veya sqlite). Anahtar: symbol×timeframe×variant×formationTag.

Her execution.fill/close geldiğinde ilgili anahtarın EWMA metriklerini güncelle:

hitRate (close’da rMultiple>0 → 1, ≤0 → 0)

profitFactor (grossProfit/grossLoss; loss=0 ise sınırlı yükseklik)

avgR (ortalama realize R)

slippageBps (fill/close ortalaması)

Pencere boyutları: son maxTradesWindow ve maxDaysWindow ile sınırla (eski veriye azalır ağırlık).

Algoritma (Öğrenme → Öneri Akışı)

KPI Güncelle: EWMA ile hitRate, pf, avgR, slip üret.

Rejim Tespiti:

pf < poor.pf veya hitRate < poor.hitRate → POOR

pf ≥ good.pf ve hitRate ≥ good.hitRate ve avgR ≥ good.avgR → GOOD

aksi → NEUTRAL

Öneri Kuralları:

POOR:

confirmationThreshold + step (clamp lo..hi ve maxDeltaPerUpdate).

allowedVariants → ["base","conservative"] (aggressive devre dışı).

biasWeightedTune → trend+0.05, formation-0.05 (formation spesifik başarısızlık varsa daha fazla düşür).

cooldownMsAdjust = cooldown.baseMs * poorMult.

GOOD:

confirmationThreshold − step (min: policy.confirmationBounds.min).

allowedVariants → ["base","aggressive","conservative"] (aggressive açılabilir).

biasWeightedTune → orderflow+0.05 (özellikle slip düşükse), formation+0.03 (formationTag performansı iyiyse).

cooldownMsAdjust = cooldown.baseMs * goodMult.

NEUTRAL:

Küçük düzeltmeler: confirmationThreshold → no-op veya ±0.01, biasWeightedTune → yumuşak normalize.

Slippage Tepkisi:

slip son 10 trade ort. > 8 bps → entryNudgeBps = min( ceil(slip * slipToNudgeFactor), maxDeltaPerUpdate.nudgeBps ).

liquidityClass=="low" → allowedVariants’tan aggressive geçici çıkar.

Formation-Spesifik Ayar:

Aynı formationTag için pf<1.0 ve avgR<0.1 → biasWeightedTune.formation −0.07 (clamp min).

Tersi iyi ise +0.05 (clamp max).

Guard Rails:

Yalnızca samples ≥ minSamplesForChange ise öneri yayınla.

Her güncellemede maxDeltaPerUpdate sınırlarını uygula.

policy.snapshot sınırlarıyla clamp: risk/dailyMaxTrades/confirmationBounds.

Seri kayıp (son 5 işlemin ≥3’ü kayıp) → allowedVariants ⊆ ["base","conservative"], cooldown +%25.

Normalize & Publish:

biasWeightedTune toplamı 1.0 olacak şekilde normalize (ve biasWeightsClamp aralıkları).

vivo.hints.update olarak publish et; reasonCodes ve audit doldur.

Gerçek Dünya Kuralları (Proje-genel ile uyumlu)

Bar Kapanışı: Açık bar verisinden türemiş agresif girişler kötü performans verirse confirmationThreshold otomatik olarak +0.01 yukarı it.

Yürütme Muhasebesi: PnL’de komisyon+slipaj+fonlama düşülmüş neti kullan.

Kelly-light & Risk: Öneriler asla riskPerTradePct, Kelly cap, günlük 2–3 işlem sınırını gevşetmez.

Latency-safe: Fill/close latency > 1500ms rejiminde aggressive kapat; entryNudgeBps artır.

Overfit Koruması: Güncellemeler kademeli; her öneri şrinkage ile baseline’a yakınsın (ör. %40 varsayılan karışımla).

Kodlama Yönlendirmesi

Dosya Yapısı:

src/vivo/executionFeedbackLooper.ts

src/vivo/state/feedbackStore.ts (persist)

__tests__/executionFeedbackLooper.test.ts

Mimari:

Saf çekirdek (pure) fonksiyonlar: accumulateStats(), regimeDetect(), proposeUpdate(), applyGuards().

I/O adaptörleri: bus subscribe/publish. Yan etkiler sadece adaptörde.

Validasyon: Zod şemaları; hatalı paketleri warn et, sayılara dönüşemeyen alanları drop et.

Telemetri: vivo.feedback.metrics her 10s: pf, hitRate, avgR, slip, p99_loop_latency.

Konfig: config/vivo.feedback.json + ENV override.

Tip Güvenliği: Tüm sözleşmeler interface + as const.

Persist: JSON/sqilte; uygulama restart’ında kaldığı yerden devam.

Test İskeleti (Jest)

updates only after minSamplesForChange

poor regime → confirmation + step, aggressive off

good regime → confirmation − step, aggressive allowed

high slippage → entryNudgeBps increased

formation underperforms → formation weight down

guards clamp deltas & bounds

normalize weights sum to 1.0

Örnek Olay Akışı (Basitleştirilmiş)

Girdi dizisi (özet):

14 işlem kapanmış: pf=1.42, hitRate=0.54, avgR=0.36, son-10 slip=6.5 bps

symbol=AVAXUSDT, M15, variant=base, formationTag=ascendingTriangle

policy.confirmationBounds = [0.55,0.72], mevcut confirmation=0.62

Beklenen Öneri:

{
  "event": "vivo.hints.update",
  "scope": {"symbol":"AVAXUSDT","timeframe":"M15","variant":"base","formationTag":"ascendingTriangle"},
  "proposed": {
    "confirmationThreshold": 0.61,
    "biasWeightedTune": {"trend":0.47,"orderflow":0.33,"formation":0.20},
    "entryNudgeBps": 3,
    "cooldownMsAdjust": 24000,
    "allowedVariants": ["base","aggressive","conservative"],
    "positionSizingHint": "laddered"
  },
  "reasonCodes": ["good_pf","good_hit","slip_moderate","shrinkage_applied"],
  "audit": {
    "dataWindow":{"trades":14,"days":6},
    "kpis":{"hitRate":0.54,"profitFactor":1.42,"avgR":0.36,"slippageBps":6.5},
    "guardsApplied":["clamp_confirmation_bounds","max_delta_limited"]
  }
}

Entegrasyon Notları

Çıktı, VIVO-16 signalDecisionRouter tarafından okunup selectedVariant, tuning ve constraints kararlarında kullanılacaktır.

LIVIA (risk dampingi) “seri kayıp” saptadığında policy.snapshot üzerinden sıkılaşma gelir; looper yalnızca öneri yayınlar, yetki LIVIA/Policy’dedir.

Sinyal Yönetim Merkezi ileride açıldığında bu modül policy client olarak çalışmaya devam etmeli (adaptör katmanı soyutla).
_________________________________________________________________________________________________________________
VIVO-18 · executionIntentThrottler.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama promptu)
Amaç

execution.intent.proposed (VIVO-16 çıkışı) akışını alıp politika sınırları ve likidite/rezim koşullarına göre kabul / erteleme / reddetme kararı vermek.

Günlük 2–3 işlem sınırı, sembol başına en fazla 1 eşzamanlı pozisyon, re-entry cooldown ve oturum/likidite filtreleri ile patlama (burst) kontrolünü uygulamak.

Kabul edilenleri execution.intent.accepted, ertelenenleri execution.intent.deferred, reddedilenleri execution.intent.rejected olarak yayınlamak; neden kodlarını ve bir sonraki uygun zamanı belirtmek.

Girdiler (Event/JSON Şemaları)
// execution.intent.proposed — VIVO-16'den gelir
{
  "event": "execution.intent.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "constraints": {
    "cooldownMs": "number",
    "maxConcurrentPositions": "number",
    "riskProfile": "tight|normal|relaxed"
  },
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "audit": {
    "upstream": {"source":"string","signalId":"string"}
  }
}

// policy.snapshot — üst sınırlar (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",           // 0.5–1 aralığı
  "dailyMaxTrades": "number",            // 2–3
  "kellyCap": "number",                  // 0.25 Kelly
  "maxConcurrentPerSymbol": 1,
  "globalMaxConcurrent": 3,
  "reentryMinMins": 45,                  // aynı sembol-yön için minimum yeniden giriş süresi
  "quietHours": {"start":"HH:mm","end":"HH:mm","tz":"Europe/Istanbul"},
  "throttle": {
    "burst": {"capacity": 2, "refillPerMin": 1},  // token bucket
    "perSymbolPerHour": 2
  }
}

// account.exposure — maruziyet ve açık pozisyonlar
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {"symbol":"string","side":"long|short","qty":"number","riskPct":"number","openedAt":"iso8601"}
  ],
  "totalRiskPctOpen": "number"
}

// telemetry.market — likidite/volatilite rejimi
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",
  "liquidityClass": "low|mid|high",
  "session": "asia|eu|us|mixed"
}

// livia.guard — acil durum/seri kayıp freni
{
  "event": "livia.guard",
  "cooldownActive": "boolean",
  "seriesLoss": {"lastN": 5, "lossCount": 3},
  "emergency": "none|slowdown|halt"      // halt→tüm yeni niyetler blok
}

Çıktılar (Karar Olayları)
// Kabul
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "reasonCodes": ["string"],
  "appliedGuards": ["string"],           // hangi throttle kuralları kontrol edildi
  "correlationId": "string"
}

// Erteleme
{
  "event": "execution.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "deferUntil": "iso8601",
  "reasonCodes": ["string"],
  "correlationId": "string"
}

// Red
{
  "event": "execution.intent.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["string"],
  "correlationId": "string"
}

TypeScript Arayüzleri (ürettir)

IntentProposed, IntentAccepted, IntentDeferred, IntentRejected

PolicySnapshot, AccountExposure, MarketTelemetry, LiviaGuard

Yardımcı tipler: ThrottleState, TokenBucket, CooldownRegistry, OpenPositionKey (symbol+side)

Zod ile tüm giriş/çıkışlara runtime validasyon ekle.

Event Bus Konuları

In: execution.intent.proposed, policy.snapshot, account.exposure, telemetry.market, livia.guard

Out: execution.intent.accepted, execution.intent.deferred, execution.intent.rejected, vivo.throttle.metrics

Konfig & Varsayılanlar
{
  // temel limitler
  dailyMaxTradesDefault: 3,                 // policy ile override
  globalMaxConcurrentDefault: 3,
  perSymbolConcurrent: 1,
  perSymbolPerHour: 2,

  // re-entry ve cooldown
  reentryMinMinsDefault: 45,
  sameDirectionMinMins: 60,                 // aynı sembol-yön
  oppositeDirectionMinMins: 20,

  // token bucket (burst kontrol)
  bucket: { capacity: 2, refillPerMin: 1 },

  // seans/likidite filtreleri
  quietHours: { start: "02:30", end: "05:00", tz: "Europe/Istanbul" }, // crypto 24/7, ama düşük likidite
  lowLiquidityAggressiveBlock: true,

  // eşikler
  maxTotalRiskPctOpen: 2.0,                 // toplam açık risk %
  maxVolZForAggressive: 1.8,

  // telemetri
  metricsFlushSec: 10
}

Durum Yönetimi

ThrottleStateStore (in-memory + periyodik kalıcı; data/throttle.json):

todayTradeCount (tarih bazlı reset),

openPositionKeys (Set: symbol+side),

perSymbolHourlyCounter (Map: symbol → {hourBucket: ISO, count}),

reentryCooldown (Map: symbol+side → isoNextAllowed),

tokenBucket (global; capacity/refill),

lastDecisionForKey (audit için),

quietWindow hesaplayıcı.

Algoritma (Karar Akışı)

Ön Kontroller

Eğer livia.guard.emergency=="halt" → reject("emergency_halt").

cooldownActive==true (LIVIA seri kayıp) → defer (min 30–45 dk) reason:"series_loss_cooldown".

Global Kapasite & Günlük Limit

todayTradeCount ≥ dailyMaxTrades → reject("daily_limit_hit").

openPositions.length ≥ globalMaxConcurrent → defer("global_concurrency_full", +15m).

Sembol Bazlı Eşzamanlılık & Re-entry

openPositionKeys aynı symbol+side açık → reject("per_symbol_concurrency").

reentryCooldown[symbol+side] > now → defer("reentry_cooldown", until=cooldownTime).

Likidite/Seans & Variant Kısıtları

quietHours içi ve selectedVariant=="aggressive" → defer("+20m","quiet_hours").

MarketTelemetry.liquidityClass=="low" ve lowLiquidityAggressiveBlock →

selectedVariant=="aggressive" ise reject("low_liquidity_aggressive_block").

volZScore > maxVolZForAggressive → aggressive → reject("excess_vol_for_aggressive") (base/conservative için devam).

Burst & Saatlik Oran

Token bucket: token yoksa → defer("burst_limit", +5m).

perSymbolPerHour aşıldıysa → defer("per_symbol_hourly_limit", nextHourStart).

Risk Maruziyeti

AccountExposure.totalRiskPctOpen + proposedRiskPct > maxTotalRiskPctOpen → defer("risk_cap_reached", +10m).

proposedRiskPct = riskPerTradePct (policy’den) veya variant/riskProfile’a göre ayarlanan değer.

Kabul & Yan Etkiler

Yukarıdakilerin hiçbiri tetiklenmediyse:

accept ve yan etki olarak:

todayTradeCount++,

openPositionKeys.add(symbol+side) (pozisyon kapanışında başka modül temizleyecek),

perSymbolHourlyCounter[symbol].count++,

Token tüket.

execution.intent.accepted yayınla; reasonCodes: ["ok_limits","ok_liquidity","ok_risk"].

Pozisyon Kapanışında (bilgi)

Ayrı bir tüketici (trade close event’ini) openPositionKeys ve ilgili sayacı temizlemeli; re-entry için:

kapanıştan sonra reentryCooldown[symbol+side] = now + reentryMinMins.

Gerçek Dünya Kuralları (Proje-genel ile uyumlu)

Günlük 2–3 İşlem: dailyMaxTrades asla yükseltilmez; policy ne diyorsa odur.

Kelly-light & Risk: Toplam açık risk %2 üstüne çıkmaz; riskPerTradePct policy’den alınır.

Latency-safe & Seans: Düşük likidite veya sessiz saatlerde agresif varyantlar kısıtlanır.

Bar Kapanışı Kuralı: VIVO-16’dan gelen açık-bar kaynaklı sinyaller zaten cezalı; throttler ek blok uygularsa reason’a open_bar_penalty eklenebilir.

Adil Paylaşım: Sembol bazlı saatlik limit adaleti sağlar; tek sembol akışı tüm kotayı yemesin.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/executionIntentThrottler.ts

src/vivo/state/throttleStore.ts (persist)

__tests__/executionIntentThrottler.test.ts

Mimari

Çekirdek saf fonksiyon: throttleDecision(intent, state, policy, market, exposure, livia) → Decision.

I/O adaptörü: bus subscribe/publish; state persist ve periyodik reset (gün değiştirdiğinde todayTradeCount=0).

Validasyon

Zod şemaları; eksik MarketTelemetry varsa varsayılan liquidityClass="mid", volZ=0.

Telemetri

vivo.throttle.metrics her 10 sn: {p99_decision_ms, accept_rate, defer_rate, reject_rate, tokens, today_count}.

Konfig

config/vivo.throttle.json + ENV override; saat dilimi Europe/Istanbul.

Test İskeleti (Jest)

halt → reject(emergency_halt)

hit dailyMaxTrades → reject(daily_limit_hit)

per symbol concurrency → reject(per_symbol_concurrency)

reentry cooldown active → defer(...)

quiet hours + aggressive → defer(...)

low liquidity aggressive → reject(...)

burst no tokens → defer(...)

risk cap exceeded → defer(...)

happy path → accepted & counters updated

Örnek Olay (Özet)

Durum

policy.dailyMaxTrades=3, todayTradeCount=2, openPositions=["AVAXUSDT-long"]

account.totalRiskPctOpen=1.5, riskPerTradePct=0.5

Saat: 03:10 (Europe/Istanbul) → quietHours içinde

MarketTelemetry: liquidityClass="low", volZScore=1.2

intent: symbol="LINKUSDT" side="long" selectedVariant="aggressive"

Beklenen Karar

quietHours + lowLiquidity + aggressive → defer (20 dk)

{
  "event":"execution.intent.deferred",
  "symbol":"LINKUSDT",
  "side":"long",
  "deferUntil":"2025-09-01T00:30:00Z",
  "reasonCodes":["quiet_hours","low_liquidity_aggressive_block"],
  "correlationId":"LINKUSDT-long-..."}


Alternatif

Aynı koşullarda selectedVariant="base" olsaydı ve token mevcutsa:

Risk toplamı 2.0%’ı aşmıyorsa accept.

Entegrasyon Notları

VIVO-16 signalDecisionRouter → önerileri buraya yollar; throttler kabul/erteleme/ret verir.

VIVO-17 executionFeedbackLooper → kabul/ret/erteleme oranlarını izleyip confirmationThreshold ve allowedVariants önerilerini ayarlarken throttler metriklerini de göz önüne alabilir (opsiyonel subscribe).

LIVIA’nın acil durumları her zaman üstündür (halt/slowdown).
_________________________________________________________________________________________________________________
VIVO-19 · executionOrderComposer.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama promptu)
Amaç

execution.intent.accepted olayını al ve üretim-gerçekçiliğinde bir emir planına dönüştür:

Emir tipi seçimi (trend kırılımı → stop-market, sweep-revert → limit + TTL→market failover),

Pozisyon büyüklüğü (riskPerTradePct, ATR/range tabanlı SL mesafesine göre),

Ladder (kademeli) giriş & kademeli TP,

TP/SL (ATR|range|hybrid), OCO/Bracket (borsa destekliyorsa) veya emülasyon,

Price/Qty normalizasyonu (tick/lot/minNotional/PERCENT_PRICE),

Slipaj bütçesi ve timeout/escalation kuralları.

Çıktı: order.plan.proposed (yürütme katmanı uygulayacak).

Girdiler (Event/JSON Şemaları)
// VIVO-18'den kabul
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "constraints": {
    "riskProfile": "tight|normal|relaxed"
  },
  "audit": {
    "upstream": {"source":"string","signalId":"string"}
  }
}

// policy.snapshot — risk/limit sınırları
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",      // %0.5–1
  "kellyCap": "number",             // 0.25 Kelly (üst sınır)
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":0.55,"max":0.72}
}

// market.refs — göstergeler ve seviyeler
{
  "event": "market.refs",
  "symbol": "string",
  "lastPrice": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "session": "asia|eu|us|mixed",
  "spreadBps": "number",
  "volZScore": "number"
}

// exchange.info — kural & filtreler
{
  "event": "exchange.info",
  "symbol": "string",
  "filters": {
    "tickSize": "number",
    "stepSize": "number",
    "minNotional": "number",
    "priceLimitRate": "number",     // PERCENT_PRICE(_BY_SIDE)
    "minQty": "number",
    "maxQty": "number"
  },
  "tradeMode": "spot|usdm|coinm"
}

// account.equity — büyüklük hesabı için
{
  "event": "account.equity",
  "equityQuote": "number"           // USDT gibi
}

Çıktı (Emir Planı Olayı)
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [
      {
        "ratio": "0..1",            // toplamı 1.0
        "type": "market|limit|stop_market|stop_limit",
        "price": "number",          // tick'e yuvarlanmış
        "qty": "number",            // step'e yuvarlanmış
        "ttlSec": "number",
        "slippageBudgetBps": "number",
        "failover": "none|market|price_step_escalation"
      }
    ]
  },
  "protection": {
    "stopLoss": {"type":"stop_market|stop_limit","price":"number","offset":"bps"},
    "takeProfit": [
      {"ratio":"0..1","type":"limit","price":"number"}
    ],
    "ocoCapable": "boolean",
    "trailing": {"enabled": "boolean","callbackRateBps":"number"}
  },
  "risk": {
    "riskPerTradePct": "number",
    "plannedRR": "number",
    "notional": "number",
    "maxSlipBps": "number"
  },
  "normChecks": {
    "priceRounded": "boolean",
    "qtyRounded": "boolean",
    "minNotionalOk": "boolean",
    "percentPriceOk": "boolean"
  },
  "audit": {
    "variant": "base|aggressive|conservative",
    "tpSlStyle": "ATR|range|hybrid",
    "basis": {"atr":"number","swingHigh":"number","swingLow":"number"},
    "refs": {"bestBid":"number","bestAsk":"number","mid":"number"},
    "reasonCodes": ["string"],
    "correlationId": "string"
  }
}

TypeScript Arayüzleri (ürettir)

IntentAccepted, OrderPlan, EntryLeg, ProtectionBracket, RiskBlock, NormChecks.

ExchangeFilters, MarketRefs, PolicySnapshot, AccountEquity.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: execution.intent.accepted, market.refs, exchange.info, account.equity, policy.snapshot

Out: order.plan.proposed, order.compose.metrics (p99_plan_ms, plan_rr, ladder_count, oco_used)

(Opsiyonel uyarı): order.plan.rejected (norm ihlali veya veri eksikliği varsa)

Konfig & Varsayılanlar
{
  // TP/SL katsayıları (ATR çoklayıcıları)
  atrK: { conservative: {tp: 2.2, sl: 2.0}, base: {tp: 1.8, sl: 1.5}, aggressive: {tp: 1.5, sl: 1.2} },

  // Range tamponları (bps)
  rangeBufBps: { tp: 8, sl: 12 },

  // Ladder geometrisi
  ladder: {
    legs: { single: 1, laddered: 3 },
    weights: { laddered: [0.4, 0.35, 0.25] },
    spacingBps: { base: 6, aggressive: 10, conservative: 4 } // limit modunda içeri dizilim
  },

  // Emir tipi matrisi (özet)
  orderMatrix: {
    breakout: { long: "stop_market", short: "stop_market" },
    sweepRevert: { long: "limit", short: "limit" },
    default: { long: "limit", short: "limit" }
  },

  // TTL ve failover
  ttlSec: { limit: 12, stop_limit: 15 },
  failover: { onPartialFillUnder: 0.6, mode: "market" },

  // Slipaj bütçesi
  maxSlipBps: { base: 8, aggressive: 12, conservative: 6 },

  // OCO desteği yoksa emülasyon
  ocoEmulation: { enabled: true, pollMs: 300, cancelBeforePlace: true },

  // Normalizasyon
  roundMode: "floor", // fiyat->tick, qty->step
  minNotionalBufferPct: 0.02
}

Ön-İşleme

Sembol whitelisti (kullanıcının listesi) içindeyse devam et; değilse reason:"symbol_not_whitelisted".

Gerekli referansların hepsi var mı? (market.refs, exchange.info, account.equity, policy.snapshot) — yoksa plan.rejected.

tpSlStyle ve selectedVariant’a göre katsayıları ve spacing parametrelerini seç.

Boyutlandırma (Risk → Qty)

SL mesafesi (price units):

ATR: slDist = atr.value * atrK[variant].sl

Range: long ise lastPrice - (swingLow - swingLow*buf_sl_bps), short ise swingHigh*(1+buf_sl_bps) - lastPrice

Hybrid: slDist = max( ATR tabanlı, Range tabanlı )

Risk Notyonu: riskQuote = equityQuote * (riskPerTradePct / 100)

Qty (quote→base): qtyRaw = riskQuote / slDist

Ladder: weights ile her bacağa qty_i = qtyRaw * weight_i

Yuvarlama: price tickSize’a, qty stepSize’a; minQty ve maxQty kontrolü.

Min Notional: her bacak için price_i * qty_i ≥ minNotional*(1+buffer) olmalı; değilse bacağı birleştir veya planı downscale et.

Percent Price: bacak fiyatları PERCENT_PRICE kuralı içinde kalmalı.

Not: riskPerTradePct Kelly cap ile asla yukarı itilmez; LIVIA guard aktifse (seri kayıp) boyutlandırma üst katmanda sıkılır; composer sadece verilen risk yüzdesini uygular.

Giriş Planı (Entry)

Order Type Seçimi:

Trend kırılımı (upstream formationTag veya kaynak ipucu): stop_market.

Sweep-revert / mean reversion: limit + ttlSec + failover.

Aksi durumda default matrisi.

Fiyatlandırma:

market: fiyat yok; sadece slippage budget ve audit’e market=true.

limit:

long: price = min(bestAsk, mid * (1 - entryNudge_bps)) değil; gerçekçilik → likit ortamda fiyatı almak için:

“pasif” istiyorsak price = bestBid’e yakın (- nudge),

TTL sonunda fill<60% ise failover market.

short için simetrik.

stop_market: tetik seviyesi = long’da swingHigh + buffer veya lastPrice*(1+entryNudge_bps).

TTL & Escalation:

TTL doldu, dolum < onPartialFillUnder →

failover.mode=="price_step_escalation" ise fiyatı +/- tick * kademeli artır ve tekrar TTL koy,

Aksi market failover.

Slippage Bütçesi:

Gerçekleşen fill bps > maxSlipBps[variant] → yürütme katmanına kapatma/iptal politikası ilet (composer audit’e yazar).

TP/SL (Koruma)

SL:

tpSlStyle=="ATR" → slPrice = entryRef -/+ atr.value * atrK[variant].sl

range → swingLow/High ± buffer

hybrid → max(ATR, range) mesafesi kadar daha uzak olan SL (daha güvenli)

Yuvarla (tick). Stop_limit gerekiyorsa limit offset bps ekle.

TP:

Planlanan R:R: plannedRR = atrK[variant].tp / atrK[variant].sl (yaklaşık) veya range bazlı hedef.

Laddered TP (örnek): [0.5, 0.3, 0.2] oranla; tp_i = entryPrice ± RR * slDist * scale_i.

OCO/Bracket:

Borsa destekliyse native; değilse emülasyon (SL/TP yerleştirme sırası: önce SL, ardından TP; fill event’lerinde kalan qty’ye göre ayarla).

Normalizasyon & Guard Rails

priceRounded, qtyRounded, minNotionalOk, percentPriceOk true olmak zorunda; aksi order.plan.rejected.

notional (toplam) günlük risk/limitlerle çelişiyorsa planı downscale et (RR değişmeden).

Quiet hours + aggressive + low liquidity durumunda ladder ağırlıklarını önden küçült (weights normalize < 1.0); audit’e liquidity_downscale ekle.

Açık bar kuralı: upstream açık-bar kaynaklı girişse TP/SL daha muhafazakâr (SL +0.1ATR; TP −0.1ATR).

Algoritma (Özet Akış)

Girdileri doğrula (Zod).

SL mesafesini hesapla (ATR|range|hybrid).

Risk→qty→ladder dağıt, tick/step/minNotional/PERCENT_PRICE kontrol et.

Emir tipi ve fiyatlarını belirle; TTL/failover kuralını uygula.

TP/SL’yi hesapla; OCO/Bracket kur.

NormChecks ve guard rails uygula; ihlal varsa plan.rejected.

order.plan.proposed yayınla; telemetriyi güncelle (order.compose.metrics).

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/executionOrderComposer.ts

src/vivo/lib/normalize.ts (tick/step/minNotional/PERCENT_PRICE)

src/vivo/lib/positionSizing.ts (risk→qty→ladder)

__tests__/executionOrderComposer.test.ts

Mimari

Saf çekirdek: composeOrderPlan(intent, refs, filters, equity, policy, cfg)

IO adaptörü: bus subscribe/publish + exchangeInfo/equity cache.

Validasyon

Zod şemaları; sayısal alanlar finite(); negatif/NaN reddedilir.

Telemetri

order.compose.metrics her 10 sn: {p99_plan_ms, accept_rate, reject_rate, ladder_count_avg, rr_avg}

Konfig

config/vivo.composer.json + ENV override (ör. VIVO_COMPOSER_TTL_LIMIT).

Test İskeleti (Jest)

atr style → doğru SL/TP ve RR

range style → swing tabanlı TP/SL

hybrid → max(ATR, range) mesafesi

risk→qty ladder dağılımı & rounding

minNotional ihlali → downscale veya reject

PERCENT_PRICE ihlali → reject

limit TTL <60% fill → market failover

low liquidity + aggressive → weights küçülür

oco yok → emülasyon sırası doğru

Örnek Senaryo (Özet)

Girdi (kısaltılmış)

intent.accepted: symbol="LINKUSDT", side="long", variant="base", tuning={entryNudge:3,tpSlStyle:"hybrid",positionScaling:"laddered"}

policy: riskPerTradePct=0.7

equityQuote=10_000

market.refs: last=12.40, bestBid=12.39, bestAsk=12.41, mid=12.40, atr14=0.28, swingLow=11.95, swingHigh=12.55, spread=8 bps

filters: tick=0.01, step=0.1, minNotional=10, priceLimitRate=5%

Hesap Özeti

hybrid slDist = max(ATR*1.5, last - swingLow + buf) ≈ max(0.42, 0.47) = 0.47

riskQuote = 10_000 * 0.007 = 70

qtyRaw = 70 / 0.47 ≈ 148.93 LINK

Ladder (0.4/0.35/0.25) → 59.57/52.13/37.23 → step’e yuvarla: 59.6/52.1/37.2

Limit giriş (mean-revert kabulü ise): price1≈bestBid (12.39), spacingBps=6 → p2≈12.31, p3≈12.24 (tick’e yuvarla)

SL (hybrid): 12.40 - 0.47 = 11.93 → tick: 11.93

TP (RR~1.2–1.4): ör. 12.40 + 0.56 ≈ 12.96 (%50), 13.10 (%30), 13.25 (%20)

Çıktı (özet)

{
  "event":"order.plan.proposed",
  "symbol":"LINKUSDT",
  "side":"long",
  "entryPlan":{
    "mode":"limit",
    "legs":[
      {"ratio":0.4,"type":"limit","price":12.39,"qty":59.6,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"},
      {"ratio":0.35,"type":"limit","price":12.31,"qty":52.1,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"},
      {"ratio":0.25,"type":"limit","price":12.24,"qty":37.2,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"}
    ]
  },
  "protection":{
    "stopLoss":{"type":"stop_market","price":11.93,"offset":0},
    "takeProfit":[
      {"ratio":0.5,"type":"limit","price":12.96},
      {"ratio":0.3,"type":"limit","price":13.10},
      {"ratio":0.2,"type":"limit","price":13.25}
    ],
    "ocoCapable":false,
    "trailing":{"enabled":false,"callbackRateBps":0}
  },
  "risk":{"riskPerTradePct":0.7,"plannedRR":1.3,"notional":1845.0,"maxSlipBps":8},
  "normChecks":{"priceRounded":true,"qtyRounded":true,"minNotionalOk":true,"percentPriceOk":true},
  "audit":{"variant":"base","tpSlStyle":"hybrid","basis":{"atr":0.28,"swingHigh":12.55,"swingLow":11.95},"refs":{"bestBid":12.39,"bestAsk":12.41,"mid":12.40},"reasonCodes":["ok"],"correlationId":"LINKUSDT-long-..."}
}

Entegrasyon Notları

Bu plan yürütme motoru tarafından emir yerleştirmeye dönüştürülür (bir sonraki modül).

VIVO-17 (feedback looper) planlanan RR, slipaj, partial-fill sonuçlarını geri besleme için dinleyebilir.

VIVO-18’in throttling kararları üstündür; composer boyutlandırmayı yükseltmez, sadece uygular.
_________________________________________________________________________________________________________________
VIVO-20 · orderExecutionManager.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama promptu)
Amaç

order.plan.proposed planını atomik bir yürütme senaryosuna çevirmek:

Giriş bacaklarını sırayla/eşzamanlı yerleştir (market/limit/stop…),

Kısmi dolumlarda dinamik miktar ile SL/TP (reduce-only) kur,

OCO/Bracket kullan (varsa), yoksa emülasyon yap,

TTL dolumu yetersizse cancel→replace veya market failover uygula,

Slipaj bütçesi aşıldığında korumacı davran,

Ağ/limit/kurallar hatalarında idempotent retry/backoff uygula.

Durum makinesiyle tüm yaşam döngüsünü yönet; sonuçları event bus’a yayınla.

Girdiler (Event/JSON Şemaları)
// order.plan.proposed — VIVO-19'dan
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [
      {"ratio":"0..1","type":"market|limit|stop_market|stop_limit","price":"number","qty":"number","ttlSec":"number","slippageBudgetBps":"number","failover":"none|market|price_step_escalation"}
    ]
  },
  "protection": {
    "stopLoss": {"type":"stop_market|stop_limit","price":"number","offset":"bps"},
    "takeProfit": [{"ratio":"0..1","type":"limit","price":"number"}],
    "ocoCapable": "boolean",
    "trailing": {"enabled":"boolean","callbackRateBps":"number"}
  },
  "risk": {"riskPerTradePct":"number","plannedRR":"number","notional":"number","maxSlipBps":"number"},
  "normChecks": {"priceRounded":"boolean","qtyRounded":"boolean","minNotionalOk":"boolean","percentPriceOk":"boolean"},
  "audit": {"variant":"base|aggressive|conservative","tpSlStyle":"ATR|range|hybrid","reasonCodes":["string"],"correlationId":"string"}
}

// exchange.info — kural/özellikler
{
  "event": "exchange.info",
  "symbol": "string",
  "features": {
    "ocoNative": "boolean",
    "reduceOnly": "boolean",     // futures
    "postOnly": "boolean",
    "timeInForce": ["GTC","IOC","FOK"]
  },
  "limits": {
    "tickSize":"number","stepSize":"number","minNotional":"number","minQty":"number","maxQty":"number","priceLimitRate":"number"
  }
}

// market.refs — anlık referanslar
{
  "event": "market.refs",
  "symbol": "string",
  "bestBid":"number","bestAsk":"number","mid":"number","spreadBps":"number","volZScore":"number"
}

// account.exposure — açık pozisyonlar ve risk
{
  "event": "account.exposure",
  "openPositions": [{"symbol":"string","side":"long|short","qty":"number","avgPrice":"number"}],
  "totalRiskPctOpen":"number"
}

// livia.guard — acil durumlar
{
  "event":"livia.guard",
  "emergency":"none|slowdown|halt"
}

Çıktılar (Yürütme Olayları)
// Emir yerleştirme isteği/sonucu (adapter-agnostic)
{
  "event": "order.placement.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol":"string",
  "tradeMode":"spot|usdm|coinm",
  "legs": [{"clientOrderId":"string","type":"market|limit|stop_market|stop_limit","price":"number|null","qty":"number","tif":"GTC|IOC|FOK","reduceOnly":"boolean"}]
}

{
  "event": "order.placement.result",
  "timestamp": "iso8601",
  "correlationId": "string",
  "results": [
    {"clientOrderId":"string","exchangeOrderId":"string","status":"accepted|rejected","reason":"string|null"}
  ]
}

// Canlı güncellemeler
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number"
}

// İptal/replace
{"event":"order.cancel.request","timestamp":"iso8601","correlationId":"string","clientOrderId":"string"}
{"event":"order.cancel.result","timestamp":"iso8601","correlationId":"string","clientOrderId":"string","status":"canceled|not_found|failed","reason":"string|null"}

// Bracket kurulum durumu
{
  "event":"order.bracket.ready",
  "timestamp":"iso8601",
  "correlationId":"string",
  "slOrderId":"string","tpOrderIds":["string"],
  "mode":"native_oco|emulated"
}

// Hatalar / zaman aşımı
{
  "event":"order.execution.error",
  "timestamp":"iso8601",
  "correlationId":"string",
  "stage":"placing_entry|placing_bracket|monitoring|cancel_replace|failover",
  "code":"network|ratelimit|percent_price|min_notional|insufficient_margin|unknown",
  "detail":"string"
}

TypeScript Arayüzleri (ürettir)

OrderPlan, PlacementRequest/Result, OrderUpdate, BracketReady, ExecError.

ExchangeInfo, MarketRefs, Exposure, LiviaGuard.

Yardımcı: ExecutionState, LegState, BracketState, RetryPolicy, BackoffPlan.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: order.plan.proposed, exchange.info, market.refs, account.exposure, livia.guard

Out: order.placement.request, order.placement.result, order.update, order.cancel.*, order.bracket.ready, order.execution.error, order.exec.metrics

Konfig & Varsayılanlar
{
  // Timeouts & TTL
  legPlaceTimeoutMs: 3000,
  entryLegTtlSecDefault: 12,           // plan bacağı TTL override edebilir
  partialFillUnder: 0.6,               // TTL sonunda kısmi dolum <60% ise escalation
  replaceMaxAttempts: 2,
  failoverModeDefault: "market",       // price_step_escalation | market

  // Price step escalation
  escalationTickSteps: [1, 2],         // her replace'te kaç tick öte
  escalationHoldSec: 5,                // yeni fiyatla bekleme

  // Slippage & koruma
  maxSlipBpsHard: 15,                  // variant'tan bağımsız üst sınır
  cancelIfSlipOverHard: true,

  // TIF tercihleri
  tif: { market: "IOC", limit: "GTC", stop_market: "GTC", stop_limit: "GTC" },

  // OCO emülasyon
  ocoEmulation: { enabled: true, placeOrderDelayMs: 250, pollMs: 300, cancelOtherOnFill: true },

  // Idempotency & retry
  clientOrderIdFormat: "{symbol}-{side}-{ts}-{rand4}",
  retry: { max: 3, backoffMs: [250, 500, 1000] },

  // Telemetry
  metricsFlushSec: 10
}

Durum Makinesi (State Machine)

States

INIT → PLACING_ENTRY → WAITING_ENTRY_FILL → (PLACE_PROTECTION → MONITORING) → COMPLETED

Ara durumlar: PARTIAL_ESCALATION, CANCEL_REPLACE, TIMEOUT_FAILOVER, ABORTED

Transitions (özet)

INIT: Plan ve ön koşullar doğrulanır (limits, features, livia.halt?).

PLACING_ENTRY: Tüm giriş bacakları için order.placement.request gönder; result bekle.

WAITING_ENTRY_FILL:

Fill eventleri geldiğinde avgFillPrice ve filledQty güncellenir.

TTL doldu + fillRatio < partialFillUnder → PARTIAL_ESCALATION.

Slipaj ölçülür; hard limit aşılırsa CANCEL_REPLACE veya ABORTED.

PARTIAL_ESCALATION:

Bacak failover=="price_step_escalation" → fiyat ±tick ile replace (max replaceMaxAttempts).

Aksi → TIMEOUT_FAILOVER (market).

PLACE_PROTECTION:

SL/TP kur. exchange.features.ocoNative==true ise native OCO; değilse emülasyon:

futures: reduceOnly SL & TP ayrı emirler, fill geldiğinde diğeri iptal.

MONITORING:

order.update akışı dinlenir; TP veya SL tetiklenirse kalan karşı emir iptal (OCO emülasyonu).

Pozisyon kapanınca COMPLETED.

CANCEL_REPLACE:

Geçerli bacağı iptal et, yeni fiyatla yeniden yerleştir. Başarısızsa TIMEOUT_FAILOVER.

TIMEOUT_FAILOVER:

Market failover uygula (slippage bütçesi içinde).

Başarılıysa PLACE_PROTECTION, değilse ABORTED.

ABORTED:

Tüm bekleyen giriş ve koruma emirlerini iptal et; hata yayınla.

Algoritma (Ayrıntı)
1) Giriş Yerleştirme

TIF: market→IOC, limit→GTC. Post-Only gerekiyorsa postOnly=true (destekleniyorsa).

clientOrderId deterministik ve benzersiz üret (idempotency).

order.placement.result.status=="rejected" ise hata koduna göre:

percent_price → plan hatası; ABORTED ve order.execution.error(code="percent_price").

min_notional → ABORTED (plan düzeyi çözmeliydi).

ratelimit/network → backoff retry (en fazla retry.max).

insufficient_margin → ABORTED.

2) Kısmi Dolum & Ortalama Fiyat

avgFillPrice = weightedAvg(prevQty, prevAvg, newQty, newPrice).

Her fill’de kalan koruma miktarları yeniden hesaplanır (reduce-only).

3) TTL, Escalation ve Failover

TTL bitti, fill < %60:

price_step_escalation: fiyatı ± tick * escalationTickSteps[i] kaydır → replace.

Aksi: market failover (slip bütçesi ≤ maxSlipBpsHard ve plan risk.maxSlipBps).

4) Slipaj Muhasebesi

Her fill’de lastFillSlipBps = abs(fillPrice - (limitPrice||mid)) / mid * 1e4.

lastFillSlipBps > risk.maxSlipBps → uyarı; > maxSlipBpsHard ve cancelIfSlipOverHard==true → CANCEL_REPLACE (veya ABORTED).

5) Bracket Kurulumu

Native OCO:

Spot: OCO ile TP + SL aynı anda; başarı → order.bracket.ready(mode="native_oco").

Emülasyon:

Önce SL yerleştir, ardından TP (reducesOnly/closeOnTrigger).

Fill/trigger update’lerinde diğeri iptal.

Emülasyon döngüsü pollMs ile order status kontrol eder.

6) Trailing Stop (opsiyonel)

trailing.enabled==true → exchange destekliyorsa native; yoksa emülasyon: periyodik fiyat izleme + SL fiyatını yukarı/aşağı ticks ile güncelle (rate-limit koruması).

7) İptal/Replace

Replace sürecinde:

Eski emri order.cancel.request → result bekle → yeni şartlarla placement.

not_found ise, muhtemelen tetiklenmiş/filled; status query ile doğrula (çifte yerleştirme yapma).

8) Telemetri & Audit

order.exec.metrics (10 sn):
{p99_place_ms, p99_first_fill_ms, replace_count, failover_count, avg_slip_bps, oco_emulated_rate, error_rate}

order.update’lar üzerinden filled notional, realized slipaj hesaplanır ve VIVO-17 (feedback) kullanır.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/orderExecutionManager.ts (durum makinesi + orkestrasyon)

src/exchange/adapter.ts (abstract: place, cancel, query, time, features)

src/vivo/lib/slippage.ts, src/vivo/lib/avgFill.ts

__tests__/orderExecutionManager.test.ts

Mimari

Saf çekirdek: advance(state, event) → state (deterministik).

IO adaptörleri: bus subscribe/publish + exchange adapter çağrıları.

Idempotency: her clientOrderId tekil; yeniden başlatmada reconcile akışı.

Validasyon

Zod şemaları; tüm sayısal alanlar finite(). Hatalı paket → order.execution.error(code="invalid_payload").

Zaman Senkronu

exchange.time() ile drift ölç; TTL/timeout hesaplarında kullan.

Hata Haritası

Bilinen exchange kodlarını percent_price|min_notional|rate_limit|insufficient_margin|duplicate_client_id|unknown’a eşle.

Günlük Reset

Gerekli sayaçlar (telemetri) gün sonunda sıfırlanır (Europe/Istanbul).

Test İskeleti (Jest)

market leg → IOC fill → bracket native OCO

limit leg TTL<60% → price step escalation → fill

limit leg TTL<60% → market failover

slippage > hard → cancel_replace/abort

emulated OCO → TP fill → SL auto-cancel

network/ratelimit → backoff retry

percent_price violation → aborted with error

idempotent restart → reconcile open orders, no duplicates

Gerçek Dünya Kuralları (Proje-genel uyumlu)

Latency-safe: Bekleyen açık bar sinyalinde zaten cezalar uygulandı; burada market failover olsa bile slipaj üst sınırlarına sadık kal.

Yürütme muhasebesi: Tüm fill’lerde komisyon+slipaj metriklerini hesapla; VIVO-17’ye yayınla.

Risk & Kelly-light: Boyutlandırma VIVO-19’da sabitlendi; asla artırma. Yalnızca aşağı ölçekleyebilirsin (percent_price/minNotional baskısı vb.).

Rate limit & Flood: Replace/failover’da hız limitlerini aşma; backoff uygula.

Futures: reduce-only zorunlu; hedge mode varsa symbol+side anahtarıyla yönet.

Örnek Olay (Kısaltılmış)

Plan

LINKUSDT long, tradeMode=spot, laddered limit 3 bacak (TTL=12s), maxSlipBps=8, OCO yok (emülasyon).

Akış

PLACING_ENTRY: 3 limit bacağı GTC gönderildi → result: accepted.

WAITING_ENTRY_FILL:

8s’de 1. bacağın %40’ı doldu, avgSlip=5 bps.

12s TTL: toplam fill %50 < %60 → PARTIAL_ESCALATION.

CANCEL_REPLACE: 2. bacak iptal→yeniden yerleştir (+1 tick), 3. bacak +2 tick.

5s sonra fill %85 → PLACE_PROTECTION.

PLACE_PROTECTION:

Emülasyon: önce SL, sonra TP emirleri (reduce-only/closeOnTrigger).

order.bracket.ready(mode="emulated") yayınlandı.

MONITORING:

TP1 doldu → kalan qty’ye göre SL/TP yeniden ayarlandı.

Sonra SL tetiklendi → TP otomatik iptal → COMPLETED.

Telemetri: replace_count=1, failover_count=0, avg_slip_bps=6.1.

Entegrasyon Notları

VIVO-18 Throttler kabul verdikten sonra bu modül devreye girer; abort olursa sebep execution.error ile geri yayınlanır ve VIVO-17 feedback tarafından öğrenmeye alınır.

VIVO-19 Composer ile sözleşme: fiyat/qty/limit kontrolleri planda geçmiştir; Execution Manager yalnızca uygular, kural ihlali gelirse raporlar.

Signal Yönetim Merkezi ileride gelirse, correlationId ile tüm zincir uçtan uca izlenebilir.
_________________________________________________________________________________________________________________
VIVO-21 · livePositionSupervisor.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)

Bu promptu diğer yapay zekâya ver; modülü Node.js + TypeScript ile yazsın. Kod istemiyoruz; ama nasıl kodlaması gerektiğini net yönlendiriyoruz. Tüm giriş/çıkış JSON ve event-driven.

Amaç

Açık pozisyonları canlı izleyip şu kararları otomatik yönetmek:

Trailing stop (ATR/chandelier veya callback-bps) kur/ilerlet.

Kısmi TP sonrası yeniden dengeleme (kalan miktara göre SL/TP güncelle).

Stagnation/timeout durumunda korumacı kapatma (time-based exit).

Bağlantı kesintisi ve veri tazeliği düşüşünde güvenli moda geçiş.

Abnormal spread/volatilite rejiminde SL sıkılaştırma, agresif varyantların geçici bloklanması.

Tüm operasyonları reduce-only mantığıyla, slipaj/limit kurallarına saygı ile yürütmek.

Girdiler (Event / JSON Şemaları)
// order.bracket.ready — VIVO-20 kurulum tamam
{
  "event": "order.bracket.ready",
  "timestamp": "iso8601",
  "correlationId": "string",
  "mode": "native_oco|emulated",
  "slOrderId": "string",
  "tpOrderIds": ["string"]
}

// order.update — borsa akışı
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number"
}

// position.snapshot — periyodik pozisyon özeti
{
  "event": "position.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeId": "string",
  "qtyOpen": "number",
  "avgPrice": "number",
  "unrealizedPnlQuote": "number",
  "entryTime": "iso8601"
}

// market.refs — anlık fiyat/ATR/swing referansları
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "lastPrice": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// telemetry.market — likidite rejimi (opsiyonel farklı kaynak)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "liquidityClass": "low|mid|high",
  "session": "asia|eu|us|mixed"
}

// connectivity.heartbeat — veri/bağ tazeliği
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean"
}

// policy.snapshot — üst sınırlar (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"},
  "maxHoldMins": 240,
  "drawdownFromPeakR": {"aggressive":0.25,"base":0.35,"conservative":0.45}
}

// vivo.hints.update — (VIVO-17 önerileri; trailing modu vs.)
{
  "event": "vivo.hints.update",
  "timestamp": "iso8601",
  "scope": {"symbol":"string","timeframe":"string","variant":"base|aggressive|conservative"},
  "proposed": {
    "entryNudgeBps": "number",
    "cooldownMsAdjust": "number",
    "positionSizingHint": "single|laddered",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  }
}

Çıktılar (Supervisor Karar Olayları)
// SL/TP/trailing güncellemesi (reduce-only düzenlemeleri)
{
  "event": "order.modify.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "actions": [
    {
      "type": "move_sl|move_tp|enable_trailing|disable_trailing",
      "orderId": "string|null",
      "newPrice": "number|null",
      "callbackRateBps": "number|null",
      "reduceOnly": true
    }
  ],
  "reasonCodes": ["string"]
}

// Kademeli çıkış / yeniden dengeleme
{
  "event": "position.rebalance.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "scaleOut": [{"ratio":"0..1","mode":"limit|market","price":"number|null"}],
  "reasonCodes": ["string"]
}

// Acil/korumacı kapatma
{
  "event": "order.close.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "mode": "market|limit",
  "reasonCodes": ["string"]
}

// Bilgilendirme/telemetri
{
  "event": "vivo.supervisor.metrics",
  "timestamp": "iso8601",
  "symbol": "string",
  "p99_loop_ms": "number",
  "trailUpdates": "number",
  "scaleOuts": "number",
  "timeouts": "number",
  "emergencyCloses": "number"
}

{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["string"]}
}

TypeScript Arayüzleri (ürettir)

BracketReady, OrderUpdate, PositionSnapshot, MarketRefs, MarketTelemetry, ConnectivityHeartbeat, PolicySnapshot, VivoHintsUpdate.

SupervisorDecision (union: modify/scaleOut/close).

TrailingState, PositionState, PeakTracker, StagnationTimer.

Zod ile tüm giriş/çıkışlara runtime validasyon.

Event Bus Konuları

In: order.bracket.ready, order.update, position.snapshot, market.refs, telemetry.market, connectivity.heartbeat, policy.snapshot, vivo.hints.update

Out: order.modify.request, position.rebalance.request, order.close.request, vivo.supervisor.metrics, vivo.supervisor.alert

Konfig & Varsayılanlar
{
  // Trailing
  trailingModeDefault: "chandelier_atr",      // "callback_bps" destekle
  chandelier: { atrPeriod: 14, k: { aggressive: 2.0, base: 2.5, conservative: 3.0 } },
  callbackBps: { aggressive: 80, base: 60, conservative: 45 },
  minTrailStepBps: 6,                         // yeni SL, eski SL'den en az bu kadar daha iyi olmalı
  lockProfitAtR: 0.4,                         // realize edilmemiş R >= 0.4 ise SL'i break-even üstüne kilitle

  // Stagnation / Timeout
  stagnation: { lookbackMins: 20, minATRMove: 0.5, action: "scale_out_25" },
  maxHoldMinsDefault: 180,                    // policy.maxHoldMins overrides

  // Abnormal rejim eşikleri
  abnormal: {
    spreadBpsWarn: 20, spreadBpsPanic: 35,
    volZWarn: 1.6, volZPanic: 2.2
  },

  // Bağlantı / veri tazeliği
  freshness: { maxMarketGapMs: 3000, maxOrderGapMs: 5000, panicAfterMs: 8000 },

  // Risk & guard rails
  drawdownFromPeakR: { aggressive: 0.25, base: 0.35, conservative: 0.45 },  // policy ile clamp
  minQtyToAct: 1e-6,                        // step check üstünde olmak zorunda
  preferStopMarketOnEmergency: true,

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

PositionStateStore (in-memory + periyodik persist data/supervisor.json):

key = symbol+side+tradeId

entryTime, avgPrice, qtyOpen, variant, tpSlStyle, bracketMode

Peak tracker: peakPrice (long için max, short için min), peakR

Trailing state: son SL fiyatı, mod, callbackBps, son güncelleme zamanı

Stagnation timer: son anlamlı hareket zamanı (ATR tabanlı)

Freshness: son market/order heartbeat zamanı

Algoritma (Karar Akışı)

Ön Koşullar & Freshness

marketStreamAlive==false veya now - lastMarketRef > freshness.maxMarketGapMs → SAFE MODE:

Eğer borsada native SL yoksa acil SL yerleştir/güncelle (preferStopMarketOnEmergency).

Gap > panicAfterMs → order.close.request(mode="market") (reason: data_stale_panic).

Peak & R Hesabı

Long: peakPrice = max(peakPrice, lastPrice); Short: min.

R = (lastPrice - avgPrice) / slDistance (long; kısa için ters).

peakR güncellenir; drawdownFromPeakR ihlalinde:

SL’i yeni trailing seviyesine taşı (minTrailStepBps koşullu).

Retiestte tekrar ihlal olursa scale-out 25% veya close (policy’ye göre).

Trailing Kuralı

Chandelier ATR:

Long SL adayı = peakPrice - k*ATR; Short = peakPrice + k*ATR.

Callback Bps:

Long SL adayı = peakPrice * (1 - callbackBps/10000); Short simetrik.

newSL > oldSL + minTrailStepBps (long) ise order.modify.request(move_sl).

R ≥ lockProfitAtR → SL break-even üstüne alın.

Quiet hours + low liquidity → trailing daha tutucu (k katsayı +10%).

Kısmi TP / Rebalance

order.update.status=="filled" ve bir TP bacağı dolduysa:

Kalan qty’ye göre SL/TP yeniden proportional ayarlanır (reduce-only).

Eğer kalan qty çok küçük (< minQtyToAct) → order.close.request (temizle).

Stagnation / Timeout

stagnation.lookbackMins içinde ATR-normalize hareket < minATRMove ve R ≤ 0.2:

action "scale_out_25" → position.rebalance.request (market veya yakın limit).

Devam ederse maxHoldMins dolumunda close.

Abnormal Spread/Vol

spreadBps ≥ spreadBpsPanic VEYA volZScore ≥ volZPanic:

SL’i sıkılaştır, aggressive varyant geçici devre dışı (alert yayınla).

Durum sürerse scale-out 50% veya close (liquidityClass="low" ise market).

Ladder TP Senkronizasyonu

Emülasyon modunda TP/SL çifti: TP tetiklenince karşı emir iptal/yeniden yerleştir (reduce-only ve kalan qty’ye göre).

Native OCO’da borsa halleder; yine de denetim için order.update dinle, tutarsızlıkta düzelt.

Telemetri & Feedback

Her 10 sn: vivo.supervisor.metrics.

Kayda değer kararlar (move_sl, scale_out, close) için vivo.supervisor.alert + reasonCodes.

VIVO-17’nin öğrenmesi için outcome özetini (trailUpdates, emergencyCloses) logla.

Gerçek Dünya Kuralları (Proje-genel ile uyumlu)

Reduce-only zorunlu (futures); boyutu arttırma yok.

Slipaj ve limit kuralları korunur; acil durumlarda stop-market tercih edilir.

Bar kapanışı kuralına saygı (sinyal tarafı zaten uyguluyor); burada yürütme güvenliği öncelikli.

Kelly-light ve günlük 2–3 işlem sınırı başka modüllerde tutulur; Supervisor sadece açık pozisyonu korur.

Europe/Istanbul saat dilimi esas; quiet hours’ta trailing tutucu.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/livePositionSupervisor.ts

src/vivo/state/supervisorStore.ts (persist)

src/vivo/lib/trailing.ts (chandelier/callback hesapları)

__tests__/livePositionSupervisor.test.ts

Mimari

Saf çekirdek: supervise(positionState, refs, policy, cfg, telemetry) → SupervisorDecision[]

I/O adaptörü: bus subscribe/publish; state persist; timers.

Validasyon

Zod şemaları; sayısal alanlar finite(); eksik kritik veri → SAFE MODE.

Zaman

connectivity.heartbeat ile drift takip; timeout hesaplarında kullan.

Idempotency

Aynı SL seviyesine tekrar move_sl göndermeyi engelle (debounce/hash).

Loglama

Her karar traceId/correlationId ile auditlensin.

Test İskeleti (Jest)

chandelier_atr → SL adımı doğru ve minTrailStepBps’ten küçükse güncelleme YOK

callback_bps → peakPrice’dan gerilemede SL yukarı taşınır

drawdownFromPeakR ihlali → move_sl ardından tekrar ihlalde scale_out

stagnation 20dk + düşük R → scale_out_25

maxHoldMins dolunca → close

spread≥panic veya volZ≥panic → emergency tighten → close|scale_out

heartbeat gap > panicAfterMs → data_stale_panic → close market

TP fill → SL/TP yeniden ölçeklenir

Örnek Senaryo (Özet)

Durum

symbol=AVAXUSDT long, avgPrice=9.80, qtyOpen=120

ATR=0.22, variant=base, trailingMode=chandelier_atr(k=2.5)

peakPrice=10.45 → trailSL = 10.45 - 2.5*0.22 = 9.90

current last=10.20, R≈(10.20-9.80)/((9.80 - initialSL)) ~ örn. 0.6

Beklenen Kararlar

move_sl → newPrice=9.90 (oldSL 9.72 idi; minTrailStepBps sağlandı)

20 dk boyunca ATR-normalize hareket < 0.5 ve R ≤ 0.2 → position.rebalance.request(scaleOut 25%)

spreadBps=36 ve volZ=2.3 → move_sl (daha sıkı) + order.close.request(mode="market") (likidite low ise)

Entegrasyon Notları

VIVO-20’den sonra devrededir; bracket native/emülasyon farkını gözetir.

VIVO-17 geri besleme modülü, Supervisor’ın scale_out/close oranlarını kullanıp eşikleri ayarlayabilir.

Throttler (VIVO-18) yeni işlem başlatma işini kısıtlasa da, Supervisor açık pozisyonu her zaman korur.

correlationId zinciri ile uçtan uca izlenebilirlik korunur.
_________________________________________________________________________________________________________________
VIVO-22 · postTradePerformanceLogger.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Her işlemin uçtan-uca yaşam döngüsünü kayda almak: giriş/partial-fill/TT L/escalation/SL-TP/manuel/timeout gibi tüm aşamalar.

Gerçekleşen PnL (komisyon+slipaj+fonlama düşülmüş net), R multiple, MFE/MAE, time-to-first-fill, time-in-trade ve slippage bps gibi metrikleri hesaplayıp kalıcılaştırmak.

Günlük/haftalık simb ol×timeframe×variant×formationTag kırılımlarında özet KPI’lar (PF, hitRate, avgR, expectancy, feeRatio, avgSlipBps, maxDD) üretmek.

VIVO-17 (executionFeedbackLooper) ve Denetim Asistanı için hem ham olay akışı hem de normalize özet sağlamak.

Tüm saat/tarih işlemleri Europe/Istanbul; bar kapanışı/latency kuralları proje-genelle uyumlu. Idempotent ve tekrar çalıştırılabilir tasarla.

Girdiler (Event / JSON Şemaları)
// execution.fill — (VIVO-20/Exchange adapter'ından)
{
  "event": "execution.fill",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "formationTag": "string|null",
  "price": "number",
  "qty": "number",
  "fees": "number",
  "slippageBps": "number",
  "latencyMs": "number",
  "entryLegId": "string",
  "planRef": { "tpSlStyle": "ATR|range|hybrid", "plannedRR": "number", "slBasisDist": "number" }
}

// order.bracket.ready — (VIVO-20)
{
  "event": "order.bracket.ready",
  "timestamp": "iso8601",
  "correlationId": "string",
  "tradeId": "string",
  "mode": "native_oco|emulated",
  "slOrderId": "string",
  "tpOrderIds": ["string"]
}

// order.update — canlı durum (SL/TP tetik, cancel/replace, vs.)
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number",
  "reason": "string|null"
}

// execution.close — pozisyon tamamen kapanınca (VIVO-20)
{
  "event": "execution.close",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "symbol": "string",
  "side": "long|short",
  "pnlQuote": "number",
  "rMultiple": "number",
  "exitReason": "tp|sl|timeout|manual|rule|emergency|liquidation",
  "holdingMins": "number",
  "feesTotal": "number",
  "slippageBpsAvg": "number"
}

// market.refs — giriş/çıkış anı bağlamı (opsiyonel ama tavsiye)
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// policy.snapshot — politika üst sınırları (okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"}
}

// vivo.supervisor.alert — (VIVO-21'den önemli yol içi olaylar)
{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["string"]}
}

Çıktılar (Logger Olayları)
// Ham günlük satırı (append-only)
{
  "event": "trade.log.append",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "phase": "entry|scale_in|bracket_ready|scale_out|tp_hit|sl_hit|timeout|manual|emergency|close",
  "payload": { "any": "json" }
}

// Normalize edilmiş kapatma özeti (öğrenme ve rapor için)
{
  "event": "trade.summary.closed",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "formationTag": "string|null",
  "entry": { "time": "iso8601", "avgPrice": "number", "notional": "number" },
  "exit": { "time": "iso8601", "avgPrice": "number", "reason": "tp|sl|timeout|manual|rule|emergency|liquidation" },
  "durMins": "number",
  "pnl": { "gross": "number", "fees":"number", "net":"number" },
  "rMultiple": "number",
  "slippageBpsAvg": "number",
  "path": { "mfeR": "number", "maeR": "number", "peakR": "number", "ddFromPeakR": "number" },
  "timings": { "tFirstFillMs": "number", "tToBracketMs":"number" },
  "flags": ["open_bar_entry?","quiet_hours","low_liquidity","high_vol","emergency_flow"],
  "audit": { "tpSlStyle":"ATR|range|hybrid","plannedRR":"number","slBasisDist":"number" }
}

// VIVO-17 için ham öğrenme girişi (istenen sözleşme)
{
  "event": "vivo.feedback.raw",
  "timestamp": "iso8601",
  "scope": { "symbol":"string","timeframe":"string","variant":"base|aggressive|conservative","formationTag":"string|null" },
  "kpis": { "hit": "0|1", "profitFactor":"number", "rMultiple":"number", "slippageBps":"number", "fees":"number" },
  "samples": { "fills":"int" }
}

// Günlük roll-up KPI'ları
{
  "event": "vivo.performance.daily",
  "date": "YYYY-MM-DD",
  "scope": { "symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null" },
  "kpis": {
    "trades":"int","wins":"int","hitRate":"number","profitFactor":"number","avgR":"number",
    "expectancyR":"number","avgSlipBps":"number","feeToGrossPct":"number","maxDD_R":"number"
  }
}

TypeScript Arayüzleri (ürettir)

ExecFill, OrderBracketReady, OrderUpdate, ExecClose, MarketRefs, PolicySnapshot, SupervisorAlert.

TradeLogRow, TradeSummaryClosed, FeedbackRaw, DailyKpis.

Yardımcı: TradeSessionState, MfeMaeTracker, ClockDriftGuard.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: execution.fill, order.bracket.ready, order.update, execution.close, market.refs, policy.snapshot, vivo.supervisor.alert

Out: trade.log.append, trade.summary.closed, vivo.feedback.raw, vivo.performance.daily, vivo.logger.metrics, vivo.logger.alert

Konfig & Varsayılanlar
{
  // Depolama & elde tutma
  storage: { driver: "sqlite|json", file: "data/trades.db", retentionDays: 120 },

  // EWMA half-life (örneklem)
  ewma: { slip: 10, r: 14 },

  // Zamanlandırma
  rollupFlushSec: 15,
  dailyCutoffHour: 0, // Europe/Istanbul'da gün sonu

  // Anomali eşikleri
  anomaly: {
    slipBpsHigh: 12,
    feeToGrossMaxPct: 0.40,
    tFirstFillSlowMs: 3000,
    dataGapPanicMs: 8000
  },

  // Güvenlik & guard rails
  clamp: { rMultipleMin: -5, rMultipleMax: 5, slipBpsMaxAbs: 80 },

  // Telemetri
  metricsFlushSec: 10
}

Durum & Kalıcılık

TradeSessionState (in-memory + persist):

key = tradeId

startedAt, entryAvg, entryNotional, fills[], tFirstFillMs, tToBracketMs

mfeMae: {peakPrice, troughPrice, mfeR, maeR, peakR, ddFromPeakR}

lastMarketRef, lastOrderUpdate, openBarEntryFlag, quietHoursFlag, liquidityFlag, volZFlag

SQLite şema önerisi: trades, fills, events, daily_kpis (indeksler: symbol, timeframe, variant, formationTag, date).

Algoritma (Yüksek Seviye Akış)

Başlat / Güncelle

İlk execution.fill → trade oturumu aç; entryAvg, entryNotional, tFirstFillMs.

order.bracket.ready → tToBracketMs hesapla.

Her order.update / market.refs → MFE/MAE/peakR/ddFromPeakR güncelle.

vivo.supervisor.alert → ilgili flags’e ekle (örn. emergency_flow).

Slippage ve Ücret Muhasebesi

Fill bazında slippageBps EWMA güncelle.

Ücretleri ve (varsa) fonlamayı biriktir; feeToGrossPct’yi sınırla/anomali işaretle.

Kapanış

execution.close geldiğinde:

Net PnL = pnlQuote - fees - funding.

R multiple = netPnLQuote / (riskQuote); riskQuote = equity * riskPerTradePct (policy’den) veya plan sl mesafesine göre notional/SLdist; seçime göre audit.slBasisDist ile kayda geç.

TradeSummaryClosed’ı üret → yayınla.

FeedbackRaw üret → VIVO-17 tüketecek.

Roll-Up KPI’ları

Gün içinde kapananlar için scope key (symbol×tf×variant×formationTag) bazında kümüle et.

Gün sonunda (cutoff) vivo.performance.daily yayınla; maxDD_R kapalı işlemler üzerinden (equity simülasyonu yoksa close-to-close R drawdown).

Guard Rails

Aykırı değerleri clamp ile sınırla; uyarı olarak vivo.logger.alert.

Zaman uyumsuzluğu/eksik alan → satırı append et ama flags=["invalid_payload"] + alert.

Telemetri

10 sn’de bir vivo.logger.metrics: {p99_ingest_ms, rows_appended, summaries_published, anomalies}.

Gerçek Dünya Kuralları (Proje-genel)

Yürütme muhasebesi: Komisyon + slipaj + fonlama mutlaka düşülmüş net PnL raporla.

Bar kapanışı kuralı: Açık bar kaynaklı giriş varsa flags’e işaretle; performans analizinde ayrıştırılabilir olsun.

Kelly-light & günlük 2–3 işlem: Logger politika değiştirmez; yalnızca raporlar.

Latency-safe: tFirstFillMs > anomaly.tFirstFillSlowMs ise “geç giriş” uyarısı.

PERCENT_PRICE / minNotional ihlali sonucu abort edilen planlar trade olarak sayılmaz; fakat trade.log.append(phase="abort") ile kaydedilir.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/postTradePerformanceLogger.ts

src/vivo/state/tradeStore.ts (SQLite/JSON sürücü)

src/vivo/lib/mfeMae.ts, src/vivo/lib/kpi.ts, src/vivo/lib/ewma.ts

__tests__/postTradePerformanceLogger.test.ts

Mimari

Saf çekirdek: ingest(event) → updates[], close(tradeId) → summary.

IO adaptörü: bus subscribe/publish + storage persist + roll-up scheduler.

Validasyon

Zod şemaları; sayısal alanlar finite(). Hatalı paket drop etme — işaretle ve alert yayınla.

Idempotency

(tradeId, eventId||hash) ile aynı eventi iki kez işlememek için WAL/idempotency anahtarı.

Zaman & TZ

Tüm aggregasyonlar Europe/Istanbul; günlük cutoff 00:00 (konfig ile değiştirilebilir).

Test İskeleti (Jest)

first fill → session open & tFirstFillMs hesaplanır

bracket_ready → tToBracketMs

mfe/mae/peakR/ddFromPeakR hesapları (long/short senaryoları)

close → netPnL, rMultiple, feeRatio, slip EWMA

abort edilen plan → trade olarak sayılmaz

anomali eşik aşımları → logger.alert

idempotent ingest (aynı event iki kez) → tek kayıt

daily roll-up → doğru PF, hitRate, avgR, expectancyR

Örnek Senaryo (Özet)

Girdiler (kısaltılmış)

execution.fill (3 kez, IOC+limit), toplam qty 1.5 ETH, avgFill 2950; tFirstFillMs=420

order.bracket.ready (emulated), tToBracketMs=2100

Süre boyunca market.refs ile peakR=0.9, ddFromPeakR=0.35 ölçüldü

execution.close: pnlQuote=+58.4, feesTotal=5.2, slippageBpsAvg=7.9, rMultiple=+0.78, exitReason=tp

Beklenen Çıktı

trade.summary.closed net PnL 53.2, path {mfeR≈0.95, maeR≈-0.18, peakR≈0.9, ddFromPeakR≈0.35}, timings {420,2100}

vivo.feedback.raw hit=1, pf>1, rMultiple=0.78, slip=7.9

Gün sonunda vivo.performance.daily LINKUSDT/ M15 / base / ascendingTriangle kırılımıyla güncel KPI’lar.

Entegrasyon Notları

VIVO-17 bu modülün vivo.feedback.raw ve trade.summary.closed olaylarını birincil veri kaynağı olarak kullanmalı.

Denetim Asistanı ve raporlama katmanı, daily_kpis ve trade.summary.closed ile haftalık rapor çıkarabilir.

VIVO-21’den gelen alert ve path metrikleri (drawdown, emergency) flags içinde tutulur; gelecekte neden-sonuç analizi için kullanılacak.
_________________________________________________________________________________________________________________
VIVO-23 · riskBreachIncidentReporter.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Risk ve politika ihlallerini anında tespit edip olay (“incident”) olarak açmak, izlemek ve kapatmak.

Olayları sınıflandırmak (taxonomi), kök neden (root-cause) ve katkı faktörleri ile kayda geçirmek.

Yönetişim önerileri üretmek (ör. “cooldown uygula”, “aggressive varyantı kapat”, “yeni niyetleri durdur”).

VIVO-17 (feedback) ve Denetim Asistanı için öğrenme olayı yayınlamak.

Bu modül karar vermez (trade aç/kapat). Önerileri yayımlar; uygulama yetkisi Policy/LIVIA ve ilgili modüllerdedir.

Girdiler (Event / JSON Şemaları)
// policy.snapshot — üst sınırlar
{
  "event": "policy.snapshot",
  "riskPerTradePct": 0.5,
  "dailyMaxTrades": 3,
  "kellyCap": 0.25,
  "maxConcurrentPerSymbol": 1,
  "globalMaxConcurrent": 3,
  "confirmationBounds": {"min":0.55,"max":0.72}
}

// livia.guard — acil durum / seri kayıp
{
  "event": "livia.guard",
  "cooldownActive": true,
  "seriesLoss": {"lastN": 5, "lossCount": 3},
  "emergency": "none|slowdown|halt"
}

// account.exposure — açık risk ve pozisyonlar
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {"symbol":"string","side":"long|short","qty":1.23,"riskPct":0.6}
  ],
  "totalRiskPctOpen": 1.8
}

// execution.intent.* — throttler kararları
{
  "event": "execution.intent.rejected|execution.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["daily_limit_hit","risk_cap_reached","per_symbol_concurrency","burst_limit","emergency_halt"],
  "correlationId": "string"
}

// order.execution.error — yürütme hataları (VIVO-20)
{
  "event": "order.execution.error",
  "timestamp": "iso8601",
  "correlationId": "string",
  "stage": "placing_entry|placing_bracket|monitoring|cancel_replace|failover",
  "code": "network|ratelimit|percent_price|min_notional|insufficient_margin|unknown",
  "detail": "string"
}

// vivo.supervisor.alert — açık pozisyonda riskli durumlar (VIVO-21)
{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["data_stale_panic","abnormal_spread","abnormal_vol","drawdown_breach"]}
}

// trade.summary.closed — işlem kapanışı (VIVO-22)
{
  "event": "trade.summary.closed",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "rMultiple": "number",
  "pnl": {"gross":"number","fees":"number","net":"number"},
  "path": {"peakR":"number","ddFromPeakR":"number"},
  "flags": ["quiet_hours","open_bar_entry","emergency_flow"]
}

// telemetry.market — rejim/likidite sinyalleri (opsiyonel)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",
  "liquidityClass": "low|mid|high"
}

Çıktılar (Incident & Öneri Olayları)
// Olay açma
{
  "event": "risk.incident.open",
  "timestamp": "iso8601",
  "incidentId": "RIS-20250901-AVAXUSDT-0001",
  "type": "policy_violation|exposure_breach|series_loss|drawdown_breach|limit_breach|execution_anomaly|data_staleness|emergency_halt|governance_override",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "correlationId": "string|null",
  "rootCause": {"trigger":"string","immediate":"string","contributing":["string"]},
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "openReasonCodes": ["string"]
}

// Olay güncelleme (tekrar ihlal, metrik güncel, seviye artışı)
{
  "event": "risk.incident.update",
  "timestamp": "iso8601",
  "incidentId": "string",
  "severity": "low|medium|high|critical",
  "appendReasonCodes": ["string"],
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "notes": "string"
}

// Olay kapatma (iyileşme/recovery)
{
  "event": "risk.incident.closed",
  "timestamp": "iso8601",
  "incidentId": "string",
  "resolution": "auto_recovered|manual_intervention|policy_applied|timeout",
  "durationSec": "number",
  "finalNotes": "string"
}

// Yönetişim önerisi (uygulama Policy/LIVIA’da)
{
  "event": "risk.governance.recommendation",
  "timestamp": "iso8601",
  "incidentId": "string",
  "recommendations": [
    "apply_cooldown_30m",
    "halt_new_intents_10m",
    "disable_aggressive_variant_2h",
    "tighten_confirmation_by_0.01",
    "reduce_risk_per_trade_to_0.5pct",
    "limit_per_symbol_per_hour_to_1"
  ],
  "rationale": ["string"]
}

// VIVO-17 öğrenmesi için özet
{
  "event": "vivo.feedback.incident",
  "timestamp": "iso8601",
  "type": "string",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "reasonCodes": ["string"]
}

Taxonomi & Haritalama (Reason → Incident Type)

policy_violation: daily_limit_hit, per_symbol_concurrency, burst_limit, confirmation_out_of_bounds

exposure_breach: risk_cap_reached, totalRiskPctOpen > cfg.maxTotalRiskPctOpen

series_loss: livia.guard.seriesLoss.lossCount >= cfg.seriesLoss.minLosses

drawdown_breach: vivo.supervisor.alert.reasonCodes içinde drawdown_breach veya trade.summary.closed.path.ddFromPeakR ≥ cfg.ddFromPeakR[variant]

limit_breach: percent_price|min_notional (order.execution.error)

execution_anomaly: ratelimit|network|failover_excess|slippage_excess

data_staleness: data_stale_panic (supervisor) veya heartbeats eksikliği (başka modülden geliyorsa)

emergency_halt: livia.guard.emergency == "halt"

TypeScript Arayüzleri (ürettir)

PolicySnapshot, LiviaGuard, AccountExposure

IntentDecision (rejected/deferred), ExecError, SupervisorAlert, TradeSummaryClosed, MarketTelemetry

RiskIncidentOpen|Update|Closed, GovernanceRecommendation, IncidentFeedback

Yardımcı: IncidentState, IncidentKey (type+symbol+timeframe), Severity

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: policy.snapshot, livia.guard, account.exposure, execution.intent.*, order.execution.error, vivo.supervisor.alert, trade.summary.closed, telemetry.market

Out: risk.incident.open, risk.incident.update, risk.incident.closed, risk.governance.recommendation, vivo.feedback.incident, risk.incident.metrics, risk.incident.alert

Konfig & Varsayılanlar
{
  // Eşikler
  "maxTotalRiskPctOpen": 2.0,
  "seriesLoss": { "window": 5, "minLosses": 3 },
  "ddFromPeakR": { "aggressive": 0.25, "base": 0.35, "conservative": 0.45 },
  "slippageBpsHard": 15,
  "spreadBpsPanic": 35,
  "volZPanic": 2.2,

  // Olay ömrü
  "dedupeWindowSec": 600,               // aynı type+symbol için tek açık olay
  "autoCloseQuietSec": 1800,            // ihlal yoksa otomatik kapanış
  "escalateAfterRepeats": 2,            // tekrar sayısında seviye artır

  // Öneri şablonları
  "recommendationProfiles": {
    "series_loss": ["apply_cooldown_30m","disable_aggressive_variant_2h"],
    "exposure_breach": ["halt_new_intents_10m","reduce_risk_per_trade_to_0.5pct"],
    "data_staleness": ["halt_new_intents_10m"],
    "execution_anomaly": ["tighten_confirmation_by_0.01"]
  },

  // Telemetri
  "metricsFlushSec": 10,
  "tz": "Europe/Istanbul"
}

Durum Yönetimi

IncidentStateStore (in-memory + periyodik persist data/incidents.json veya SQLite):

openByKey: Map<IncidentKey, IncidentRecord>

history: append-only günlük

Sayaçlar: tekrar sayısı, son görülme, ilk/son zaman damgası

Algoritma (Karar Akışı)

Normalize & Sınıflandır

Olayı Zod ile doğrula, reason→type eşle.

IncidentKey = type + (symbol||"*") + (timeframe||"*").

De-dupe & Aç/Kor

dedupeWindowSec içinde aynı IncidentKey açık ise update yap; değilse open.

escalateAfterRepeats eşiğinde severity bir kademe artır.

Kök Neden & Faktörler

rootCause.trigger = tetikleyen olay (ör. daily_limit_hit).

immediate = doğrudan ihlal (ör. totalRiskPctOpen 2.1%).

contributing = liquidityClass=low, volZ>2.2, quiet_hours, network.

Metrik Ata

Mümkünse totalRiskPctOpen, ddFromPeakR, slipBps gibi sayıları doldur.

Öneri Üret

recommendationProfiles[type] starting set; bağlama göre ekle/çıkar:

severity=="critical" → halt_new_intents_10m ekle.

variant=="aggressive" ve tekrar varsa → disable_aggressive_variant_2h.

Yayınla

risk.incident.open|update + risk.governance.recommendation + vivo.feedback.incident.

Kapanış

autoCloseQuietSec boyunca yeni ihlal yoksa risk.incident.closed(resolution="auto_recovered").

livia.guard.emergency=="halt" kalkınca ve metrikler normalleşince kapat.

Telemetri

10 sn’de bir risk.incident.metrics: {open_incidents, updates, closes, critical_rate}.

Önemli durumlarda risk.incident.alert(level="warn|error").

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/riskBreachIncidentReporter.ts

src/vivo/state/incidentStore.ts

src/vivo/lib/incidentMap.ts (reason→type, severity başlangıcı)

__tests__/riskBreachIncidentReporter.test.ts

Mimari

Saf çekirdek: ingest(event, state, cfg) → emissions[].

I/O adaptörü: bus subscribe/publish + persist + periodic auto-close timer.

Validasyon

Tüm giriş/çıkış Zod; bilinmeyen reason’lar execution_anomaly altına graceful düşsün (notes ile).

Idempotency

Aynı olay tekrar gelirse eventHash ile yoksay (history’ye tek satır).

Log/Audit

Tüm açık olaylar traceId/correlationId ile izlenebilir; kapanışta süresini yaz.

Test İskeleti (Jest)

daily_limit_hit → policy_violation(open); tekrarında update + severity↑

totalRiskPctOpen>2% → exposure_breach(open); normalleşince auto_close

seriesLoss(≥3/5) → series_loss(open); öneri: cooldown + aggressive off

order.execution.error(percent_price) → limit_breach(open)

supervisor data_stale_panic → data_staleness(critical); öneri: halt_new_intents

drawdown_breach from trade.summary.closed → drawdown_breach(open)

unknown reason → execution_anomaly(open); graceful degrade

dedupeWindowSec içinde ikinci aynı olay → update, open sayısı artmaz

Örnek Senaryo (Özet)

Girdiler

execution.intent.rejected reason=risk_cap_reached, account.exposure.totalRiskPctOpen=2.3

3 dk sonra vivo.supervisor.alert reason=abnormal_spread (spread=38 bps)

15 dk ihlal yok

Beklenen Yayınlar

{
  "event":"risk.incident.open",
  "type":"exposure_breach",
  "severity":"high",
  "scope":{"symbol":null,"timeframe":null,"variant":null},
  "metrics":{"totalRiskPctOpen":2.3},
  "openReasonCodes":["risk_cap_reached"]
}

{
  "event":"risk.governance.recommendation",
  "incidentId":"RIS-...","recommendations":["halt_new_intents_10m","reduce_risk_per_trade_to_0.5pct"],
  "rationale":["open_risk_2.3pct_over_2.0pct","recent_abnormal_spread"]
}


15 dk sonra:

{"event":"risk.incident.closed","resolution":"auto_recovered","durationSec":900}

Entegrasyon Notları

VIVO-18 Throttler ve VIVO-21 Supervisor’dan gelen reason’lar bu modülü tetikler.

Policy/LIVIA risk.governance.recommendation olaylarını dinleyerek gerçekte uygular (cooldown/slowdown/halt).

VIVO-17 vivo.feedback.incident ile eşiklerini yeniden ayarlarken incident tip ve şiddetini dikkate alır.

Denetim Asistanı haftalık raporlarında incident history + governance uygulama oranı KPI’larını kullanır.
_________________________________________________________________________________________________________________
VIVO-24 · signalQualityAssurance.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Grafi̇k Beyni ve diğer kaynaklardan gelen sinyalleri yayınlanmadan önce “fail-fast” kalite kontrolünden geçirmek:

Şema/alan validasyonu, tazelik (freshness), bar kapanışı kuralı,

Anomali damgaları (uç değer, z-score sapması, open-bar, clock-skew, replay),

Rejim uyumu ve likidite filtreleri,

Tekilleştirme / anti-replay ve kaynak güven katmanı,

Özelliklerin normalize/standartlaştırılması ve qualityScore hesaplanması.

Sonuç olarak sinyali geçir, ertele (hold) veya reddet; gerekçeleri ve metrikleri yayımla.

Bu modül “kalite kapısıdır”. Karar üretmez; temizlenmiş sinyali VIVO-16 signalDecisionRouter’a iletir.

Girdiler (Event / JSON Şemaları)
// signal.envelope.raw — Grafik Beyni ve diğer üreticilerden gelir (ham)
{
  "event": "signal.envelope.raw",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",               // M1|M5|M15|H1|H4|D1...
  "source": "string",                  // formation.breakout|orderflow.imbalance|ext.alphaX ...
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number"
  },
  "vivoHints": {
    "confirmationThreshold": "number|null",
    "signalVariant": "base|aggressive|conservative|null",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number|null",
    "barState": "open|closed|null"     // sinyal üretildiği anda bar durumu
  }
}

// market.refs — çapraz doğrulama bağlamı
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "atr": {"period":14,"value":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// regime.snapshot — rejim tespiti (Grafik Beyni veya ayrı)
{
  "event": "regime.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "regime": "trend|range|breakout|highVol|illiquid"
}

// exchange.info — sembol filtreleri (tick/step/minNotional vs. doğrulama için opsiyonel)
{
  "event": "exchange.info",
  "symbol": "string",
  "filters": {"tickSize":"number","stepSize":"number","minNotional":"number"}
}

// connectivity.heartbeat — veri tazeliği izleme
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "marketStreamAlive": "boolean",
  "latencyMs": "number"
}

Çıktılar (QA Kararı & Telemetri)
// Geçen sinyal (temizlenmiş/enriched) → VIVO-16
{
  "event": "signal.envelope",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number",
    "zScores": {"trend":"number","rr":"number","vol":"number","of":"number"}   // eklenti
  },
  "vivoHints": {
    "confirmationThreshold": "number|null",
    "signalVariant": "base|aggressive|conservative|null",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  },
  "qa": {
    "qualityScore": "0..1",
    "tags": ["string"],                       // open_bar, high_vol, illiquid, clock_skew...
    "reasonCodes": ["string"],                // pass gerekçeleri ve cezalar
    "sourceTier": "core|experimental|external",
    "freshnessMs": "number"
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number|null",
    "barState": "open|closed|null"
  }
}

// Reddedilen sinyal (log & izleme)
{
  "event": "signal.qa.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "signalId": "string",
  "reasonCodes": ["invalid_payload","stale","duplicate_id","illiquid_block","clock_skew","anomaly_outlier"],
  "qa": {"qualityScore":"0..1","tags":["string"]}
}

// Erteleme (bar kapanışı veya veri eksikliği nedeniyle)
{
  "event": "signal.qa.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "signalId": "string",
  "deferUntil": "iso8601",
  "reasonCodes": ["await_bar_close","await_market_refs","network_latency_high"]
}

// Telemetri
{
  "event": "signal.qa.metrics",
  "timestamp": "iso8601",
  "p99_ms": "number",
  "pass_rate": "number",
  "reject_rate": "number",
  "defer_rate": "number",
  "dup_drop_rate": "number",
  "avg_quality": "number"
}

{
  "event": "signal.qa.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string","source":"string","reasonCodes":["string"]}
}

TypeScript Arayüzleri (ürettir)

RawSignalEnvelope, CleanSignalEnvelope, QABlock, QAMetrics, QAReject, QADefer.

Bağlam: MarketRefs, RegimeSnapshot, ExchangeInfo, ConnectivityHeartbeat.

Yardımcı: BaselineStats (rolling mean/std/z), DedupKey, BloomLikeSet.

Zod ile tüm giriş/çıkışlarda runtime validasyon; NaN/∞/null sapmaları yakala.

Event Bus Konuları

In: signal.envelope.raw, market.refs, regime.snapshot, exchange.info, connectivity.heartbeat

Out: signal.envelope (temiz), signal.qa.rejected, signal.qa.deferred, signal.qa.metrics, signal.qa.alert

Konfig & Varsayılanlar
{
  // Tazelik pencereleri (timeframe'e göre max timestamp drift)
  freshnessMsByTF: { "M1": 3000, "M5": 5000, "M15": 8000, "H1": 15000, "H4": 30000, "D1": 60000 },

  // Bar kapanışı politikası
  openBarPolicy: { mode: "penalize|defer|block", penalty: 0.04, deferMs: 5000 },

  // Kaynak güven katmanı
  sourceTiers: { "formation.breakout": "core", "orderflow.imbalance": "core", "ext.alphaX": "experimental", "*": "external" },
  minQualityByTier: { "core": 0.58, "experimental": 0.64, "external": 0.68 },

  // Rejim/likidite filtreleri
  illiquidBlock: true,
  highVolPenalty: 0.03,       // regime=highVol ise qualityScore cezaları
  illiquidPenalty: 0.06,

  // Özellik normalizasyonu (clamp & z-score)
  featureClamp: { min: -3, max: 3 },         // normalized alanlarda
  zScoreWindow: 200,                          // rolling baseline örnek sayısı

  // Anti-duplicate / replay
  dedupe: { windowMs: 1500, keyFields: ["symbol","side","timeframe","source","meta.signalId"] },

  // Clock skew & latency
  maxClockSkewMs: 2000,
  highLatencyPenalty: 0.03,

  // QualityScore ağırlıkları
  qualityWeights: {
    payload: 0.30,     // şema/alan bütünlüğü, clamp ihlalsiz
    freshness: 0.20,   // tazelik, clock skew yok
    barClose: 0.10,    // closed bar avantajı
    regimeFit: 0.15,   // rejim-formation uyumu
    sourceTrust: 0.15, // tier ağırlığı
    anomalySafe: 0.10  // z-score ve uç-değer kontrolleri
  },

  // Anomali/Outlier eşikleri
  outlier: { zAbsMax: 3.5, rrMin: 0.0, rrMax: 1.0, trendMin: 0.0, trendMax: 1.0 },

  // Defer bekleme
  awaitRefsMaxMs: 4000,

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

QABaselineStore (in-memory + periyodik persist data/qa.baseline.json):

Rolling mean/std (trendStrength, rrScore, volatility, orderflowBias), count.

Son görülen market.refs ve regime.snapshot timestamps (tazelik).

DedupLRU/Bloom set (key → expiresAt).

QAMetricsState: kaydırmalı sayaçlar (pass/reject/defer/dup_drop, p99 loop ms, avg_quality).

Algoritma (Karar Akışı)

Şema & Tip Validasyonu

Zod ile RawSignalEnvelope doğrula. Sayısal alanlar finite(); rrScore, trendStrength, orderflowBias → [0,1] clamp.

Hatalı → reject("invalid_payload"); signal.qa.rejected yayınla.

De-dupe & Anti-Replay

DedupKey = join(cfg.dedupe.keyFields) + Math.floor(timestamp/cfg.dedupe.windowMs) dilimi.

Varsa → reject("duplicate_id"); yoksa sete ekle (TTL = windowMs).

Tazelik & Saat Kayması

now - timestamp > freshnessMsByTF[timeframe] → reject("stale").

|timestamp - now| > maxClockSkewMs → penalize (clock_skew) veya reject (skew çok büyükse).

Bar Kapanışı Politikası

meta.barState=="open":

openBarPolicy.mode=="penalize" → qualityScore − penalty, qa.tags += ["open_bar"].

"defer" → deferred (deferUntil = bar kapanışı tahmini).

"block" → reject("open_bar").

Piyasa Referansları & Rejim

Son market.refs taze mi? Değilse defer("await_market_refs"), en fazla awaitRefsMaxMs.

regime.snapshot.regime == "illiquid" → illiquidBlock ? reject : penalize.

regime=="highVol" → penalize (highVolPenalty).

Formation uyumu:

formationTag “breakout” & regime “range” → küçük ceza.

formationTag “meanRevert” & regime “trend” → ceza.

Eşleşen kombinasyonlara mini bonus (0.01–0.02).

Anomali/Outlier Kontrolleri

Rolling baseline’dan z-score hesapla; herhangi bir özelliğin |z|> outlier.zAbsMax → reject("anomaly_outlier").

rrScore, trendStrength gibi [0,1] dışı değerler clamp sonrası büyük sapma yaratıyorsa penalize("clamp_hit").

Kaynak Güveni & Eşikler

sourceTier = cfg.sourceTiers[source] || "external".

qualityScore hesapla (ağırlıklar).

qualityScore < minQualityByTier[sourceTier] → reject("quality_below_tier_min").

Zenginleştirme ve Yayın

features.zScores alanını ekle, qa.tags ve reasonCodes’u doldur.

pass ise signal.envelope olarak yayınla.

defer ise signal.qa.deferred (tekrar deneme için) yayınla.

Metrikler & Uyarılar

Sayaçları ve p99 döngü süresini güncelle; signal.qa.metrics her 10 sn’de yayınla.

Seri stale veya illiquid_block artarsa alert üret.

Gerçek Dünya Kuralları (Proje-genel uyumlu)

Fail-fast: Şema/tazelik ihlali anında reject; “yumuşatmaya” çalışma.

Idempotency: Aynı ham sinyal tekrar işlense aynı DedupKey ile drop edilir.

Open Bar: Varsayılan penalize; VIVO-16 zaten açık barları cezalı ele alır.

Likidite: “illiquid” rejiminde agresif varyantlar sistemin diğer katmanlarında da kısıtlı; burada blok/ceza “ilk bariyer”.

TZ: Europe/Istanbul; bar kapanışı tahminlerinde local saate göre hesap.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/signalQualityAssurance.ts

src/vivo/state/qaStore.ts (baseline + dedupe + metrics persist)

src/vivo/lib/zscore.ts, src/vivo/lib/qualityScore.ts

__tests__/signalQualityAssurance.test.ts

Mimari

Saf çekirdek: qaCheck(raw, ctx, cfg) → {decision: "pass|defer|reject", emissions[]}

I/O adaptörü: bus subscribe/publish + ctx cache (market.refs, regime.snapshot).

Validasyon

Zod şemaları; sayısal alanlara finite(), [0,1] beklenenleri clamp + tag.

Bilinmeyen alanlar → warn ve ignore; drop etme (fail-fast yalnızca kritiklerde).

Performans

p99 < 5ms hedef; z-score için O(1) güncellenen “rolling mean/std” uygula.

Idempotency

signalId + zaman dilimi anahtarıyla tekrar işlemleri önle.

Log/Audit

Tüm kararlar traceId/correlationId (yoksa üret) ile auditlenir.

Test İskeleti (Jest)

invalid payload → reject(invalid_payload)

duplicate within window → reject(duplicate_id)

stale timestamp (M1>3s) → reject(stale)

openBar penalize|defer|block davranışı

illiquid regime + illiquidBlock=true → reject(illiquid_block)

highVol → qualityScore penalty uygulandı

outlier z>|3.5| → reject(anomaly_outlier)

experimental source quality < min → reject(quality_below_tier_min)

await market refs → deferred & tekrar denemede pass

metrics counters & p99 loop güncellenir

Örnek Senaryo (Özet)

Girdi (ham)

{
  "event":"signal.envelope.raw",
  "timestamp":"2025-09-01T07:12:05Z",
  "symbol":"AVAXUSDT","side":"long","timeframe":"M5",
  "source":"formation.breakout",
  "features":{"trendStrength":0.68,"rrScore":0.66,"volatility":0.92,"orderflowBias":0.51},
  "vivoHints":{"confirmationThreshold":0.62,"signalVariant":"base","biasWeightedTune":{"trend":0.5,"orderflow":0.3,"formation":0.2}},
  "meta":{"signalId":"sig-889","formationTag":"ascendingTriangle","latencyMs":420,"barState":"open"}
}


Bağlam

market.refs (taze), spreadBps=9, volZScore=1.4

regime.snapshot.regime="trend"

openBarPolicy.mode="penalize" (0.04)

Beklenen Çıktı (özet)

{
  "event":"signal.envelope",
  "symbol":"AVAXUSDT","side":"long","timeframe":"M5","source":"formation.breakout",
  "features":{"trendStrength":0.68,"rrScore":0.66,"volatility":0.92,"orderflowBias":0.51,
    "zScores":{"trend":0.7,"rr":0.5,"vol":1.1,"of":0.2}},
  "qa":{"qualityScore":0.62,"tags":["open_bar"],"reasonCodes":["payload_ok","fresh_ok","bar_penalize","regime_fit"],"sourceTier":"core","freshnessMs":1200},
  "meta":{"signalId":"sig-889","formationTag":"ascendingTriangle","latencyMs":420,"barState":"open"}
}


(Eşikleri aşmayan kalite → pass; open-bar nedeniyle quality -0.04 ceza.)

Entegrasyon Notları

VIVO-16 signalDecisionRouter bu modülden geçen signal.envelope’ı tüketir; qa.qualityScore ve qa.tags karar sürecine ipucu olur.

VIVO-18 Throttler ve VIVO-21 Supervisor açık-bar / highVol etiketlerine göre daha korumacı davranabilir.

VIVO-17 Feedback “qa.rejected/deferred” oranlarını izleyip confirmationThreshold önerilerini ayarlarken QA çıktılarını kullanır.
_________________________________________________________________________________________________________________
VIVO-25 · portfolioExposureBalancer.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Yeni kabul edilmiş işlem niyeti (VIVO-18) gelmeden önce/gelir gelmez, portföyün toplam risk tavanı, küme (cluster) limitleri ve korelasyon-temelli marjinal riske göre dengelemek.

Aşırı korelasyonlu/aynı kümeye yığılmış pozisyonları yumuşak (downscale) veya sert (reject/defer) biçimde yönetmek.

Net yön sapması (long vs short), beta/faktör yoğunluğu ve tekil enstrüman tavanlarını uygulamak.

Çıktı: portfolio.intent.approved|adjusted|deferred|rejected (gerekirse risk yüzdesi düşürülmüş).

Bu katman boyutu yükseltmez; yalnızca aynı tutar bırakır veya azaltır/bloklar. Yürütme planlaması VIVO-19’dadır.

Girdiler (Event / JSON Şemaları)
// execution.intent.accepted — throttler'dan sonra gelen kabul edilmiş niyet (giriş)
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "constraints": { "riskProfile": "tight|normal|relaxed" },
  "tuning": { "positionScaling": "single|laddered" },
  "audit": { "upstream": {"source":"string","signalId":"string"} }
}

// account.exposure — açık pozisyonlar ve açık risk
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {
      "symbol":"string","side":"long|short",
      "riskPct":"number",                 // işlemde risklenen % (equity'e göre)
      "cluster":"L1|L2|DeFi|Layer1|AI|PerpAlts|BTCComplex|StablePair|Other",
      "beta":{"BTC":"number","Market":"number"},
      "corrKey":"string"                  // risk model anahtarı
    }
  ],
  "totalRiskPctOpen": "number"
}

// risk.model.snapshot — korelasyon/kovaryans ve kümeler (risk modeli)
{
  "event": "risk.model.snapshot",
  "timestamp": "iso8601",
  "universe": ["AVAXUSDT","BTCUSDT","ETHUSDT","..."],
  "corr": [["1.0","0.78","..."],["0.78","1.0","..."],["..."]],
  "volBps": {"AVAXUSDT": "number", "BTCUSDT": "number"},
  "clusters": {"AVAXUSDT":"Layer1","ETHUSDT":"Layer1","LINKUSDT":"Infra","..."},
  "factorBeta": {"AVAXUSDT":{"BTC":0.82,"Market":1.1},"BTCUSDT":{"BTC":1.0,"Market":1.0}}
}

// portfolio.policy — portföy tavanları ve kurallar
{
  "event": "portfolio.policy",
  "timestamp": "iso8601",
  "caps": {
    "totalRiskPct": 2.0,                   // toplam açık risk %2
    "perSymbolPct": 0.8,                   // tek işlem risk tavanı %
    "perClusterPct": {"Layer1": 1.2, "DeFi": 0.8, "Infra": 0.8, "Other": 0.8},
    "perFactorBetaAbs": {"BTC": 1.8, "Market": 2.5},  // |beta-weighted net|
    "longShortImbalancePct": 1.0           // |netLong - netShort| ≤ 1.0%
  },
  "correlation": {
    "hardPairThreshold": 0.85,             // bu eşik üzeri aynı yönde → sert kontrol
    "softPairThreshold": 0.7,              // bu eşik üzeri → downscale
    "defaultSameCluster": 0.5,             // model yoksa varsayılan
    "marginalRiskMaxPct": 0.6              // yeni niyetin marjinal katkısı (toplam riske oran)
  },
  "actions": {
    "onHardBreach": "reject",              // reject|defer
    "onSoftBreach": "adjust"
  }
}

// mapping.meta — sembol→cluster/beta override (opsiyonel)
{
  "event": "mapping.meta",
  "overrides": {"SUIUSDT":{"cluster":"Layer1","beta":{"BTC":0.74,"Market":1.05}}}
}

Çıktılar (Karar Olayları)
// Olduğu gibi onay
{
  "event": "portfolio.intent.approved",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "riskPerTradePct": "number",
  "reasonCodes": ["ok_total","ok_cluster","ok_corr","ok_factor","ok_balance"],
  "correlationNotes": {"topPairs":[{"symbol":"string","rho":"number"}]}
}

// Downscale (yumuşak ayar)
{
  "event": "portfolio.intent.adjusted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "riskPerTradePctOriginal": "number",
  "riskPerTradePctAdjusted": "number",
  "scaleFactor": "number",                   // 0..1
  "reasonCodes": ["soft_pair_corr","cluster_cap_tight","total_cap_close","beta_saturation"],
  "correlationNotes": {"topPairs":[{"symbol":"string","rho":"number"}]}
}

// Ertele (ör. model tazeliği yok, exposure snapshot eski)
{
  "event": "portfolio.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "deferUntil": "iso8601",
  "reasonCodes": ["stale_risk_model","stale_exposure"]
}

// Red (sert ihlal)
{
  "event": "portfolio.intent.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["hard_pair_corr","cluster_cap_exceeded","total_cap_exceeded","beta_over","imbalance_exceeded"]
}

// Opsiyonel tavsiye (hedge/scale-out hedefleri)
{
  "event": "portfolio.hedge.suggestion",
  "timestamp": "iso8601",
  "suggestions": [
    {"action":"scale_out","symbol":"ETHUSDT","ratio":0.25,"reason":"cluster_overflow"},
    {"action":"open_hedge","symbol":"BTCUSDT","side":"short","riskPct":0.3,"reason":"beta_over_BTC"}
  ],
  "rationale": ["reduce Layer1 cluster from 1.6%→1.2%", "lower BTC beta from 2.1→1.7"]
}

TypeScript Arayüzleri (ürettir)

IntentAccepted (VIVO-18), AccountExposure, RiskModelSnapshot, PortfolioPolicy, MappingMeta.

Çıkışlar: PortfolioIntentApproved|Adjusted|Deferred|Rejected, PortfolioHedgeSuggestion.

Yardımcı: ExposureVector, ClusterExposure, FactorExposure, PairCorrelation, RiskContribution.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: execution.intent.accepted, account.exposure, risk.model.snapshot, portfolio.policy, mapping.meta

Out: portfolio.intent.*, portfolio.hedge.suggestion, portfolio.balancer.metrics, portfolio.balancer.alert

Konfig & Varsayılanlar
{
  // Tazelik
  freshness: { modelMaxAgeSec: 180, exposureMaxAgeSec: 10 },

  // Varsayılan korelasyonlar (model yokken)
  defaults: { sameClusterRho: 0.5, crossClusterRho: 0.2 },

  // Ölçekleme mantığı
  scale: {
    minFactor: 0.2,                      // asgari bırakılacak risk
    step: 0.05,                          // iteratif azaltım adımı
    preferDownscaleOverDefer: true
  },

  // Net yön sapması
  imbalance: { maxAbsPct: 1.0 },         // |netLong - netShort| ≤ 1.0%

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

PortfolioState (in-memory + periyodik persist data/portfolio.state.json):

Son AccountExposure, RiskModelSnapshot, PortfolioPolicy, MappingMeta.

Türetilmiş: clusterExposure (Map), factorExposure (beta-weighted), netLongPct, netShortPct.

CorrelationCache: (symbolA,symbolB) → rho (model yoksa defaults).

Hesaplamalar (Basitleştirilmiş ama sağlam)

Aday Niyetin Risk Ağırlığı

w_new = riskPerTradePct_candidate (yeni niyetin risk yüzdesi).

Mevcut Portföy Vektörleri

w_i = riskPct (açık işlemlerin risk yüzdeleri), işaret: long=+; short=− (net dengesi için).

Cluster toplamları: Σ |w_i| kümeye göre.

Factor (beta) maruziyeti: Σ (sign_i * |w_i| * beta_i[f]).

Çift Korelasyonu

Aday sembol S ile her açık sembol i için rho(S,i) (model yoksa default/cluster tabanlı).

Marjinal Risk Katkısı (MRC ~)

Yaklaşık: mrc ≈ w_new * ( Σ_i ( |w_i| * rho(S,i) ) + |w_new| ) / ( totalRiskPctOpen + |w_new| ).

Kabul için: mrc ≤ portfolio.policy.correlation.marginalRiskMaxPct.

Limit Kontrolleri

Total: totalRiskPctOpen + |w_new| ≤ caps.totalRiskPct.

Per-Symbol: |w_new| ≤ caps.perSymbolPct.

Cluster: clusterExposure[cluster(S)] + |w_new| ≤ caps.perClusterPct[cluster].

Hard Pair Corr: varsa aynı yönde açık i ve rho(S,i) ≥ hardPairThreshold → hard breach.

Soft Pair Corr: rho ≥ softPairThreshold → downscale hedefi.

Factor Beta: |factorExposure[f] + sign_new*|w_new|*beta_S[f]| ≤ caps.perFactorBetaAbs[f].

Imbalance: | (netLongPct + longNew) - (netShortPct + shortNew) | ≤ caps.longShortImbalancePct.

Downscale Stratejisi (Soft ihlallerde)

Önce soft pair ve cluster ihlallerini giderene kadar w_new *= (1 - step) iterasyonu.

mrc ve factor limitleri sağlanana kadar sürdür.

Alt sınır scale.minFactor altına düşerse actions.onSoftBreach=="adjust" ise rejecte dön; aksi defer.

Hard Breach

actions.onHardBreach uyarınca reject veya defer.

Ayrıca hedge.suggestion üret (ör. en büyük korelasyonlu açık pozisyonda scale_out 25%).

Algoritma (Akış)

Tazelik & Bağlam

Risk modeli age > modelMaxAgeSec → defer("stale_risk_model").

Exposure age > exposureMaxAgeSec → defer("stale_exposure").

Kümeler/Beta Override

mapping.meta.overrides ile sembol özelliklerini güncelle.

Sert Limitler

Total/Per-Symbol aşımı → rejected (total_cap_exceeded/per_symbol_cap).

Hard pair corr → rejected("hard_pair_corr").

Yumuşak Limitler & MRC

Soft pair/cluster/factor/imbalance ihlallerinde downscale döngüsü.

mrc ≤ eşik olduğunda adjusted yayınla.

Temiz Onay

Hiçbiri tetiklenmediyse approved.

Hedge Önerileri (opsiyonel)

Cluster overflow veya beta aşımı varsa, en büyük katkı yapan açık pozisyonlar için portfolio.hedge.suggestion.

Telemetri

portfolio.balancer.metrics 10 sn: {approved, adjusted, deferred, rejected, avg_scale, top_corr_pair}.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/portfolioExposureBalancer.ts

src/vivo/state/portfolioStore.ts (model+exposure+policy cache)

src/vivo/lib/corr.ts (rho fetch & default), src/vivo/lib/mrc.ts (marginal risk)

__tests__/portfolioExposureBalancer.test.ts

Mimari

Saf çekirdek: balance(intent, state, policy, cfg) → Emission[].

I/O adaptörü: bus subscribe/publish; state persist; freshness kontrolleri.

Validasyon

Zod şemaları; sayısal alanlar finite(); unknown alanlar ignore + warn.

Idempotency

Aynı correlationId için tekrarı engelle (WAL/idempotent key).

Performans

N açık pozisyon için O(N) değerlendirme; rho lookup cache’li.

Test İskeleti (Jest)

total cap exceeded → rejected(total_cap_exceeded)

per-symbol cap exceeded → rejected(per_symbol_cap)

hard pair corr (ρ≥0.85 same direction) → rejected(hard_pair_corr)

soft pair corr (ρ≥0.70) → adjusted(scaleFactor<1)

cluster cap near → adjusted ve clusterExposure sınır içinde

factor beta over → adjusted veya rejected(beta_over) (policyye göre)

imbalance > cap → adjusted/rejected (netLong-netShort düzeltilir)

stale model/exposure → deferred

marginal risk > limit → adjusted until ≤ limit or reject if <minFactor

no issues → approved (risk pct unchanged)

Örnek Senaryo (Özet)

Durum

Açıklar:

ETHUSDT long 0.7% (cluster=Layer1, ρ(ETH,BTC)=0.79)

BTCUSDT long 0.6% (cluster=BTCComplex)

Toplam açık risk: 1.3%

Politika: total=2.0%, perSymbol=0.8%, perCluster.Layer1=1.2%, softPair≥0.70, hardPair≥0.85

Risk modeli: ρ(AVAX,ETH)=0.82, ρ(AVAX,BTC)=0.68, beta_AVAX.BTC=0.84

Yeni niyet: AVAXUSDT long, riskPerTradePct_candidate=0.7%, cluster=Layer1

Hesap

Total sonrası: 1.3 + 0.7 = 2.0 → total OK.

Cluster Layer1: ETH 0.7 + AVAX 0.7 = 1.4% > 1.2% → cluster soft breach.

Pair corr: ρ(AVAX,ETH)=0.82 ≥ soft (0.70) ve < hard (0.85) → soft pair.

MRC başlangıçta yüksek → downscale: 0.7 → 0.55 → 0.50 (iteratif).

0.50% ile Cluster: 1.2% tam dolar; MRC ≤ eşik.

Beklenen Çıktı

{
  "event":"portfolio.intent.adjusted",
  "symbol":"AVAXUSDT","side":"long",
  "riskPerTradePctOriginal":0.7,
  "riskPerTradePctAdjusted":0.5,
  "scaleFactor":0.714,
  "reasonCodes":["cluster_cap_tight","soft_pair_corr","mrc_capped"],
  "correlationNotes":{"topPairs":[{"symbol":"ETHUSDT","rho":0.82}]}
}


Opsiyonel:

{
  "event":"portfolio.hedge.suggestion",
  "suggestions":[{"action":"scale_out","symbol":"ETHUSDT","ratio":0.25,"reason":"cluster_overflow"}],
  "rationale":["reduce Layer1 exposure from 1.4% to 1.2%"]
}

Entegrasyon Notları

Sıra: execution.intent.accepted (VIVO-18) → VIVO-25 balancer → (gerekirse ayarlanmış riskPct ile) VIVO-19 composer.

Yükseltme yok: Balancer riskPct’yi yalnızca ↓ azaltır (veya değişmez).

VIVO-17 bu modülden adjusted/rejected oranlarını izleyip allowedVariants ve confirmationThreshold önerilerini şekillendirebilir.

Risk Incident Reporter (VIVO-23) ile uyum: aşırı korelasyon/hard ihlaller incident tetikleyebilir.
_________________________________________________________________________________________________________________
VIVO-26 · latencyAndSlippageGuard.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Gerçek zamanlı slipaj ve gecikme ölçümlerine göre işlem akışını geçici olarak kısıtlamak:

Aşırı slipaj anlarında market failover’ı kapat, post-only/limit dayat, bekleyen girişleri iptal/ertele.

Yerleştirme/ilk dolum gecikmesi yükselirse yavaşlat (slowdown), aggressive varyantı geçici kapat.

Akış/WS gecikmesi veya kalp atışı (heartbeat) zayıfladığında halt_entry (yeni girişleri durdur) ve açık emirleri güvenle kapat.

Yetki alanı: Sadece kısıtlama/ertleme/iptal uygular; risk büyütmez, bütçe genişletmez.

Girdiler (Event / JSON Şemaları)
// order.placement.result — VIVO-20’dan yerleştirme latencies
{
  "event": "order.placement.result",
  "timestamp": "iso8601",
  "correlationId": "string",
  "results": [
    {"clientOrderId":"string","exchangeOrderId":"string","status":"accepted|rejected","reason":"string|null","placeLatencyMs":"number"}
  ],
  "symbol": "string",
  "side": "long|short",
  "variant": "base|aggressive|conservative"
}

// order.update — fill/trigger ve slipaj sinyali
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number",
  "firstFillLatencyMs": "number|null"
}

// market.refs — spread/vol bağlamı
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "spreadBps": "number",
  "volZScore": "number"
}

// connectivity.heartbeat — ağ/WS sağlığı
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean"
}

// policy.snapshot — üst sınırlar (okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"},
  "slippageHardBps": 15,
  "latencyHardMs": 1800
}

// order.plan.proposed — (opsiyonel) plan görünümü (failover modu vs)
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "entryPlan": {"mode":"market|limit|stop_market|stop_limit","legs":[{"type":"string","ttlSec":"number","failover":"none|market|price_step_escalation"}]},
  "risk": {"maxSlipBps":"number"},
  "audit": {"variant":"base|aggressive|conservative"}
}

Çıktılar (Guard Direktifleri & Eylemler)
// Muhafaza direktifi (VIVO-18/19/20/21 tarafından dikkate alınır)
{
  "event": "latency_slip.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|slowdown|block_aggressive|halt_entry|cancel_open_orders",
  "scope": {"symbol":"string|null","variant":"base|aggressive|conservative|null"},
  "expiresAt": "iso8601",
  "actions": [
    "disallow_market_failover",
    "force_post_only",
    "cap_slippage_bps",
    "defer_new_entries",
    "cancel_pending_entries"
  ],
  "limits": {"maxSlippageBps":"number","maxNewEntriesPerMin":"number"},
  "reasonCodes": ["string"]
}

// Tek emre yönelik anlık override (execution manager okur)
{
  "event": "execution.policy.override",
  "timestamp": "iso8601",
  "correlationId": "string",
  "directives": {
    "failover":"none|price_step_escalation",   // market failover kapatılır ya da step'e çevrilir
    "postOnly": true,
    "maxSlippageBps": "number"
  },
  "reasonCodes": ["string"]
}

// Telemetri ve uyarı
{
  "event": "latency_slip.guard.metrics",
  "timestamp": "iso8601",
  "ewma": {"placeMs":"number","firstFillMs":"number","slipBps":"number","spreadBps":"number"},
  "modeRates": {"normal":"number","slowdown":"number","block_aggressive":"number","halt_entry":"number"},
  "panicCount": "number"
}
{
  "event": "latency_slip.guard.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string|null","reasonCodes":["string"]}
}

TypeScript Arayüzleri (ürettir)

PlacementResult, OrderUpdate, MarketRefs, ConnectivityHeartbeat, PolicySnapshot, OrderPlanProposed.

Çıkışlar: GuardDirective, ExecutionPolicyOverride, GuardMetrics, GuardAlert.

Yardımcı: EwmaTracker, GuardState, Hysteresis, ScopeKey (symbol|* + variant|*).

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: order.placement.result, order.update, market.refs, connectivity.heartbeat, policy.snapshot, order.plan.proposed

Out: latency_slip.guard.directive, execution.policy.override, latency_slip.guard.metrics, latency_slip.guard.alert

Konfig & Varsayılanlar
{
  // Eşikler (variant’a göre)
  slipWarnBps: { aggressive: 10, base: 8, conservative: 6 },
  slipPanicBps: 15,                            // policy.slippageHardBps ile clamp
  placeLatencyWarnMs: 800,
  firstFillLatencyWarnMs: 1200,
  streamLatencyWarnMs: 700,
  panicWhenStreamsDeadMs: 8000,

  // Histerezis (çırpınmayı önlemek)
  hysteresis: { exitPct: 0.75, minHoldSec: 60 },

  // Slowdown etkileri
  slowdown: { maxNewEntriesPerMin: 1, expireSec: 300 },

  // Mod süreleri
  ttlSec: { block_aggressive: 900, halt_entry: 600, cancel_open_orders: 120 },

  // EWMAs
  ewmaHalfLife: { slip: 10, placeMs: 8, firstFillMs: 8, spread: 6 },

  // Aksiyon haritası
  overrides: {
    onSlipWarn: ["disallow_market_failover", "cap_slippage_bps"],
    onSlipPanic: ["cancel_pending_entries", "defer_new_entries"],
    onLatencyWarn: ["force_post_only", "disallow_market_failover"],
    onStreamsPanic: ["halt_entry", "cancel_open_orders"]
  },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

GuardStateStore (in-memory + periyodik persist data/latency_slip.guard.json):

perScope (symbol/variant/*) EWMA: slipBps, placeMs, firstFillMs, spreadBps.

Aktif mod ve expiresAt, enteredAt, reasonCodes[].

Hysteresis: modu sonlandırma eşiği, minimum bekleme.

Günlük sayaçlar: panicCount, slowdownSeconds.

Algoritma (Karar Akışı)

Ölçümleri Güncelle

Her order.update.lastFillSlipBps → ewma.slipBps.

order.placement.result.placeLatencyMs → ewma.placeMs.

order.update.firstFillLatencyMs → ewma.firstFillMs.

market.refs.spreadBps → ewma.spreadBps.

Akım Sağlığı

connectivity.heartbeat: stream’ler down veya latencyMs > streamLatencyWarnMs → latency_warn.

marketStreamAlive==false || orderStreamAlive==false ve now - lastHeartbeat > panicWhenStreamsDeadMs → streams_panic.

Eşik Değerlendirme (Variant’a göre)

ewma.slipBps ≥ slipWarnBps[variant] → SlipWarn.

lastFillSlipBps ≥ slipPanicBps (tekil olay) veya ewma.slipBps ≥ slipPanicBps*0.9 → SlipPanic.

ewma.placeMs ≥ placeLatencyWarnMs veya ewma.firstFillMs ≥ firstFillLatencyWarnMs → LatencyWarn.

Mod Seçimi (Öncelik)
streams_panic → halt_entry (+ cancel_open_orders)
SlipPanic → block_aggressive + cancel_pending_entries
LatencyWarn → slowdown + force_post_only
SlipWarn → disallow_market_failover + cap_slippage_bps
(Birden fazla tetik varsa en sert mod seçilir.)

Histerezis & Süre

Mod aktifse minHoldSec dolmadan düşürme.

Ölçümler exitPct oranında normale dönünce modu normal’a indir; aksi halde expiresAt’a dek sürdür.

Eylemler & Yayın

Scope: mümkünse symbol+variant, değilse global (*).

GuardDirective yayınla (mode, actions, limits, expiresAt).

Eğer spesifik bir order.plan.proposed görünüyorsa, order bazında execution.policy.override da gönder:

failover: none|price_step_escalation, postOnly: true, maxSlippageBps = min(plan.risk.maxSlipBps, slipWarnBps[variant]).

Panik Durumu

streams_panic → latency_slip.guard.alert(level="error", reason="streams_panic"),
ardından halt_entry ve cancel_open_orders direktifleri.

Telemetri

10 sn’de bir latency_slip.guard.metrics (EWMA’lar, mod oranları, panicCount).

Gerçek Dünya Kuralları (Uyum)

Risk artırma yok: maxSlippageBps sadece azaltılır; failover kapatılır veya step-escalation’a çevrilir.

Reduce-only disiplinine saygı: Bekleyen giriş iptalleri pozisyon kapatmaz; kapatma kararı VIVO-21’dedir.

Variant yönetimi: block_aggressive modunda aggressive varyant sisteme giriş yapamaz (Throttler ve Router dinler).

Sessiz saatler + yüksek spread birlikteyse eşikler daha katı yorumlanabilir (opsiyonel: +10% sıkılaştır).

Idempotency: Aynı moda aynı scope için tekrar direktif gönderme (hash/debounce).

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/latencyAndSlippageGuard.ts

src/vivo/state/guardStore.ts (persist + histerezis)

src/vivo/lib/ewma.ts, src/vivo/lib/hysteresis.ts

__tests__/latencyAndSlippageGuard.test.ts

Mimari

Saf çekirdek: evaluate(event, state, cfg) → emissions[]

I/O adaptörü: bus subscribe/publish + state persist

Validasyon

Zod şemaları; sayısal alanlar finite(); negatif/NaN → event drop + alert.

Performans

p99 < 5ms hedef; EWMA güncellemesi O(1).

Gün Sonu Reset

Sayaçlar ve moda ilişkin metrikler Europe/Istanbul gün sonunda sıfırlanır.

Test İskeleti (Jest)

slipWarn → directive(disallow_market_failover, cap_slippage_bps)

slipPanic (tekil ≥ hard) → block_aggressive + cancel_pending_entries

placeLatencyWarn → slowdown + force_post_only

streams_panic → halt_entry + cancel_open_orders + alert(error)

hysteresis exitPct çalışır, minHoldSec dolmadan mod düşmez

execution.policy.override maxSlippageBps ≤ plan.maxSlipBps

idempotent directive (aynı mod & scope) → tek yayın

variant=aggressive iken block_aggressive aktif → throttler yeni niyeti reddeder (simüle)

Örnek Senaryo (Özet)

Durum

variant="aggressive", son 6 fill’de slipEWMA ≈ 11 bps (warn üstü), tek bir fill 17 bps (panic).

placeLatencyEWMA = 900 ms, firstFillEWMA = 1400 ms.

market.refs.spreadBps=28, WS alive fakat latencyMs=800ms.

Beklenen Yayınlar

{
  "event":"latency_slip.guard.directive",
  "mode":"block_aggressive",
  "scope":{"symbol":"*","variant":"aggressive"},
  "expiresAt":"...+PT15M",
  "actions":["cancel_pending_entries","disallow_market_failover","cap_slippage_bps"],
  "limits":{"maxSlippageBps":10},
  "reasonCodes":["slip_panic","latency_warn","wide_spread"]
}


Ayrıca yeni plana spesifik:

{
  "event":"execution.policy.override",
  "correlationId":"LINKUSDT-long-...",
  "directives":{"failover":"price_step_escalation","postOnly":true,"maxSlippageBps":10},
  "reasonCodes":["guard_active_block_aggressive"]
}


Durum normale döndüğünde histerezis koşullarıyla mode: "normal" direktifi gönderilir.

Entegrasyon Notları

VIVO-18 Throttler: block_aggressive ve halt_entry direktiflerini dinleyip kararlarını sıkılaştırır.

VIVO-19 Composer: execution.policy.override ile failover/post-only/slip tavanını uygular.

VIVO-20 Execution Manager: tekil emir override’larını zorunlu uygular; slipaj aşımında cancel/replace davranır.

VIVO-21 Supervisor: halt_entry aktifken açık pozisyonları korur; kapatma kararı Supervisor’dadır.
_________________________________________________________________________________________________________________
VIVO-27 · exchangeConnectivitySentry.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Borsa WS/REST bağlantılarının sağlığını izlemek, sequence gap (sıra atlaması) yakalamak, snapshot→replay ile akışı yeniden senkronize etmek.

Clock drift (yerel saat ↔ borsa saati) ölçüp düzeltmek.

Otomatik yeniden bağlanma, uç nokta (primary→secondary) failover, devre kesici (circuit breaker) ve backoff+jitter politikalarını uygulamak.

Sorun anında üst katmanlara net, uygulanabilir direktifler üretmek (ör. “streams_panic → halt_entry”, “resubscribe”, “switch_endpoint”).

VIVO-26 (Latency/Slippage Guard), VIVO-20 (Execution Manager) ve VIVO-21 (Supervisor) ile uyumlu sinyaller yayınlamak.

Bu modül sadece bağlantı/akış bütünlüğünden sorumludur; emir ve risk mantığına dokunmaz.

Girdiler (Event / JSON Şemaları)
// config.exchange.endpoints — uç noktalar ve abone setleri
{
  "event": "config.exchange.endpoints",
  "timestamp": "iso8601",
  "primary": {"wsUrl":"wss://...", "restUrl":"https://..."},
  "secondary": {"wsUrl":"wss://backup...", "restUrl":"https://backup..."},
  "subscriptions": [
    {"channel":"bookTicker","symbols":["BTCUSDT","ETHUSDT","AVAXUSDT"]},
    {"channel":"aggTrades","symbols":["BTCUSDT"]},
    {"channel":"depth@100ms","symbols":["BTCUSDT","ETHUSDT"], "snapshotRestPath":"/api/depth?symbol=${sym}&limit=1000"}
  ],
  "auth": {"apiKeyId":"string","scope":"read_public"},
  "heartbeat": {"intervalMs": 1000, "timeoutMs": 4000}
}

// external.trigger.resubscribe — üst katman manuel tetikleyebilir
{
  "event": "external.trigger.resubscribe",
  "timestamp": "iso8601",
  "reason": "manual|policy_change|symbol_rotation",
  "note": "string|null"
}

// order.update / market.refs (pasif dinlenir — tazelik ölçümüne katkı)
// (şemalar önceki modüllerde tanımlı; burada yalnızca timestamp'leri kullanılır)

Çıktılar (Sentry Olayları & Direktifler)
// Sağlık nabzı (ust katmanlar VIVO-26/21 bunu tüketir)
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",                 // serverTime ping roundtrip EWMA
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean",
  "wsEndpoint": "primary|secondary",
  "clockSkewMs": "number"                // local-now - exchangeServerTime
}

// WS bağlantı durumu
{
  "event": "sentry.ws.status",
  "timestamp": "iso8601",
  "status": "connecting|open|closing|closed|failed",
  "endpoint": "primary|secondary",
  "sessionId": "string",
  "reason": "string|null",
  "attempt": "number"
}

// Abonelik/senkronizasyon akışı
{
  "event": "sentry.subscription.status",
  "timestamp": "iso8601",
  "channel": "bookTicker|aggTrades|depth@100ms|custom",
  "symbol": "string|null",
  "state": "subscribed|unsubscribed|resyncing|snapshot_loaded",
  "detail": "string|null"
}

// Sequence gap tespiti (ör. order book/aggTrades)
{
  "event": "sentry.sequence.gap",
  "timestamp": "iso8601",
  "channel": "depth@100ms|aggTrades|...",
  "symbol": "string",
  "expectedSeq": "number",
  "receivedSeq": "number",
  "gapSize": "number",
  "action": "replay|resnapshot|switch_endpoint"
}

// Kurtarma aksiyonları (üst katmanlar bilgilensin)
{
  "event": "sentry.recovery.action",
  "timestamp": "iso8601",
  "action": "resubscribe|reload_snapshot|replay_from|switch_endpoint|reconnect",
  "endpoint": "primary|secondary",
  "context": {"channel":"string","symbol":"string|null","fromSeq":"number|null"},
  "reasonCodes": ["string"]
}

// Sentry direktifi (guard’lara köprü)
{
  "event": "sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic",
  "expiresAt": "iso8601",
  "reasonCodes": ["clock_drift_high","sequence_gap_repeated","ws_flaps","no_heartbeat"],
  "hints": {"suggestHaltEntry": true, "suggestCancelOpenOrders": false}
}

// Metrik & alarm
{
  "event": "sentry.metrics",
  "timestamp": "iso8601",
  "ewma": {"pingMs":"number","wsMsgsPerSec":"number"},
  "gaps": {"count":"number","avgGap":"number"},
  "reconnects": "number",
  "endpointSwitches": "number"
}
{
  "event": "sentry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"endpoint":"primary|secondary","reason":"string","sessionId":"string"}
}

İç Veri & Yardımcı Akışlar (Sentry yönetir)
// depth.snapshot.cached — REST'ten alınan anlık snapshot (persist için opsiyonel)
{
  "event": "depth.snapshot.cached",
  "timestamp": "iso8601",
  "symbol": "string",
  "lastUpdateId": "number"
}

// depth.delta.applied — delta uygulandı (sequence tutarlılığı doğrulandı)
{
  "event": "depth.delta.applied",
  "timestamp": "iso8601",
  "symbol": "string",
  "prevSeq": "number",
  "newSeq": "number",
  "appliedCount": "number"
}

TypeScript Arayüzleri (ürettir)

EndpointsConfig, SubscriptionSpec, HeartbeatCfg, WsStatus, SubscriptionStatus.

SequenceGap, RecoveryAction, SentryGuardDirective, SentryMetrics, SentryAlert.

Yardımcı: ConnectionState, BackoffPlan, CircuitBreaker, SeqTracker (per channel+symbol), ClockSkewTracker.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: config.exchange.endpoints, external.trigger.resubscribe

Out: connectivity.heartbeat, sentry.ws.status, sentry.subscription.status,
sentry.sequence.gap, sentry.recovery.action, sentry.guard.directive,
sentry.metrics, sentry.alert, depth.snapshot.cached, depth.delta.applied

Konfig & Varsayılanlar
{
  // Bağlantı
  reconnectBackoffMs: [300, 600, 1200, 2500, 5000],  // + jitter %20
  circuitBreaker: { failThreshold: 5, openMs: 30000, halfOpenProbes: 2 },

  // Snapshot / replay
  depth: { snapshotTTLms: 120000, maxReplayBatch: 2000, gapHard: 500, gapSoft: 50 },

  // Saat
  clock: { pingIntervalMs: 2000, driftWarnMs: 800, driftPanicMs: 2000 },

  // Sağlık
  heartbeat: { intervalMs: 1000, timeoutMs: 4000 },
  msgRateWarnPerSec: 120,         // spam/sel taşması için uyarı
  wsFlapWarnCount: 3,             // 10 dk içinde

  // Failover
  switchToSecondaryOn: { repeatedGaps: 3, reconnectsIn10m: 4, driftPanic: true },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

ConnectionStateStore (in-memory + periyodik persist data/sentry.state.json):

endpoint (primary/secondary), status, sessionId, attempt, lastOpenAt.

circuitBreakerState.

seqTrackers (Map: channel|symbol → {lastSeq, gapsCount, lastGapAt}).

clockSkewTracker (EWMA).

Son heartbeatAt, wsFlapCounter, endpointSwitches, reconnects.

Idempotency: sessionId + monotonik seq eşleşmesiyle yeniden işlemede çift yayın önlenir.

Algoritma (Karar Akışı)

Başlat / Bağlan

config.exchange.endpoints alınır → WS CONNECT (primary). sentry.ws.status("connecting") yayınla.

Başarılı: status:"open", sessionId üret. Tüm subscriptions gönder, her biri için subscription.status("subscribed").

Heartbeat & Ping

Her heartbeat.intervalMs → serverTime ping (REST/time veya WS ping-pong).

clockSkewMs = localNow - serverTime.

> driftWarnMs → sentry.guard.directive(mode="degraded", reason="clock_drift_high").

> driftPanicMs → mode="streams_panic" + sentry.alert(error).

Sequence Takibi

depth/aggTrades delta paketlerinde seqTracker kontrol:

Soft gap (gap ≤ gapSoft) → replay_from (buffer’da varsa uygula).

Hard gap (gap ≥ gapHard) → resnapshot (REST snapshot al, lastUpdateId ≥ beklenen; ardından replay).

Tekrarlayan arızalar (≥ switchToSecondaryOn.repeatedGaps) → switch_endpoint(secondary).

Snapshot→Replay Süreci

reload_snapshot çağır → REST’ten snapshot çek, depth.snapshot.cached yayınla.

WS’den gelen delta’ları lastUpdateId üstüne sırayla uygula; her uygulamada depth.delta.applied.

Zaman aşımı/başarısızlıkta reconnect + resubscribe.

Reconnect & Failover

WS kapanırsa: reconnectBackoffMs[attempt] + jitter ile yeniden bağlan.

circuitBreaker açıkken sadece halfOpenProbes dene.

10 dakikada reconnects ≥ N veya driftPanic → switch to secondary; endpointSwitches++.

Flapping (Sık Aç-Kapa)

Son 10 dk’da wsFlapWarnCount aşılırsa: sentry.guard.directive(mode="degraded", reason="ws_flaps") ve slow resubscribe (kademeli).

Dış Tetikleyici

external.trigger.resubscribe → mevcut oturumda tam resubscribe; policy değiştiyse yeni sembol setiyle abone ol.

Timeout / No Heartbeat

now - lastHeartbeat > heartbeat.timeoutMs → sentry.guard.directive(mode="streams_panic", reason="no_heartbeat"), ardından reconnect.

Telemetri

10 sn’de bir sentry.metrics: EWMA ping, msgRate, gaps, reconnects, endpointSwitches.

Gerçek Dünya Kuralları (Uyum)

Deterministik tekrar: Aynı sessionId altındaki yeniden yayınlar idempotent olmalı.

Güvenli varsayılan: Senkronizasyon şüpheliyse trade etmeyin sinyali: sentry.guard.directive(mode="streams_panic").

Snapshot TTL: Eski snapshot ile replay yapma; TTL aşılırsa tekrar indir.

Saat disiplini: Clock drift düzeltme yalnızca ölçümdür; OS saatini değiştirme. Üst katmanlara uyarı/direktif ver.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/exchangeConnectivitySentry.ts

src/vivo/state/sentryStore.ts (persist + circuit breaker + seq trackers)

src/vivo/lib/backoff.ts, src/vivo/lib/seqTracker.ts, src/vivo/lib/clockSkew.ts

__tests__/exchangeConnectivitySentry.test.ts

Mimari

Saf çekirdek: advance(state, event, cfg) → emissions[] (deterministik state machine).

IO adaptörü: gerçek WS/REST client, subscribe/unsubscribe/snapshot çağrıları; event bus publish/subscribe.

Validasyon

Zod ile tüm dış olaylar; sayı alanları finite(); endpoint URL’leri non-empty.

Performans

p99 döngü < 5ms (WS event başına). Replay’de backpressure uygula (batch boyutu).

Idempotency & Debounce

Aynı recovery.action’ı aynı bağlamda art arda göndermeyi engelle (hash/time debounce).

Gün Sonu

Sayaçlar Europe/Istanbul gün sonunda sıfırlanır (metrics reset).

Test İskeleti (Jest)

soft gap → replay_from ve depth.delta.applied sıralı ilerler.

hard gap → resnapshot + replay ve akış senkronize olur.

no heartbeat > timeoutMs → streams_panic + reconnect.

clock drift > driftPanicMs → streams_panic + endpoint switch (policy uygunsa).

ws flapping (≥3/10m) → degraded + slow resubscribe.

reconnect backoff & circuit breaker doğru uygulanır.

external.trigger.resubscribe tam abonelik yeniler.

idempotent recovery.action tekrar yayınlanmaz.

Örnek Senaryo (Özet)

Durum

Primary WS açık, depth@100ms(BTCUSDT) için expectedSeq=102340, gelen 102297 → gap=43 (soft)

Ardından bir paket daha kaçtı: received=101700 → gap=640 (hard)

serverTime ping EWMA=920 ms, clockSkew=+2300 ms (panic)

Beklenen Yayınlar

{"event":"sentry.sequence.gap","channel":"depth@100ms","symbol":"BTCUSDT","expectedSeq":102340,"receivedSeq":102297,"gapSize":43,"action":"replay"}

{"event":"sentry.sequence.gap","channel":"depth@100ms","symbol":"BTCUSDT","expectedSeq":102340,"receivedSeq":101700,"gapSize":640,"action":"resnapshot"}

{"event":"sentry.recovery.action","action":"reload_snapshot","endpoint":"primary","context":{"channel":"depth@100ms","symbol":"BTCUSDT","fromSeq":null},"reasonCodes":["hard_gap"]}

{"event":"sentry.guard.directive","mode":"streams_panic","expiresAt":"...+PT10M","reasonCodes":["clock_drift_high"],"hints":{"suggestHaltEntry":true,"suggestCancelOpenOrders":false}}


(Sonrasında policy uygunsa secondary’e geçilir ve subscription.status akışı yeniden kurulur.)

Entegrasyon Notları

VIVO-26: connectivity.heartbeat ve sentry.guard.directive sinyallerine göre halt_entry / slowdown modlarını tetikler.

VIVO-20/21: streams_panic aktifken yeni giriş yapmaz; Supervisor açık pozisyonları korur.

VIVO-27 başka borsaya geçişi (çoklu adapter) destekleyecek şekilde genişletilebilir (opsiyonel multi-exchange).
_________________________________________________________________________________________________________________
VIVO-28 · fundingAndFeesForecaster.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Perp funding (8s/4s/1s periyotlu) ve işlem ücretleri (maker/taker, VIP tier, indirim token’ı vb.) için kısa vadeli maliyet tahmini üretmek.

Planlanan veya açık işlemler için beklenen maliyet bütçesi (fees+funding) ile planlanan R’ı karşılaştırıp uyarı/tavsiye yayınlamak.

Funding saati pencereleri öncesi/sonrası için “kaçın/uygula/değiştir” önerileri üretmek (ör. “funding +35 bp8h, 22 dk kaldı → giriş ertele”).

VIVO-19 (composer), VIVO-21 (supervisor) ve VIVO-26 (latency/slip guard) gibi modüllere uygulanabilir sinyaller sağlamak.

Bu modül yalnızca maliyetleri tahmin/rapor eder; emir/pozisyon yönetimi yapmaz.

Girdiler (Event / JSON Şemaları)
// funding.snapshot — borsadan periyodik alınan funding verileri
{
  "event": "funding.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "period": "8h|4h|1h",
  "lastFundingRateBp": "number",     // ör: +3.2 (bp/period)
  "nextFundingTime": "iso8601",
  "predictedNextRateBp": "number|null",
  "basisBp": "number|null",          // mark-index yıllıklaştırılmış bazis (bps/yıl)
  "oiChangePct": "number|null"       // open interest % değişimi (son periyot)
}

// fees.schedule — maker/taker ve indirim bilgileri
{
  "event": "fees.schedule",
  "timestamp": "iso8601",
  "tradeMode": "spot|usdm|coinm",
  "vipTier": "number",
  "makerFeeBp": "number",            // bp (1 bp = 0.01%)
  "takerFeeBp": "number",
  "discounts": {"token":"string|null","enabled":true,"extraMakerBp":-0.5,"extraTakerBp":-0.5}
}

// account.tradingStats — kullanıcı hacmi ve beklenen tier değişimi
{
  "event": "account.tradingStats",
  "timestamp": "iso8601",
  "last30dVolumeUSD": "number",
  "projectedVipTierInHours": "number|null"
}

// order.plan.proposed — yeni plan (VIVO-19) → maliyet değerlendirmesi için
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [{"type":"string","qty":"number","price":"number|null","ttlSec":"number"}]
  },
  "protection": {
    "stopLoss": {"price":"number"},
    "takeProfit": [{"ratio":"number","price":"number"}]
  },
  "risk": {"riskPerTradePct":"number","plannedRR":"number"},
  "audit": {"variant":"base|aggressive|conservative","tpSlStyle":"ATR|range|hybrid"}
}

// position.snapshot — açık pozisyonlar (funding etki süresi için)
{
  "event": "position.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeId": "string",
  "qtyOpen": "number",
  "avgPrice": "number",
  "tradeMode": "usdm|coinm|spot",
  "entryTime": "iso8601"
}

// market.refs — bağlam (gerektiğinde; basis ve spread teyidi)
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "spreadBps": "number",
  "volZScore": "number"
}

Çıktılar (Tahmin, Bütçe ve Uyarılar)
// Maliyet tahmini (instrument-level)
{
  "event": "cost.forecast.update",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeMode": "spot|usdm|coinm",
  "fee": {"makerBp":"number","takerBp":"number","effectiveMakerBp":"number","effectiveTakerBp":"number"},
  "funding": {
    "period": "8h|4h|1h",
    "nextFundingTime": "iso8601",
    "predictedNextRateBp": "number|null",
    "windowMinutesToFunding": "number",
    "signHint": "pay_long|pay_short|neutral"
  },
  "derived": {
    "basisBpAnnual":"number|null",
    "riskLevel": "low|elevated|high"        // funding+basis'e bağlı sınıflandırma
  }
}

// Plan bazlı maliyet/bütçe karşılaştırması (VIVO-19 planına advisory)
{
  "event": "cost.budget.advice",
  "timestamp": "iso8601",
  "correlationId": "string|null",
  "symbol": "string",
  "side": "long|short",
  "plannedRR": "number",
  "assumptions": {
    "fillStyle": "maker|taker|mixed",
    "expectedHoldMinutes": "number"       // supervisor veya geçmişten tahmin
  },
  "expectedCosts": {
    "feesBp": "number",                    // notional'a göre
    "fundingBp": "number",                 // beklenen hold süresine göre
    "totalBp": "number",
    "totalPctOfPlannedR": "number"         // (maliyet / (plannedRR*riskUnit)) normalize edilmiş oran
  },
  "recommendations": [
    "prefer_maker_post_only",
    "avoid_opening_within_20m_to_funding",
    "short_bias_ok_funding_positive",
    "reduce_hold_to_45m",
    "switch_to_spot_if_possible"
  ],
  "severity": "info|warn|block",
  "reasonCodes": ["high_funding_window","high_taker_fee","rr_eroded"]
}

// Açık pozisyonlar için funding yaklaşırken uyarı/aksiyon penceresi
{
  "event": "cost.window.supervisorHint",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeId": "string",
  "minutesToFunding": "number",
  "suggest": ["tighten_trailing","scale_out_25","close_before_funding"],
  "reasonCodes": ["funding_spike_risk"]
}

// Aşırı maliyet/uygunsuz plan durumunda alarm
{
  "event": "cost.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string","correlationId":"string|null","reasonCodes":["string"]}
}

// Telemetri
{
  "event": "cost.forecaster.metrics",
  "timestamp": "iso8601",
  "avgAdviceMs": "number",
  "adviceRates": {"info":"number","warn":"number","block":"number"},
  "makerUsageSuggestRate": "number",
  "fundingWindowAvoidRate": "number"
}

TypeScript Arayüzleri (ürettir)

FundingSnapshot, FeesSchedule, AccountTradingStats, OrderPlanProposed, PositionSnapshot, MarketRefs.

CostForecastUpdate, CostBudgetAdvice, CostWindowSupervisorHint, CostAlert, CostForecasterMetrics.

Yardımcı: HoldEstimatorInput/Output, EffectiveFeeCalc, FundingCostCalc, AdviceSeverity.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: funding.snapshot, fees.schedule, account.tradingStats, order.plan.proposed, position.snapshot, market.refs

Out: cost.forecast.update, cost.budget.advice, cost.window.supervisorHint, cost.alert, cost.forecaster.metrics

Konfig & Varsayılanlar
{
  // Funding penceresi eşikleri
  fundingWindow: { warnMin: 30, blockMin: 10 },     // funding'e kalan dakika
  fundingRiskBp: { elevated: 20, high: 35 },        // bp/period (mutlak)

  // Ücretler ve varsayım
  defaultFillStyle: "mixed",                        // maker %40, taker %60
  makerShare: 0.4,
  takerShare: 0.6,

  // Beklenen tutuş süresi (hold) modeli (dk)
  holdEstimator: { fallbackMin: 90, useSupervisorPath: true },

  // R’a göre bütçe sınırları
  costAsPctOfPlannedR: { warn: 0.25, block: 0.45 }, // maliyet / beklenen R

  // Spot geçiş önerisi
  suggestSpotIfCostly: true,

  // Tier projeksiyonu
  tierProjectionHorizonMin: 240,                    // 4 saat içinde tier düşecekse beklensin mi?

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Hesaplamalar (Formüller)

Effective Fee (bp)

makerEff = makerFeeBp + (discounts?.extraMakerBp || 0)

takerEff = takerFeeBp + (discounts?.extraTakerBp || 0)

Mixed: feesBp = makerEff * makerShare + takerEff * takerShare

Maker/Taker: feesBp = makerEff veya takerEff

Funding Cost (bp)

bp_per_period = predictedNextRateBp ?? lastFundingRateBp

holdPeriods = expectedHoldMinutes / periodMinutes

Signed cost:

long → fundingBp = +bp_per_period * holdPeriods (pozitif BP = long öder)

short → fundingBp = -bp_per_period * holdPeriods

Notional’a göre parasal etkiler VIVO-22 (logger) tarafında hesaplanır; burada bp raporlanır.

Total Cost & R Karşılaştırması

totalBp = feesBp + fundingBp

totalPctOfPlannedR = |totalBp| / (plannedRR * 10000) (R → bp çevirimi: 1R ≈ 10000bp* riskUnit varsayımı yoksa normalize amaçlı oran; burada oran raporlanır)

Eşikler: warn ve block.

Risk Seviyesi & Pencere

minutesToFunding = diff(nextFundingTime, now)

riskLevel =

high if |bp_per_period| ≥ fundingRiskBp.high

elevated if ≥ fundingRiskBp.elevated

else low

signHint = pay_long (bp>0) | pay_short (bp<0) | neutral.

Algoritma (Karar Akışı)

State Güncelle

Son funding.snapshot, fees.schedule, account.tradingStats ve market.refs değerlerini cache’le.

fees.schedule geldiğinde effective maker/taker bp’lerini hesaplayıp sakla.

Instrument Forecast

Her yeni funding.snapshot → cost.forecast.update yayınla (risk seviyesi, pencere, signHint).

Plan Değerlendirme (order.plan.proposed)

Assumptions.fillStyle: defaultFillStyle veya plan moduna göre tahmin (market → taker, limit → maker bias).

Expected hold: config/position.snapshot/VIVO-21 izlerinden tahmin (yoksa fallbackMin).

Costs: feesBp + fundingBp → totalPctOfPlannedR karşılaştır.

Seviye:

block eşiği aşılırsa: recommendations += ["avoid_opening_within_Xm_to_funding","prefer_maker_post_only","reduce_hold"]

warn ise: tavsiyeler, severity="warn".

low ise: severity="info".

Spot geçişi: tradeMode usdm|coinm ve suggestSpotIfCostly + totalPctOfPlannedR ≥ block → "switch_to_spot_if_possible" öner.

Açık Pozisyon Penceresi (position.snapshot)

minutesToFunding ≤ fundingWindow.warnMin ve riskLevel != low:

cost.window.supervisorHint (ör. "tighten_trailing", "scale_out_25", "close_before_funding").

≤ fundingWindow.blockMin ve riskLevel == high → mesajda daha güçlü öneriler.

Tier Projeksiyonu

projectedVipTierInHours ≤ tierProjectionHorizonMin/60 ise feesBp yakında düşecek; “ertele” önerisi ekle (non-block).

Uyarı & Telemetri

Aykırı değerler (bp > ±100, window negatif vs.) → cost.alert(warn|error).

Her 10 sn: cost.forecaster.metrics (ortalama gecikme, öneri oranları).

Gerçek Dünya Kuralları (Uyum)

Yön bağımlı funding: long öder (bp>0), short alır; bp<0 ise long alır (pozitif katkı). Modül bunu işaretler ama karar vermez.

Maker önceliği: Eğer severity="warn|block" ise ilk öneri post-only maker girişidir (VIVO-26 ile uyumlu).

Zamanlama: Funding’e çok az kala (≤ blockMin) yeni giriş yerine ertelenmesi önerilir.

Idempotency: Aynı plan/correlationId için aynı girdilerde aynı advice üretilmeli (hash tabanlı tekrar koruması).

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/fundingAndFeesForecaster.ts

src/vivo/state/costStore.ts (fees/funding cache + per-symbol forecast)

src/vivo/lib/fees.ts (effective fee bp), src/vivo/lib/funding.ts (bp/period → bp/hold hesapları)

__tests__/fundingAndFeesForecaster.test.ts

Mimari

Saf çekirdek: evaluate(event, state, cfg) → emissions[]

I/O adaptörü: bus subscribe/publish; clock = Europe/Istanbul.

Validasyon

Zod; sayısal alanlar finite(); periodMinutes sözlüğü {8h:480,4h:240,1h:60}.

Performans

p99 < 5ms hedef; hafif hesap, state cache O(1).

Gün Sonu

Metrik sayaçları gün sonunda sıfırla; forecast state korunur.

Test İskeleti (Jest)

bp_per_period=+35 (8h), minutesToFunding=18 → advice.severity="block", reason=high_funding_window

fillStyle=market → takerEff kullanılır; mixed→ağırlıklı hesap

short tarafında bp>0 → fundingBp negatif (rebate) ve severity düşer

holdEstimator fallback ile fundingBp ölçeklenir

fees.discount enabled → effective bp düşer

projectedVipTierInHours < horizon → ertele önerisi eklenir

position.snapshot yakın funding high → supervisorHint("tighten_trailing")

idempotent: aynı plan için aynı advice

aykırı değer → cost.alert(warn|error)

Örnek Senaryo (Özet)

Durum

funding.snapshot: symbol=AVAXUSDT, period=8h, last=+32 bp, predicted=+38 bp, nextFunding=08:00, şimdi 07:45 (15 dk kaldı).

fees.schedule: maker=1.6 bp, taker=5.0 bp, discounts.extraMaker=-0.4 bp.

order.plan.proposed: plannedRR=1.2, entryPlan.mode="market" (taker ağırlıklı), tradeMode="usdm".

holdEstimator: 90 dk.

Hesap

Effective fees (taker): ≈ 5.0 bp.

Funding: +38 bp/8h → 90 dk ≈ 1.5h/8h = 0.1875 period → +7.125 bp (long öder).

Toplam: ≈ 12.1 bp. totalPctOfPlannedR (normalize gösterge) → uyarı düzeyi.

Beklenen Çıktılar (özet)

{
  "event":"cost.budget.advice",
  "symbol":"AVAXUSDT","side":"long","plannedRR":1.2,
  "assumptions":{"fillStyle":"taker","expectedHoldMinutes":90},
  "expectedCosts":{"feesBp":5.0,"fundingBp":7.1,"totalBp":12.1,"totalPctOfPlannedR":0.33},
  "recommendations":["avoid_opening_within_20m_to_funding","prefer_maker_post_only","reduce_hold_to_45m","switch_to_spot_if_possible"],
  "severity":"block",
  "reasonCodes":["high_funding_window","rr_eroded","high_taker_fee"]
}


Açık pozisyon varsa:

{
  "event":"cost.window.supervisorHint",
  "symbol":"AVAXUSDT","tradeId":"...","minutesToFunding":15,
  "suggest":["tighten_trailing","scale_out_25"],"reasonCodes":["funding_spike_risk"]
}

Entegrasyon Notları

VIVO-19 Composer: cost.budget.advice severity="warn|block" ise post-only/maker ve TTL erteleme lehine parametre ayarlasın; switch_to_spot_if_possible önerisini dikkate alabilir.

VIVO-21 Supervisor: cost.window.supervisorHint ile funding öncesi trailing sıkılaştırma/scale-out/kapatma sinyallerini uygular.

VIVO-22 Logger: Kapanışta funding kalemi net PnL’den düşer; bu modülün bp tahmini ile gerçekleşen farkı raporlar (öğrenmeye veri).

VIVO-26 Guard: block seviyesinde gelen advice, halt_entry veya block_aggressive ile birlikte daha sıkı giriş kısıtına dönüştürülebilir.
_________________________________________________________________________________________________________________
VIVO-29 · policyCoordinator.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Tüm politika kaynaklarını (varsayılanlar, LIVIA guard, manuel override, governance önerileri vb.) tek kanonik politika snapshot’ında birleştirmek.

Çakışma çözümü, öncelik sırası, kapsam (global/cluster/symbol/variant/timeframe) kurallarıyla karar verip policy.diff yayınlamak.

Aşamalı yayma (rollout): yüzde/küme/canary hedefleri, effectiveAt/expireAt, rollback.

İlgili modüllere uygulanabilir direktifler üretmek (Throttler, Balancer, Supervisor, Guard, Composer).

Bu modül policy’nin tek doğrusudur. Trade karar vermez; sadece kuralları yayınlar.

Girdiler (Event / JSON Şemaları)
// policy.source.update — her kaynaktan gelen politika parçaları
{
  "event": "policy.source.update",
  "timestamp": "iso8601",
  "source": "default|livia|manual|governance|runtime",
  "priority": "number",                 // yüksek sayı = yüksek öncelik (örn: manual=100, governance=80, livia=70, default=10)
  "scope": {                            // kime uygulanır
    "level": "global|cluster|symbol|variant|timeframe",
    "cluster": "string|null",
    "symbol": "string|null",
    "variant": "base|aggressive|conservative|null",
    "timeframe": "M1|M5|M15|H1|H4|D1|null"
  },
  "window": {                           // zaman penceresi (opsiyonel)
    "effectiveAt": "iso8601|null",
    "expireAt": "iso8601|null",
    "rollout": {"percent": "0..100|null", "canaryTags": ["string"]}  // ör: "beta_users"
  },
  "patch": {                            // kısmi güncelleme (JSON Merge Patch semantiği)
    "risk": {
      "riskPerTradePct": "number|null",
      "totalRiskPct": "number|null",
      "kellyCap": "number|null",
      "dailyMaxTrades": "number|null",
      "maxConcurrentPerSymbol": "number|null",
      "globalMaxConcurrent": "number|null",
      "longShortImbalancePct": "number|null"
    },
    "quality": {
      "confirmationBounds": {"min":"number|null","max":"number|null"},
      "openBarPolicy": "penalize|defer|block|null",
      "slippageHardBps": "number|null",
      "latencyHardMs": "number|null"
    },
    "variants": {
      "allowed": {"base": "boolean|null","aggressive":"boolean|null","conservative":"boolean|null"}
    },
    "clusters": {                       // per cluster/sector limitleri (opsiyonel)
      "caps": {"Layer1":"number|null","DeFi":"number|null","Infra":"number|null","Other":"number|null"}
    },
    "symbols": {                        // per symbol limit/override (opsiyonel)
      "AVAXUSDT": {"perSymbolPct":"number|null","cooldownMin":"number|null"}
    },
    "throttle": {
      "maxBurstsPerMin": "number|null",
      "slowdownEnabled": "boolean|null"
    }
  },
  "audit": {"reasonCodes": ["string"], "note":"string|null", "changeId":"string|null"}
}

// risk.governance.recommendation — VIVO-23’ten gelen öneriler
{
  "event": "risk.governance.recommendation",
  "timestamp": "iso8601",
  "incidentId": "string",
  "recommendations": ["apply_cooldown_30m","halt_new_intents_10m","disable_aggressive_variant_2h","tighten_confirmation_by_0.01"],
  "rationale": ["string"]
}

// connectivity/piyasa sinyalleri (uyum amaçlı; sadece okuma)
{
  "event": "sentry.guard.directive|latency_slip.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic|halt_entry|block_aggressive",
  "expiresAt": "iso8601"
}

Çıktılar (Kanonik Politika & Uygulama)
// policy.snapshot — kanonik, birleştirilmiş ve çözümlenmiş politika
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "effectiveAt": "iso8601",
  "expiresAt": "iso8601|null",
  "hash": "string",
  "sourceStack": [                      // katkı veren yamalar (öncelik sırasına göre)
    {"source":"manual","priority":100,"changeId":"MAN-2025-09-01-01"},
    {"source":"governance","priority":80,"changeId":"RIS-..."},
    {"source":"livia","priority":70,"changeId":"LIV-..."},
    {"source":"default","priority":10,"changeId":"DEF-..."}
  ],
  "policy": {
    "riskPerTradePct": "number",
    "totalRiskPct": "number",
    "kellyCap": "number",
    "dailyMaxTrades": "number",
    "maxConcurrentPerSymbol": "number",
    "globalMaxConcurrent": "number",
    "longShortImbalancePct": "number",
    "confirmationBounds": {"min":"number","max":"number"},
    "openBarPolicy": "penalize|defer|block",
    "slippageHardBps": "number",
    "latencyHardMs": "number",
    "variants": {"base": true, "aggressive": false, "conservative": true},
    "clusterCaps": {"Layer1":"number","DeFi":"number","Infra":"number","Other":"number"},
    "symbolOverrides": {"AVAXUSDT":{"perSymbolPct":"number","cooldownMin":"number|null"}},
    "throttle": {"maxBurstsPerMin":"number","slowdownEnabled":"boolean"}
  },
  "scopeIndex": [                       // kapsam bazında farklar (en spesifik kazanır)
    {"scope":{"level":"global"},"policyRef":"hash#global"},
    {"scope":{"level":"cluster","cluster":"Layer1"},"policyRef":"hash#cluster:Layer1"},
    {"scope":{"level":"symbol","symbol":"AVAXUSDT"},"policyRef":"hash#symbol:AVAXUSDT"},
    {"scope":{"level":"variant","variant":"aggressive"},"policyRef":"hash#variant:aggressive"}
  ]
}

// policy.diff — eski→yeni farklar (özet)
{
  "event": "policy.diff",
  "timestamp": "iso8601",
  "versionFrom": "number",
  "versionTo": "number",
  "changes": [
    {"path":"/variants/aggressive","from":true,"to":false,"reasonCodes":["disable_aggressive_variant_2h"]},
    {"path":"/confirmationBounds/min","from":0.58,"to":0.60,"reasonCodes":["tighten_confirmation_by_0.01"]}
  ],
  "rollout": {"percent": 100, "canaryTags": []}
}

// policy.apply.directive — alt modüller için uygulanabilir emirler
{
  "event": "policy.apply.directive",
  "timestamp": "iso8601",
  "version": "number",
  "targets": ["throttler","balancer","supervisor","guard","composer"],
  "scope": {"level":"global|cluster|symbol|variant|timeframe","symbol":"string|null","variant":"string|null"},
  "actions": [
    {"type":"set_limit","key":"riskPerTradePct","value":"number"},
    {"type":"toggle_variant","variant":"aggressive","enabled":false},
    {"type":"set_confirm_bounds","min":"number","max":"number"},
    {"type":"set_cluster_cap","cluster":"Layer1","value":"number"},
    {"type":"set_symbol_cap","symbol":"AVAXUSDT","value":"number"},
    {"type":"set_throttle","maxBurstsPerMin":"number"}
  ],
  "effectiveAt": "iso8601",
  "expiresAt": "iso8601|null"
}

// Rollback (acil geri dönüş)
{
  "event": "policy.rollback",
  "timestamp": "iso8601",
  "rollbackToVersion": "number",
  "reason": "string"
}

// Telemetri & uyarı
{
  "event": "policy.metrics",
  "timestamp": "iso8601",
  "applies": "number",
  "rollouts": "number",
  "rollbacks": "number",
  "conflictsResolved": "number",
  "canaryCoveragePct": "number"
}
{
  "event": "policy.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"conflictPaths":["string"]}
}

Öncelik ve Kapsam Kuralları

Kaynak önceliği (yüksekten düşüğe): manual (100) → governance (80) → livia (70) → runtime (60) → default (10).

Kapsam özgüllüğü: symbol > cluster > variant > timeframe > global.
Aynı alan için daha spesifik kapsam genel kapsamı gölger.

Zaman penceresi: effectiveAt gelmedi ise now, expireAt geçtiyse geçersiz.
Zamansal çakışmada en güncel (en yüksek priority) kazanır.

Rollout: rollout.percent < 100 ise canary; hedefleme canaryTags veya pseudo-random hash (correlationId/ symbol) ile deterministik.

TypeScript Arayüzleri (ürettir)

PolicySourceUpdate, PolicyPatch, Scope, Window, SourceMeta.

PolicySnapshot, PolicyDiff, PolicyApplyDirective, PolicyRollback, PolicyMetrics, PolicyAlert.

Yardımcı: CoordinatorState, ScopeKey, MergeResult, RolloutSelector, Conflict, VersionClock.

Zod ile tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: policy.source.update, risk.governance.recommendation, sentry.guard.directive, latency_slip.guard.directive

Out: policy.snapshot, policy.diff, policy.apply.directive, policy.rollback, policy.metrics, policy.alert

Konfig & Varsayılanlar
{
  versionStart: 1000,
  defaultPolicy: {
    riskPerTradePct: 0.5,
    totalRiskPct: 2.0,
    kellyCap: 0.25,
    dailyMaxTrades: 3,
    maxConcurrentPerSymbol: 1,
    globalMaxConcurrent: 3,
    longShortImbalancePct: 1.0,
    confirmationBounds: { min: 0.58, max: 0.72 },
    openBarPolicy: "penalize",
    slippageHardBps: 15,
    latencyHardMs: 1800,
    variants: { base: true, aggressive: true, conservative: true },
    clusterCaps: { Layer1: 1.2, DeFi: 0.8, Infra: 0.8, Other: 0.8 },
    symbolOverrides: {},
    throttle: { maxBurstsPerMin: 3, slowdownEnabled: true }
  },
  precedence: { manual: 100, governance: 80, livia: 70, runtime: 60, default: 10 },
  rollout: { defaultPercent: 100, hashSalt: "vivo29" },
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

CoordinatorState (in-memory + periyodik persist data/policy.state.json):

versionClock, son PolicySnapshot, aktif overlays (kaynak→scope→patch).

rolloutAssignments: correlationId/symbol→bucket (deterministik).

history: diff/uygulama geçmişi (append-only).

Idempotency: Aynı changeId gelen güncellemeyi ikinci kez uygulama.

Algoritma (Akış)

Kaynak Güncellemesi Al

policy.source.update → Zod doğrulama → valid window?

overlays[source][scopeKey] = newestByTimeAndPriority(patch) olarak cache’le.

Governance Önerilerini Haritala

disable_aggressive_variant_2h → patch.variants.allowed.aggressive=false + expireAt = now+2h.

apply_cooldown_30m → symbolOverrides.*.cooldownMin = max(existing,30).

tighten_confirmation_by_0.01 → confirmationBounds.min += 0.01 (clamp ≤ max−0.01).

halt_new_intents_10m → throttle.maxBurstsPerMin = 0, expireAt=+10m.

Kanonik Snapshot Üret

base = defaultPolicy.

Tüm overlay’leri priority desc → scope specificity desc sırası ile JSON merge-patch uygula.

Zaman penceresi dışı yamaları atla. Conflicts kaydet (policy.alert(warn)).

Rollout Uygula (opsiyonel)

rollout.percent < 100 yamalar için RolloutSelector: symbol/correlationId hash→bucket.

Canary dışında kalanlara ilgili alanlar base’ten devam.

Yeni Sürüm & Diff

Hash üret (snapshot.policy). if (hash != lastHash) → version++, policy.diff oluştur.

policy.snapshot ve uygulama direktifleri yayınla:

Throttler: dailyMaxTrades, throttle, variants.allowed.

Balancer: totalRiskPct, clusterCaps, longShortImbalancePct.

Supervisor/Guard: slippageHardBps, latencyHardMs, openBarPolicy.

Composer: confirmationBounds, riskPerTradePct, perSymbolPct.

Sona Erme & Rollback

expireAt geçen overlay’leri otomatik sil → yeni snapshot yayınla.

policy.rollback gelirse rollbackToVersion’ı historyden al, snapshot’ı geri sar.

Telemetri

10 sn’de bir policy.metrics (applies/rollouts/rollbacks/conflicts).

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/policyCoordinator.ts

src/vivo/state/policyStore.ts (overlays + snapshot + history)

src/vivo/lib/mergePatch.ts, src/vivo/lib/rollout.ts, src/vivo/lib/diff.ts

__tests__/policyCoordinator.test.ts

Mimari

Saf çekirdek: recompute(state, cfg, now) → {snapshot, diffs, directives, alerts}

IO adaptörü: bus subscribe/publish + persist + timers (expire sweep).

Validasyon

Zod şemaları; clamp: 0≤min<max≤1 (confirmation), yüzdelik alanlar 0..100.

Geçersiz patch → policy.alert(error,"invalid_patch").

Idempotency

changeId veya eventHash ile tekrarı yut; aynı snapshot hash’i → yayınlama.

Performans

p99 < 5ms hedef; overlay sayısı artsa da O(S log S) (s=overlay sayısı).

Test İskeleti (Jest)

manual vs livia çakışma → manual kazanır; diff doğru

symbol override global’i gölgeler

governance:disable_aggressive_variant_2h → expire sonrası otomatik geri açılır

tighten_confirmation_by_0.01 → clamp ≤ max-0.01

rollout 30% → deterministik bucket; canary dışı etkilenmez

policy.snapshot hash değişmezse version artmaz

rollback → önceki snapshot geri gelir

invalid patch → policy.alert(error)

throttle=0 (halt) → policy.apply.directive targets=throttler

Örnek Senaryo (Özet)

Girdiler

default yüklenmiş.

risk.governance.recommendation: ["disable_aggressive_variant_2h","tighten_confirmation_by_0.01"]

policy.source.update(manual):

scope=symbol: AVAXUSDT, patch=symbols.AVAXUSDT.perSymbolPct=0.6

window=effectiveAt=now, expireAt=null

livia: totalRiskPct=1.8 önerdi (geçici savunma).

Beklenen Yayınlar

policy.diff:

/variants/aggressive: true→false

/confirmationBounds/min: 0.58→0.59

/symbols/AVAXUSDT/perSymbolPct: 0.8→0.6

/totalRiskPct: 2.0→1.8

policy.apply.directive:

toggle_variant(aggressive=false) (targets: throttler)

set_confirm_bounds(min=0.59,max=0.72) (composer)

set_symbol_cap(AVAXUSDT=0.6) (balancer)

set_limit(totalRiskPct=1.8) (balancer)

policy.snapshot(version++ , effectiveAt=now)

2 saat sonra aggressive tekrar true (expiry ile rollback-like).

Entegrasyon Notları

VIVO-23 (Incident Reporter) → Governance önerileri doğrudan policy.source.update’e dönüştürülür; bu modül süre/pencere ekler.

VIVO-26 & VIVO-27 sinyalleri (halt/degraded) kalıcı policy değildir; ama bu modül throttle/variants üstünden geçici yumuşatma yükleyebilir (window/expireAt ile).

Tüm tüketiciler policy.apply.directive.version’ı saklayıp aynı versiyonu iki kez uygulamamalı (idempotent).
_________________________________________________________________________________________________________________
VIVO-30 · strategyBanditOrchestrator.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Strateji/variant/formation kolları arasında güvenli keşif–istismar (multi-armed bandit) orkestrasyonu yapmak.

Policy tavanları, risk/guard sinyalleri ve rejim uyumu ile bandit seçimini kısıtlamak.

Deney trafiğini (A/B/çok kollu) yüzdesel pay olarak dağıtıp idempotent seçim kararı üretmek.

VIVO-22/17 geri beslemesiyle Bayes güncellemesi yapıp performans inançlarını (priors→posteriors) güncel tutmak.

Bu modül yalnızca seçim/dağıtım yapar; emir açmaz. Uygulama VIVO-18/19’da.

Girdiler (Event / JSON Şemaları)
// strategy.catalog — kullanılabilir kollar ve meta
{
  "event": "strategy.catalog",
  "timestamp": "iso8601",
  "arms": [
    {
      "name": "momentum_pullback_M5",
      "variant": "base|aggressive|conservative",
      "formationTag": "string|null",
      "timeframes": ["M5","M15"],
      "fits": ["trend","breakout"],
      "riskClass": "low|mid|high",
      "minSamplesToUnlock": 50,
      "trafficCapPct": 60
    }
  ]
}

// policy.snapshot — politika kısıtları (VIVO-29)
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": 1012,
  "policy": {
    "variants": {"base": true,"aggressive": false,"conservative": true},
    "confirmationBounds": {"min":0.59,"max":0.72},
    "dailyMaxTrades": 3
  }
}

// regime.snapshot — rejim bağlamı (Grafik Beyni)
{
  "event": "regime.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "regime": "trend|range|breakout|highVol|illiquid"
}

// vivo.feedback.raw — performans geri beslemesi (VIVO-22)
{
  "event": "vivo.feedback.raw",
  "timestamp": "iso8601",
  "scope": {"symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null"},
  "kpis": {"hit":"0|1","profitFactor":"number","rMultiple":"number","slippageBps":"number","fees":"number"},
  "samples": {"fills":"int"}
}

// risk.incident.* — güvenlik/ihlal sinyalleri (VIVO-23)
{
  "event": "vivo.feedback.incident|risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "type": "series_loss|drawdown_breach|execution_anomaly|data_staleness|exposure_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"}
}

// guard directives — girişleri sınırlayan modlar (VIVO-26/27)
{
  "event": "latency_slip.guard.directive|sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|slowdown|block_aggressive|halt_entry|degraded|streams_panic",
  "expiresAt": "iso8601"
}

// execution.intent.request — orkestratörden seçim talebi
{
  "event": "execution.intent.request",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "context": {"regime":"string","confidence":"0..1"},
  "audit": {"requestId":"string"}
}

Çıktılar (Seçim, Trafik, Telemetri)
// Seçim kararı (tek kol)
{
  "event": "strategy.selection.decision",
  "timestamp": "iso8601",
  "requestId": "string",
  "symbol": "string",
  "timeframe": "string",
  "mode": "explore|exploit|safe_fallback|blocked",
  "selectedArm": {
    "name": "string",
    "variant": "base|aggressive|conservative",
    "formationTag": "string|null"
  },
  "allocationPct": "number",                 // 0..100; intent trafiğinde bu kola ayrılacak pay
  "policyVersion": "number",
  "reasonCodes": ["string"],                 // ör: "ucb_max", "ts_sample_best", "variant_blocked", "guard_active"
  "constraints": {"minConfirm": "number","haltEntry": false}
}

// Çok kollu dağıtım (batch)
{
  "event": "strategy.traffic.plan",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "allocations": [
    {"arm":"momentum_pullback_M5:base","pct":55},
    {"arm":"breakout_M5:conservative","pct":45}
  ],
  "mode": "explore_mix|exploit_dominant",
  "ttlSec": 300,
  "reasonCodes": ["soft_explore_cap","cold_start_arm"]
}

// Bandit durum güncellemesi (posterior snapshot)
{
  "event": "strategy.bandit.state",
  "timestamp": "iso8601",
  "arms": [
    {
      "arm":"momentum_pullback_M5:base",
      "posteriors":{
        "hitRate": {"alpha":"number","beta":"number"},
        "rMean": {"mu":"number","sigma":"number"}
      },
      "trafficSharePct": "number",
      "safety": {"cooldownUntil":"iso8601|null","blocked":false}
    }
  ]
}

// Telemetri & uyarı
{
  "event": "strategy.bandit.metrics",
  "timestamp": "iso8601",
  "exploreRate": "number",
  "blockedRate": "number",
  "avgSamplesPerArm": "number",
  "coldStartActive": "boolean"
}
{
  "event": "strategy.bandit.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"arm":"string","reasonCodes":["string"]}
}

TypeScript Arayüzleri (ürettir)

Inputs: StrategyCatalog, PolicySnapshot, RegimeSnapshot, FeedbackRaw, IncidentEvent, GuardDirective, ExecutionIntentRequest.

Outputs: StrategySelectionDecision, StrategyTrafficPlan, StrategyBanditState, StrategyBanditMetrics, StrategyBanditAlert.

Helpers:
ArmKey (name:variant:formationTag:timeframe),
BanditParams (priors), PosteriorHitRate (Beta), PosteriorR (Gaussian),
SafetyGate (cooldown/blocked), RandomSource (deterministic seed).

Zod: tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: strategy.catalog, policy.snapshot, regime.snapshot, vivo.feedback.raw, risk.incident.*, latency_slip.guard.directive, sentry.guard.directive, execution.intent.request

Out: strategy.selection.decision, strategy.traffic.plan, strategy.bandit.state, strategy.bandit.metrics, strategy.bandit.alert

Konfig & Varsayılanlar
{
  // Bandit yöntemi
  bandit: {
    mode: "thompson_ucb_hybrid",  // TS + risk ayarlı UCB karışımı
    exploreFloorPct: 10,          // min keşif trafiği
    exploreCapPct: 35,            // max keşif trafiği
    coldStartTrafficPct: 20,      // yeni kola başlangıç
    minSamplesToExploit: 30,      // bundan azsa tam istismar etme
    ucbConfidenceZ: 1.0           // UCB z-çarpanı
  },

  // Güvenlik kapıları
  safety: {
    blockAggressiveWhenGuard: true,
    blockWhenStreamsPanic: true,
    cooldownOnIncident: {
      "series_loss": "PT30M",
      "drawdown_breach": "PT2H",
      "execution_anomaly": "PT20M"
    }
  },

  // Rejim eşleşme bonus/ceza
  regimeFit: { matchBonus: 0.02, mismatchPenalty: 0.03, highVolPenalty: 0.04, illiquidBlock: true },

  // Trafik & adalet
  traffic: { rebalanceTtlSec: 300, perArmCapPct: 60, perVariantCapPct: {"aggressive": 0, "base": 70, "conservative": 70} },

  // Priors (Bayes)
  priors: {
    hitRate: {"alpha": 2, "beta": 3},     // Beta(2,3) ~ %40 ilk inanç
    rMean: {"mu": 0.2, "sigma": 0.6}      // R-multiple ortalaması
  },

  // Deterministiklik
  seed: "vivo30-bandit",

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

BanditStateStore (in-memory + periyodik persist data/bandit.state.json veya SQLite):

arms[ArmKey]: { posteriors.hitRate (α,β), posteriors.rMean (μ,σ), samples, trafficSharePct, safety, lastUpdateAt }

policyVersion, lastRegimeByTF, activeTrafficPlan{symbol,timeframe} (TTL).

rng deterministik tohumlu (seed + symbol + timeframe + requestId → seçim idempotent).

Idempotency: Aynı requestId için aynı seçim.

Seçim Fonksiyonu (Skor & Güvenlik)

Güvenlik Kapıları

guard.mode in ["halt_entry","streams_panic"] → mode="blocked", hiçbir kol seçilmez.

policy.variants.aggressive=false → aggressive kollar gizle.

Son incident tipi için cooldownOnIncident[type] süresi dolmadıysa ilgili kol/variant blok.

Uygun Kolları Filtrele

regimeFit: illiquid ve illiquidBlock==true → tüm kollar blok.

catalog.fits rejime uymayan kola mismatchPenalty uygula (skorda).

minSamplesToUnlock dolmamış yeni kollar coldStartTrafficPct ile sınırlanır.

Posterior Örnekleme

Thompson:

p_hit ~ Beta(α,β), r ~ Normal(μ,σ) örnekle.

Utility ≈ p_hit * r (R beklentisi),
ardından regime bonus/penalty ekle.

UCB katkısı: ucb = μ + z * σ / sqrt(n); **hybridScore = 0.7TS + 0.3normalized(UCB)`.

Trafik Kısıtları

perArmCapPct ve perVariantCapPct sınırlarını uygula.

exploreFloorPct ≤ exploreShare ≤ exploreCapPct.

coldStart kollar toplamı ≤ coldStartTrafficPct.

Seçim ve Dağıtım

Tek istek (request) için en yüksek hybridScore kola decision çıkar.

Batch/plan gerekiyorsa (ör. per-symbol stream): top-K kolları traffic.plan ile yüzdelere böl (softmax/normalize).

Onay & Çıktı

strategy.selection.decision üret; constraints.minConfirm = policy.confirmationBounds.min.

strategy.bandit.state ve metrikleri periyodik yayınla.

Güncelleme (Öğrenme) Mantığı

vivo.feedback.raw geldiğinde ArmKey eşleştir:

Beta güncelle: α += hit, β += (1-hit).

Gaussian güncelle: Welford/online mean-variance; μ, σ güncellenir.

Samples artar; trafficSharePct akışa göre EWMA ile güncellenir.

Aykırı/cezalı örnekler (execution anomaly, extreme slip) düşük ağırlıkla sayılabilir (opsiyonel w=0.5).

Algoritma (Yüksek Seviye Akış)

Katalog/Policy/Rejim güncel değilse → alert(warn,"stale_context") ve safe_fallback (konservatif kol).

execution.intent.request → güvenlik→filtre→skor→kısıt→seçim akışını çalıştır.

feedback eventleri ile posteriors güncellenir, bandit.state yayınlanır.

traffic.plan TTL dolduğunda veya rejim/policy değiştiğinde yeniden hesaplanır.

metrics her 10 sn: exploreRate, blockedRate, avgSamplesPerArm, coldStartActive.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/strategyBanditOrchestrator.ts

src/vivo/state/banditStore.ts (posteriors + traffic + safety + RNG persist)

src/vivo/lib/beta.ts, src/vivo/lib/gauss.ts, src/vivo/lib/score.ts, src/vivo/lib/rng.ts

__tests__/strategyBanditOrchestrator.test.ts

Mimari

Saf çekirdek: select(request, state, cfg) → Decision|Blocked
update(feedback, state, cfg) → BanditStateDelta

IO adaptörü: bus subscribe/publish, timers (metrics/TTL).

Validasyon

Zod; sayısal alanlar finite(). Katalog boşsa safe_fallback.

Deterministiklik

RNG seed + (symbol,timeframe,requestId) → kararlı sonuç; seed değişmeden sonuç tekrarlanabilir.

Performans

p99 < 3ms hedef (N=≤32 kol varsayımı); örnekleme O(N).

Test İskeleti (Jest)

guard.halt_entry → decision.mode="blocked"

aggressive policy off → aggressive kollar filtrelenir

illiquid regime & illiquidBlock=true → blocked

coldStart arm → allocation ≤ coldStartTrafficPct

TS+UCB hybrid → yüksek μ fakat belirsiz σ kolu zamanla yükselir

feedback hit=1 → Beta α artar, seçim olasılığı yükselir

drawdown_breach incident → ilgili kol cooldown

explore caps (floor/cap) → traffic.plan oranları sınırlar içinde

deterministic RNG → aynı requestId aynı karar

stale context → safe_fallback

Örnek Senaryo (Özet)

Durum

Katalog:

momentum_pullback_M5:base (fits: trend/breakout)

meanRevert_M5:conservative (fits: range)

Rejim: trend

Policy: aggressive kapalı; minConfirm=0.59

Posteriors (özet):

MP5: p_hit≈0.55, μ≈0.35R

MR5: p_hit≈0.48, μ≈0.25R

Seçim

Regime bonus MP5’e +0.02, MR5’e mismatch -0.03.

Hybrid skor MP5 > MR5 → exploit.

Beklenen Çıktılar

{
  "event":"strategy.selection.decision",
  "requestId":"REQ-123",
  "symbol":"AVAXUSDT","timeframe":"M5",
  "mode":"exploit",
  "selectedArm":{"name":"momentum_pullback_M5","variant":"base","formationTag":null},
  "allocationPct":100,
  "policyVersion":1012,
  "reasonCodes":["ts_sample_best","regime_match","aggressive_disabled"],
  "constraints":{"minConfirm":0.59,"haltEntry":false}
}

Entegrasyon Notları

VIVO-18 Throttler: strategy.selection.decision’daki constraints.minConfirm ve allocationPct’i tüketip niyet basamaklarını ayarlayabilir.

VIVO-19 Composer: seçilen arma göre parametre setleri (giriş tipi, TTL, TP/SL stili) yüklenir.

VIVO-17/22: feedback akışı bu modülün tek öğrenme kaynağıdır; logger’ın trade.summary.closed ve feedback.raw’ı yeterli.

VIVO-23/26/27/29: guard/incident/policy sinyalleri güvenlik kapısı olarak uygulanır; modül sonuçlarına üstteki kısıtlar önceliklidir.
_________________________________________________________________________________________________________________
VIVO-31 · symbolUniverseManager.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

İşlem yapılabilir sembol evrenini dinamik yönetmek: whitelist/blacklist, likidite & kalite eşikleri, dönemsel rotasyon, canary/deneysel kümeler.

Likidite/sağlık (hacim, spread, derinlik, uptime), performans (hitRate/expectancy), maliyet (fees/funding), risk/incident sinyallerini birleştirip evren snapshot üretmek.

Sonucu Throttler/QA/Balancer/Bandit gibi modüllere uygulanabilir direktif olarak yayınlamak.

Bu modül giriş-çıkış akışlarını yönetir; emir mantığına karışmaz.

Girdiler (Event / JSON Şemaları)
// exchange.symbols.catalog — borsadan desteklenen semboller ve filtreleri
{
  "event": "exchange.symbols.catalog",
  "timestamp": "iso8601",
  "exchange": "string",
  "symbols": [
    {
      "symbol": "AVAXUSDT",
      "status": "TRADING|BREAK|HALT",
      "base": "AVAX",
      "quote": "USDT",
      "filters": {
        "minNotional": "number",
        "tickSize": "number",
        "stepSize": "number"
      }
    }
  ]
}

// market.liquidity.snapshot — likidite ve mikro yapı metrikleri (rolling/periodic)
{
  "event": "market.liquidity.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "windowMin": 60,
  "metrics": {
    "volUSD": "number",            // pencere hacmi (USD)
    "avgSpreadBps": "number",
    "p10DepthUSD": "number",       // en iyi 10 seviye toplam derinlik
    "uptimePct": "number",         // son pencerede stream/heartbeat sürekliliği
    "msgRatePerSec": "number"      // WS mesaj/se
  }
}

// vivo.performance.daily — (VIVO-22) performans özetleri (symbol×tf×variant)
{
  "event": "vivo.performance.daily",
  "date": "YYYY-MM-DD",
  "scope": {"symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null"},
  "kpis": {
    "trades":"int","wins":"int","hitRate":"number","profitFactor":"number",
    "avgR":"number","expectancyR":"number","avgSlipBps":"number","maxDD_R":"number"
  }
}

// cost.forecast.update — (VIVO-28) maliyet (fees/funding) bağlamı
{
  "event": "cost.forecast.update",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeMode": "spot|usdm|coinm",
  "fee": {"effectiveMakerBp":"number","effectiveTakerBp":"number"},
  "funding": {"period":"8h|4h|1h","predictedNextRateBp":"number|null","windowMinutesToFunding":"number","signHint":"string"},
  "derived": {"basisBpAnnual":"number|null","riskLevel":"low|elevated|high"}
}

// risk.incident.* — (VIVO-23) risk olayları; sembol sağlığını etkiler
{
  "event": "risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "type": "exposure_breach|execution_anomaly|data_staleness|series_loss|drawdown_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null"}
}

// sentry.guard.directive — (VIVO-27) bağlantı sağlığı (evren kararı için)
{
  "event": "sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic",
  "expiresAt": "iso8601",
  "reasonCodes": ["string"]
}

// mapping.meta — küme ve beta sınıfları (VIVO-25 ile uyumlu)
{
  "event": "mapping.meta",
  "overrides": {"AVAXUSDT":{"cluster":"Layer1","beta":{"BTC":0.84,"Market":1.1}}}
}

// policy.snapshot — evren kotaları ve kurallar (VIVO-29)
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "policy": {
    "clusterCaps": {"Layer1":"number","DeFi":"number","Infra":"number","Other":"number"},
    "variants": {"base":true,"aggressive":true,"conservative":true},
    "openBarPolicy": "penalize|defer|block"
  }
}

// external.universe.command — manuel müdahale (opsiyonel)
{
  "event": "external.universe.command",
  "timestamp": "iso8601",
  "action": "whitelist_add|whitelist_remove|blacklist_add|blacklist_remove|watch_add|watch_remove|rotate_now",
  "symbols": ["string"]
}

Çıktılar (Evren & Direktifler)
// Evrenin kanonik anlık görüntüsü
{
  "event": "universe.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "hash": "string",
  "exchange": "string",
  "summary": {
    "totalSymbols": "number",
    "allowed": "number",
    "experimental": "number",
    "blacklisted": "number"
  },
  "universe": [
    {
      "symbol": "AVAXUSDT",
      "status": "allowed|experimental|blocked",
      "cluster": "Layer1",
      "score": {
        "liquidity": "0..1",
        "performance": "0..1",
        "cost": "0..1",
        "riskPenalty": "0..1",
        "composite": "0..1"
      },
      "tags": ["core","quiet_ok","funding_high_window","recent_incident"],
      "limits": {"maxRiskPct":"number|null","maxConcurrent":"number|null"}
    }
  ]
}

// Farklar (eski→yeni)
{
  "event": "universe.diff",
  "timestamp": "iso8601",
  "versionFrom": "number",
  "versionTo": "number",
  "added": ["string"],            // yeni allowed/experimental
  "removed": ["string"],          // evrenden çıkan
  "statusChanges": [              // allowed↔experimental↔blocked
    {"symbol":"AVAXUSDT","from":"experimental","to":"allowed","reasonCodes":["liquidity_ok","stable_perf"]}
  ]
}

// Uygulama direktifleri (downstream hedefler)
{
  "event": "universe.apply.directive",
  "timestamp": "iso8601",
  "version": "number",
  "targets": ["throttler","qa","balancer","bandit","router"],
  "actions": [
    {"type":"allow_symbols","symbols":["BTCUSDT","ETHUSDT","AVAXUSDT"]},
    {"type":"block_symbols","symbols":["LOWLIQUSDT","HALTCOINUSDT"]},
    {"type":"experimental_symbols","symbols":["NEWCOINUSDT"]},
    {"type":"set_symbol_limit","symbol":"AVAXUSDT","maxRiskPct":0.6}
  ],
  "effectiveAt": "iso8601"
}

// Alarm/telemetri
{
  "event": "universe.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"symbols":["string"]}
}
{
  "event": "universe.metrics",
  "timestamp": "iso8601",
  "scores": {"avgLiquidity":"number","avgPerf":"number","avgCost":"number"},
  "counts": {"allowed":"number","experimental":"number","blocked":"number"},
  "rotation": {"lastAt":"iso8601","added": "number","removed":"number"}
}

TypeScript Arayüzleri (ürettir)

Inputs: ExchangeSymbolsCatalog, MarketLiquiditySnapshot, DailyPerformance, CostForecastUpdate, IncidentEvent, SentryGuardDirective, MappingMeta, PolicySnapshot, ExternalUniverseCommand.

Outputs: UniverseSnapshot, UniverseDiff, UniverseApplyDirective, UniverseAlert, UniverseMetrics.

Helpers:
SymbolHealth, ScoreBreakdown, UniverseState, RotationPlan, HysteresisGate, QuotaTracker, Ranker, Hasher (deterministik canary).

Zod: tüm giriş/çıkışlarda runtime validasyon (NaN/∞ reddet).

Event Bus Konuları

In: exchange.symbols.catalog, market.liquidity.snapshot, vivo.performance.daily, cost.forecast.update, risk.incident.*, sentry.guard.directive, mapping.meta, policy.snapshot, external.universe.command

Out: universe.snapshot, universe.diff, universe.apply.directive, universe.alert, universe.metrics

Konfig & Varsayılanlar
{
  // Tazelik pencereleri
  freshness: { liquidityMaxAgeSec: 180, perfMaxAgeHours: 36, costMaxAgeMin: 60 },

  // Likidite eşikleri (minimumlar)
  liquidityMin: { volUSD: 2e6, p10DepthUSD: 5e5, uptimePct: 0.97 },
  spreadMaxBpsAvg: 25,            // bunun üstü riskli

  // Sembol filtreleri
  filters: { minNotional: 10, minTickPrecision: 1e-6, minStepPrecision: 1e-6 },

  // Skor ağırlıkları (0..1 normalizasyon sonrası)
  weights: { liquidity: 0.45, performance: 0.30, cost: 0.10, riskPenalty: 0.15 },

  // Performans skorlaması
  perfNorm: { hitRateRef: 0.5, expectancyRef: 0.15, slipPenaltyScale: 0.02 },

  // Maliyet skoru (düşük daha iyi → ters normalize)
  costNorm: { feeBpRef: 4.0, fundingRiskRefBp: 15 },

  // Risk/incident cezası
  incidentPenalty: { low: 0.02, medium: 0.05, high: 0.10, critical: 0.20, decayHalfLifeMin: 180 },

  // Kotalar ve rotasyon
  quotas: { maxAllowed: 40, maxExperimental: 8, perClusterMax: { Layer1: 12, DeFi: 10, Infra: 8, Other: 10 } },
  rotation: { periodMin: 60, hysteresisBps: 5, promoteThreshold: 0.62, demoteThreshold: 0.55 },

  // Canary/deneysel seçim
  experimental: { candidateTopK: 20, canaryPercent: 20, holdMinPeriodMin: 120 },

  // Manuel listeler önceliği
  manual: { whitelistWins: true, blacklistWins: true },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul",
  seed: "vivo31-universe"
}

Durum Yönetimi

UniverseState (in-memory + periyodik persist data/universe.state.json):

catalog (aktif semboller + filtreler), lastLiquidityBySymbol, lastPerfBySymbolTF, lastCostBySymbol, incidentPenalties, mappingMeta, policyVersion.

currentUniverse (Map<symbol, entry>), version, lastRotationAt.

manualLists: whitelist, blacklist, watchlist.

quotaTracker: cluster/overall sayaçlar.

Idempotency: Aynı hash’li snapshot/diff’i tekrar yayınlama.

Skorlamalar

Likidite Skoru (0..1)

L = w1 * min(1, volUSD / volRef) + w2 * min(1, p10DepthUSD / depthRef) + w3 * clamp(1 - avgSpreadBps/spreadMax, 0, 1) + w4 * uptimePct

Referanslar: volRef=5e6, depthRef=1e6, spreadMax=config.spreadMaxBpsAvg. (Normalize et, ağırlıkları eşit veya sabit tut.)

Performans Skoru (0..1)

P = 0.5*normHit + 0.4*normExp + 0.1*(1 - normSlip)

normHit = clamp((hitRate - 0.35)/(0.6 - 0.35), 0, 1)

normExp = clamp((expectancyR - 0.05)/(0.25 - 0.05), 0, 1)

normSlip = clamp(avgSlipBps / (2*perfNorm.slipPenaltyScale*100), 0, 1) (uygun ölçekle)

Maliyet Skoru (0..1)

feesScore = clamp(1 - effectiveTakerBp/feeBpRef, 0, 1)

fundScore = if riskLevel=="high" then 0 else if "elevated" then 0.5 else 1

C = 0.6*feesScore + 0.4*fundScore

Risk Cezası (0..1)

Son incident şiddetine göre ceza, zamanla exponential decay: penalty = base * exp(-ln(2)*ageMin/decayHalfLifeMin)

R = 1 - penalty (yani 1 iyi, 0 kötü)

Bileşik Skor

S = weights.liquidity*L + weights.performance*P + weights.cost*C + weights.riskPenalty*R

Algoritma (Karar Akışı)

Tazelik Kontrolü

Likidite/perf/cost verisi bayatsa sembol experimental veya blockeda düşebilir (konfige göre).

sentry.guard.directive.mode=="streams_panic" → evren değişikliklerini yavaşlat (yalnızca blocked genişlet).

Ön Filtreler

exchange.symbols.catalog.status!="TRADING" → blocked.

filters.minNotional < config.filters.minNotional veya tick/step hassasiyeti yetersiz → blocked.

Blacklist’te olan → blocked. Whitelist’te olan → filtreler geçse doğrudan allowed.

Skor Hesapla & Etiketle

L/P/C/R/S değerlerini hesapla.

Tag’ler: core (yüksek L ve P), experimental (S orta ama taze), recent_incident, funding_high_window, quiet_ok (avgSpread<15 bps).

Kotalar & Kümeler

quotas’a göre cluster bazında kontenjan uygula (Layer1, DeFi, …).

allowed sınıfı için en yüksek S puanlılar seçilir; sınırı aşanı experimental veya blockeda iter.

Rotasyon & Histerezis

rotation.periodMin dolmadan statü değiştirme.

Terfi (experimental→allowed) yalnızca S ≥ promoteThreshold;
Düşürme (allowed→experimental/blocked) ancak S ≤ demoteThreshold ve hysteresisBps üstünde fark varsa.

Deneysel/Canary Seçimi

experimental.candidateTopK içinden seed’e göre deterministik canaryPercent seç; statü experimental.

holdMinPeriodMin dolmadan deneysel statüyü bozma.

Manuel Komutlar

external.universe.command uygula (whitelist/blacklist/watch). *manual.Wins=true kuralları öncelikli.

Snapshot & Diff

Yeni evreni oluştur, hashle.

hash != lastHash ise universe.diff ve universe.apply.directive yayınla:

allow_symbols: Throttler/Router’a.

block_symbols: QA/Throttler/Balancer’a.

experimental_symbols: Bandit’e “düşük trafik” etiketi.

Telemetri & Alarm

Eşik ihlallerinde universe.alert(warn|error).

10 sn’de bir universe.metrics.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/symbolUniverseManager.ts

src/vivo/state/universeStore.ts (catalog + metrics + penalties + lists + snapshot persist)

src/vivo/lib/score.ts (normalize & composite), src/vivo/lib/decay.ts, src/vivo/lib/hysteresis.ts, src/vivo/lib/quota.ts

__tests__/symbolUniverseManager.test.ts

Mimari

Saf çekirdek: recompute(state, cfg, now) → {snapshot, diff, directives, alerts, metrics}

IO adaptörü: bus subscribe/publish + timers (rotation schedule).

Validasyon

Zod; sayısal alanlar finite(); status alanları enum; listeler set olarak tutulur.

Idempotency

Aynı hash → tekrar yayın yok; external.universe.command için eventId/hash ile yut.

Performans

N sembol için O(N) skor; top-K seçimleri için O(N log K).

Test İskeleti (Jest)

catalog.status!=TRADING → blocked

liquidity below thresholds → blocked

whitelist → allowed (filters sağsa); blacklist → blocked

incident high/critical → riskPenalty düşürür; demoteThreshold altında ise düşer

promote/demote histerezis kuralları

quotas per cluster uygulanır

experimental canary deterministik (seed) ve holdMinPeriod korunur

stale data → experimental/blocked

diff & apply.directive doğru listeleri içerir

sentry.streams_panic → yalnızca block yönünde değişim

Örnek Senaryo (Özet)

Girdi Özetleri

exchange.symbols.catalog: { BTCUSDT, ETHUSDT, AVAXUSDT, NEWCOINUSDT } (hepsi TRADING)

market.liquidity.snapshot (60dk):

BTC: vol 150M, spread 4 bps, depth 20M, uptime 0.999

AVAX: vol 6.2M, spread 18 bps, depth 1.1M, uptime 0.985

NEWCOIN: vol 0.9M, spread 48 bps, depth 0.08M, uptime 0.94

vivo.performance.daily: AVAX M5 expectancy 0.18R, hit 0.53; NEWCOIN veri az (trades=3)

cost.forecast.update: AVAX funding risk elevated, BTC low

risk.incident.open: NEWCOIN execution_anomaly high (taze)

policy.snapshot: quotas maxAllowed=40, clusterCaps.Layer1=12

Beklenen Karar

BTC: allowed (core) — S ≈ yüksek

ETH: allowed

AVAX: allowed veya experimental→allowed (likidite sınırı geçti, performans pozitif, funding elev. → küçük eksi)

NEWCOIN: blocked (likidite zayıf + high incident)

universe.apply.directive:

allow_symbols: [BTCUSDT, ETHUSDT, AVAXUSDT]

block_symbols: [NEWCOINUSDT]

experimental_symbols: []

Entegrasyon Notları

VIVO-18 Throttler / VIVO-16 Router: Yalnızca allow_symbols listesindeki semboller için niyet üret; experimental’a düşük hacim limiti uygulanabilir.

VIVO-24 QA: blocked sembollerden gelen sinyalleri reject("symbol_blocked").

VIVO-25 Balancer: Cluster kotaları ve set_symbol_limitleri uygular.

VIVO-30 Bandit: experimental_symbols canary trafiği olarak kısıtlı dağıtılır.

VIVO-27 Sentry: streams_panic sırasında evren daraltma yönünde sinyal verir, geri açmayı bu modül zamansal kurallara göre yapar.
_________________________________________________________________________________________________________________
VIVO-32 · telemetryDashboardEmitter.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Sistemdeki tüm modüllerden gelen metrik, sayaç, latency ve oran bilgilerini toplayıp dashboard-friendly formatta yayınlamak:

Prometheus (pull, /metrics), TSDB satır-protokolü (push; Influx/Quest/ClickHouse).

SLO/SLI tanımı ve ihlal uyarıları (error budget, p95/p99).

Servis/boru sağlığı: akış gecikmesi, mesaj oranları, hata oranları, uptime.

Minimal overhead ve idempotent yayım: aggregator → exporter’lar.

Bu modül sadece gözlemler; karar vermez. Uyarı üretir, ama “guard/policy”yi değiştirmez.

Girdiler (Events / JSON Şemaları)

Aşağıdaki olaylar diğer VIVO modüllerinden gelmektedir (hepsi opsiyoneldir; geleni işler).

// QA, Guard, Sentry, Policy, Portfolio, Bandit, Universe, Cost, Logger vb. metrikleri
{ "event": "signal.qa.metrics", "timestamp": "iso8601",
  "p99_ms": 4.6, "pass_rate": 0.62, "reject_rate": 0.28, "defer_rate": 0.10, "dup_drop_rate": 0.02, "avg_quality": 0.61 }

{ "event": "latency_slip.guard.metrics", "timestamp": "iso8601",
  "ewma": {"placeMs": 740, "firstFillMs": 1120, "slipBps": 8.9, "spreadBps": 22.1},
  "modeRates": {"normal": 0.76, "slowdown": 0.18, "block_aggressive": 0.06, "halt_entry": 0.00},
  "panicCount": 1 }

{ "event": "sentry.metrics", "timestamp": "iso8601",
  "ewma": {"pingMs": 880, "wsMsgsPerSec": 94}, "gaps": {"count": 3, "avgGap": 74}, "reconnects": 2, "endpointSwitches": 1 }

{ "event": "policy.metrics", "timestamp": "iso8601",
  "applies": 4, "rollouts": 1, "rollbacks": 0, "conflictsResolved": 2, "canaryCoveragePct": 30 }

{ "event": "portfolio.balancer.metrics", "timestamp": "iso8601",
  "approved": 6, "adjusted": 3, "deferred": 1, "rejected": 2, "avg_scale": 0.81, "top_corr_pair": "ETHUSDT:AVAXUSDT" }

{ "event": "strategy.bandit.metrics", "timestamp": "iso8601",
  "exploreRate": 0.23, "blockedRate": 0.05, "avgSamplesPerArm": 41.3, "coldStartActive": false }

{ "event": "universe.metrics", "timestamp": "iso8601",
  "scores": {"avgLiquidity": 0.84, "avgPerf": 0.31, "avgCost": 0.67},
  "counts": {"allowed": 28, "experimental": 4, "blocked": 12},
  "rotation": {"lastAt": "iso8601", "added": 2, "removed": 1 } }

{ "event": "cost.forecaster.metrics", "timestamp": "iso8601",
  "avgAdviceMs": 2.1, "adviceRates": {"info": 0.55, "warn": 0.30, "block": 0.15},
  "makerUsageSuggestRate": 0.62, "fundingWindowAvoidRate": 0.21 }

{ "event": "vivo.logger.metrics", "timestamp": "iso8601",
  "p99_ingest_ms": 3.2, "rows_appended": 142, "summaries_published": 11, "anomalies": 1 }

{ "event": "risk.incident.alert", "timestamp": "iso8601",
  "level": "warn|error", "message": "string", "context": {"type": "series_loss"} }

// Her modül kendi *.metrics olayını benzer yapıda yollar; emitter hepsini haritalar.


Ayrıca sistem kalp atışı:

{ "event": "connectivity.heartbeat", "timestamp":"iso8601",
  "latencyMs": 910, "marketStreamAlive": true, "orderStreamAlive": true, "wsEndpoint": "primary", "clockSkewMs": 1200 }

Çıktılar (Exporter veri & Uyarılar)
// Prometheus exporter anlık dump'ı (pull modeli için memory snapshot)
{
  "event": "telemetry.prom.dump",
  "timestamp": "iso8601",
  "contentType": "text/plain; version=0.0.4",
  "body": "vivo_qa_pass_rate 0.62\nvivo_qa_p99_ms 4.6\nvivo_guard_slip_ewma_bps 8.9\n..."
}

// TSDB push paketi (line protocol / JSON batch)
{
  "event": "telemetry.tsdb.batch",
  "timestamp": "iso8601",
  "lines": [
    "vivo_guard,scope=global slip_ewma_bps=8.9,place_ewma_ms=740i 1693552800000000000",
    "vivo_sentry endpoint_switches=1i,reconnects=2i,ping_ms=880i 1693552800000000000"
  ],
  "target": "primary|secondary"
}

// SLO değerlendirmesi ve uyarı
{
  "event": "telemetry.slo.status",
  "timestamp": "iso8601",
  "service": "qa|sentry|guard|bandit|balancer|policy|universe|cost|logger",
  "slo": "availability|latency_p99|decision_success_rate",
  "window": "1h|24h|7d",
  "target": "number",
  "sli": "number",
  "status": "ok|breach|at_risk",
  "errorBudgetUsedPct": "number"
}

{
  "event": "telemetry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"service":"string","slo":"string","reasonCodes":["string"]}
}

// Sağlık nabzı (self)
{
  "event": "telemetry.emitter.heartbeat",
  "timestamp": "iso8601",
  "p95_emit_ms": "number",
  "exporterQueueDepth": "number",
  "scrapeCount": "number"
}

TypeScript Arayüzleri (ürettir)

Inputs: QaMetrics, GuardMetrics, SentryMetrics, PolicyMetrics, PortfolioBalancerMetrics, BanditMetrics, UniverseMetrics, CostForecasterMetrics, LoggerMetrics, ConnectivityHeartbeat, IncidentAlert.

Outputs: PromDump, TsdbBatch, SloStatus, TelemetryAlert, EmitterHeartbeat.

Helpers: MetricRegistry, Counter, Gauge, Histogram, Summary, QuantileEstimator (CKMS/TDigest), SloTracker, LabelSet, ExporterQueue.

Zod: tüm giriş/çıkışta runtime validasyon; finite/NaN/∞ reddet.

Event Bus Konuları

In: *.metrics, connectivity.heartbeat, risk.incident.alert

Out: telemetry.prom.dump, telemetry.tsdb.batch, telemetry.slo.status, telemetry.alert, telemetry.emitter.heartbeat

Konfig & Varsayılanlar
{
  // Prometheus exporter
  prom: {
    enabled: true,
    httpPort: 9108,
    path: "/metrics",
    histogramBucketsMs: [1, 2, 5, 10, 25, 50, 100, 250, 500, 1000, 2000],
    slipBucketsBps: [1, 2, 4, 6, 8, 10, 12, 15, 20, 30]
  },

  // TSDB push
  tsdb: {
    enabled: true,
    protocol: "line",              // "line" | "json"
    endpointPrimary: "http://tsdb:8086/write",
    endpointSecondary: "http://tsdb-b:8086/write",
    batchMaxSize: 1000,
    batchMaxWaitMs: 1000,
    retryBackoffMs: [250, 500, 1000, 2000]
  },

  // SLO tanımları (hedef ve pencere)
  slo: {
    qa: { availability: { target: 0.995, window: "24h" }, latency_p99: { targetMs: 8, window: "1h" } },
    sentry: { availability: { target: 0.995, window: "24h" }, latency_p99: { targetMs: 1500, window: "1h" } },
    guard: { decision_success_rate: { target: 0.98, window: "24h" } },
    bandit: { decision_latency_p99: { targetMs: 3, window: "1h" } },
    balancer: { approve_or_adjust_rate: { target: 0.8, window: "24h" } },
    policy: { apply_success_rate: { target: 0.99, window: "24h" } }
  },

  // Örnekleme / downsample
  sampling: { metricsEveryNth: 1, heavySeriesEveryNth: 3 },

  // Etiketler
  labels: { env: "prod", service: "vivo", instance: "vivo32-01" },

  // Telemetri
  metricsFlushSec: 10,
  emitterHeartbeatSec: 30,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

MetricRegistry:

Counters/Gauges: isim + LabelSet (ör. symbol, variant, service).

Histograms/Summaries: CKMS/TDigest ile p90/p95/p99; bucket counters.

SloTracker (service×sloKey):

SLI zaman pencereleri: halka arabellek (1m dilimler); error budget hesap.

ExporterQueue:

Prom dump memory snapshot (idempotent), TSDB batch kuyruğu (retry/backoff).

Persist (opsiyonel): data/telemetry.state.json (yalnızca SLO pencereleri); crash sonrası devam.

SLI Tanımları (örnekler)

QA availability = pass + defer > 0 ? pass / (pass + reject + defer) : 1.0

QA latency_p99 = p99_ms (signal QA döngüsü).

Sentry availability = marketStreamAlive && orderStreamAlive dakika başına oran.

Guard decision_success_rate = directive_published / directive_attempted.

Bandit decision_latency_p99 = seçim döngüsü p99 (ms).

Balancer approve_or_adjust_rate = (approved + adjusted) / (approved + adjusted + rejected + deferred).

Policy apply_success_rate = applies_success / applies_total (apply çıktısı olan modüller raporlar).

Exchange connectivity (opsiyonel SLI): heartbeat within timeout oranı.

Algoritma (Akış)

Ingest & Map

Gelen *.metrics olayını Zod’la doğrula → MetricRegistry’de ilgili serilere haritala:

Örn: signal.qa.metrics.pass_rate → gauge vivo_qa_pass_rate{tf="*",source="all"}.

p99_ms → histogram/summary güncelle.

modeRates.* → çok-etiketli gauge (mode).

connectivity.heartbeat → sentry_availability SLI pencere güncelle.

SLO Hesapla

Her metricsFlushSec → SLI pencerelerini hesapla, hedefle karşılaştır:

status = ok|at_risk|breach → telemetry.slo.status yayınla.

breach durumunda telemetry.alert(level="error").

Exporters

Prometheus: Bellekteki MetricRegistry → /metrics dump (pull).

TSDB: Son metricsFlushSec’te değişen ölçümler → telemetry.tsdb.batch (push, retry/backoff).

Sampling & Downsample

sampling.heavySeriesEveryNth ile yüksek hacimli serilerde (ör. per-symbol histograms) downsample uygula.

Labeling & Idempotency

Global labels her seriye eklenir. Aynı zaman diliminde aynı seri iki kez gönderilmez (hash/kadran anahtarı).

Alarm Kuralları

Pik değerler: guard.slip_ewma_bps ≥ slipPanicBps veya sentry.ping_ms p99 > target → warn/error.

Error budget burn: 1h pencerede >20% tüketim → at_risk uyarısı.

Self Heartbeat

Her emitterHeartbeatSec → telemetry.emitter.heartbeat (p95 emit ms, queue depth, scrape count).

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/telemetryDashboardEmitter.ts

src/vivo/state/metricsRegistry.ts, src/vivo/lib/ckms.ts (veya t-digest), src/vivo/lib/lineProtocol.ts, src/vivo/lib/slo.ts

__tests__/telemetryDashboardEmitter.test.ts

Mimari

Saf çekirdek: ingest(event) → updates[], tick(now) → {promDump?, tsdbBatch?, sloStatuses[], alerts[]}

IO adaptörü: HTTP server (Prom dump), TSDB HTTP client, bus publish/subscribe.

Validasyon

Zod; ölçümler finite(). Negatif ms/bps → discard + telemetry.alert(warn,"invalid_metric").

Performans

p99 ingest < 2ms; dump < 20ms; batch push < 50ms hedef. GC baskısını azaltmak için object pool veya reused buffers.

Güvenlik

/metrics endpoint’ini opsiyonel basic auth / allowlist ile koru (config).

Test İskeleti (Jest)

qa.metrics ingest → prom/gauges & histograms doğru dolar.

slo: qa.availability 0.994 < 0.995 → breach + telemetry.alert(error).

sentry heartbeat false → availability SLI düşer.

tsdb.batch boyut/timeout → retryBackoff uygular.

sampling heavySeriesEveryNth → seri sayısı azalır.

idempotent dump → aynı snapshot tekrarı yok.

invalid metric → alert(warn) ve seri güncellenmez.

Örnek Senaryo (Özet)

Durum

10 sn’de bir qa.metrics, guard.metrics, sentry.metrics, bandit.metrics akıyor.

Son 1 saatte qa.p99_ms hedef 8ms, gözlem ~9.1ms; pass_rate 0.61.

3 reconnect ve bir endpoint switch yaşanmış.

Beklenen Yayınlar

/metrics dump’ında:

vivo_qa_pass_rate 0.61, vivo_qa_p99_ms 9.1, vivo_guard_mode_rate{mode="slowdown"} 0.18, vivo_sentry_endpoint_switches_total 1 …

telemetry.slo.status(qa.latency_p99) → breach, errorBudgetUsedPct ≈ 35%

telemetry.alert(error,"qa_latency_p99_breach")

telemetry.tsdb.batch push: line-proto ile yukarıdaki metrikler (env/service/instance label’ları ile).

Entegrasyon Notları

Ops/Dev dashboard’ları (Grafana/Kibana) bu modülün Prom/TSDB çıktısını veri kaynağı yapar.

VIVO-27/26 ihlallerinde emitter sadece uyarı üretir; guard/policy’ye müdahale etmez.

SLO’lar haftalık rapor ve Denetim Asistanı için telemetry.slo.status akışından alınır.
_________________________________________________________________________________________________________________
VIVO-33 · incidentNotificationBridge.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Risk olayları ve kritik telemetri/SLO ihlallerini Telegram/Discord/Email/Webhook gibi kanallara akıllı şekilde köprülemek:

Sessiz saat (quiet hours) ve soaking (X sn bekle, benzerleri tek mesajda topla),

Dedupe (aynı incident tekrarlarını bastır), oran sınırlama (rate-limit),

Eskalasyon (on-call rotası), ACK/Resolve geri akışı,

Şablonlama (platforma uygun Markdown/format), yerelleştirme (TR/EN),

Güvenlik (imza, webhook secret), audit (kim, ne zaman, nereye gönderildi).

Bu modül sadece bildirim köprüler; risk/policy kararını değiştirmez.

Girdiler (Event / JSON Şemaları)
// Kritik sinyaller (birincil)
{
  "event": "risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "incidentId": "string",
  "type": "series_loss|drawdown_breach|exposure_breach|execution_anomaly|data_staleness|emergency_halt|limit_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "openReasonCodes": ["string"],
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "notes": "string|null"
}

{
  "event": "telemetry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"service":"string","slo":"string|null","reasonCodes":["string"],"symbol":"string|null"}
}

{
  "event": "telemetry.slo.status",
  "timestamp": "iso8601",
  "service": "qa|sentry|guard|bandit|balancer|policy|universe|cost|logger",
  "slo": "availability|latency_p99|decision_success_rate|...",
  "window": "1h|24h|7d",
  "target": "number",
  "sli": "number",
  "status": "ok|breach|at_risk",
  "errorBudgetUsedPct": "number"
}

// On-call & kanal haritası
{
  "event": "oncall.roster",
  "timestamp": "iso8601",
  "rotation": [
    {"team":"core","primary":{"name":"string","contact":{"telegramUserId":"number","email":"string"}},"secondary":{"name":"string","contact":{"telegramUserId":"number","email":"string"}},"since":"iso8601"}
  ]
}

{
  "event": "bridge.channel.map",
  "timestamp": "iso8601",
  "routes": [
    {"match":{"event":"risk.incident.*","severity":">=high"},"channels":["telegram:ops","discord:#incidents","email:oncall@acme.io"]},
    {"match":{"service":"sentry","status":"streams_panic"},"channels":["telegram:ops"],"rateLimitPerMin":2}
  ]
}

// Kullanıcı/ekip tercihleri
{
  "event": "bridge.prefs",
  "timestamp": "iso8601",
  "locale": "tr|en",
  "quietHours": {"start":"HH:mm","end":"HH:mm","timezone":"Europe/Istanbul"},
  "mute": {"symbols":["string"],"incidentTypes":["string"]},
  "digest": {"enabled": true, "periodMin": 15}
}

// Geri akış (kanallardan ACK/resolve komutu, webhook/bot ile)
{
  "event": "bridge.inbound.command",
  "timestamp": "iso8601",
  "channel": "telegram|discord|email|webhook",
  "userId": "string",
  "cmd": "ack|resolve|note",
  "incidentId": "string",
  "note": "string|null",
  "signature": "hex"
}

Çıktılar (Köprü Mesajları & Akış)
// Platformdan bağımsız çıkış (iç katman)
{
  "event": "bridge.notification.outgoing",
  "timestamp": "iso8601",
  "dedupeKey": "string",
  "channels": ["telegram:ops","discord:#incidents","email:oncall@acme.io","webhook:https://..."],
  "title": "string",
  "body": "markdown",
  "severity": "low|medium|high|critical",
  "threadKey": "string",                  // incidentId veya sloKey
  "actions": [{"type":"ack","incidentId":"string"},{"type":"resolve","incidentId":"string"}],
  "context": {"incidentId":"string|null","service":"string|null","symbol":"string|null"},
  "ttlSec": 900
}

// Kanal özgül “send” olayları (adaptörler dinler ve gönderir)
{
  "event": "bridge.telegram.send",
  "timestamp": "iso8601",
  "chat": "ops|dev|customId",
  "threadKey": "string",
  "text": "markdown",
  "buttons": [{"text":"ACK","callback":"ack:INC-123"},{"text":"RESOLVE","callback":"resolve:INC-123"}]
}

{
  "event": "bridge.discord.send",
  "timestamp": "iso8601",
  "channel": "#incidents",
  "threadKey": "string",
  "embed": {
    "title":"string","description":"markdown",
    "color":"int","fields":[{"name":"Symbol","value":"AVAXUSDT","inline":true}]
  },
  "components": [{"type":"buttons","items":[{"label":"ACK","customId":"ack:INC-123"}]}]
}

{
  "event": "bridge.email.send",
  "timestamp": "iso8601",
  "to": ["oncall@acme.io"],
  "subject": "[HIGH] exposure_breach AVAXUSDT",
  "html": "<p>…</p>",
  "threadKey": "string",
  "headers": {"Message-Id":"<...>","In-Reply-To":"<...>"}
}

{
  "event": "bridge.webhook.send",
  "timestamp": "iso8601",
  "url": "https://hooks.example/xyz",
  "method": "POST",
  "headers": {"X-Signature":"hex"},
  "json": {"title":"…","severity":"high","incidentId":"INC-123","link":"https://…"}
}

// ACK/Resolve dışa yansıma (iç sisteme geri)
{
  "event": "incident.acknowledged",
  "timestamp": "iso8601",
  "incidentId": "string",
  "by": {"userId":"string","channel":"telegram|discord|email|webhook"},
  "note": "string|null"
}

{
  "event": "incident.resolved.external",
  "timestamp": "iso8601",
  "incidentId": "string",
  "by": {"userId":"string","channel":"telegram|discord|email|webhook"},
  "note": "string|null"
}

// Telemetri & uyarı
{
  "event": "bridge.metrics",
  "timestamp": "iso8601",
  "sent": {"telegram": "number","discord":"number","email":"number","webhook":"number"},
  "suppressed": {"quiet":"number","dedupe":"number","rate":"number"},
  "ackMedianSec": "number",
  "errorRate": "number"
}
{
  "event": "bridge.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"channel":"string|null"}
}

TypeScript Arayüzleri (ürettir)

Inputs: RiskIncidentEvent, TelemetryAlert, SloStatus, OncallRoster, BridgeChannelMap, BridgePrefs, InboundCommand.

Outputs: BridgeNotificationOutgoing, BridgeTelegramSend, BridgeDiscordSend, BridgeEmailSend, BridgeWebhookSend, IncidentAcknowledged, IncidentResolvedExternal, BridgeMetrics, BridgeAlert.

Helpers: TemplateEngine (Markdown/HTML), RateLimiter, DedupeCache, SoakBuffer, QuietHours, EscalationPlan, Signer (HMAC), ThreadIndex, LocaleDict.

Zod: tüm giriş/çıkışlarda runtime validasyon.

Event Bus Konuları

In: risk.incident.*, telemetry.alert, telemetry.slo.status, oncall.roster, bridge.channel.map, bridge.prefs, bridge.inbound.command

Out: bridge.notification.outgoing, bridge.*.send, incident.acknowledged, incident.resolved.external, bridge.metrics, bridge.alert

Konfig & Varsayılanlar
{
  // Sessiz saat ve soaking
  quietHours: { start: "23:30", end: "07:30", timezone: "Europe/Istanbul" },
  soak: { windowSec: 60, maxBatch: 5 },                // benzer olayları 60 sn topla

  // Dedupe & rate-limit
  dedupe: { windowSec: 300 },                          // aynı dedupeKey'i bastır
  rate: { telegramPerMin: 8, discordPerMin: 8, emailPerMin: 20, webhookPerMin: 30 },

  // Eskalasyon
  escalation: {
    stages: [
      { afterSec: 300, channels: ["telegram:ops"], target: "primary" },
      { afterSec: 900, channels: ["telegram:ops","email:oncall@acme.io"], target: "secondary" }
    ],
    requireAckSeverities: ["high","critical"]
  },

  // Şablonlar
  templates: {
    title: "[${severity}] ${type} ${symbol ?? ''}",
    bodyTR: "Olay: **${type}**\nŞiddet: **${severity}**\nSembol: ${symbol ?? '-'}\nNot: ${notes ?? '-'}\nMetrikler: ${metricsStr}",
    bodyEN: "Incident: **${type}**\nSeverity: **${severity}**\nSymbol: ${symbol ?? '-'}\nNotes: ${notes ?? '-'}\nMetrics: ${metricsStr}"
  },

  // Güvenlik
  secrets: { webhookHmacKey: "env:BRIDGE_HMAC", emailFrom: "vivo@acme.io" },

  // Haritalama (renk/kod)
  severityColors: { low: 0x2e7d32, medium: 0xf9a825, high: 0xef6c00, critical: 0xc62828 },

  // Lokalizasyon varsayılanı
  defaultLocale: "tr",

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

BridgeState (in-memory + periyodik persist data/bridge.state.json):

prefs, routes, oncallRoster, quietRangeToday, dedupeIndex (key→expiresAt),

soakBuffer (threadKey→[events]), threadIndex (incidentId|sloKey→threadKey),

acks (incidentId→{ackAt, by}), pendingEscalations zamanlayıcıları,

Kanal başına rateLimiter sayaçları.

Idempotency: dedupeKey (eventType + incidentId/sloKey + severity + roundedMinute) ile tekrarları yut.

Şablonlama & Dedupe Anahtarları

threadKey = incidentId ?? "${service}:${slo}:${window}".

dedupeKey = threadKey + ":" + severity + ":" + floor(now, 1m).

metricsStr yardımcı fonksiyon: {totalRiskPctOpen:1.8, slipBps:17} → "risk=1.8%, slip=17bps".

Algoritma (Karar Akışı)

Normalize & Filtrele

Zod validasyon; prefs.mute eşleşirse drop (telemetriye suppressed yaz).

routes ile eşleşen kanal setini çıkar; yoksa varsayılan kanal(lar).

Quiet Hours & Soaking

Quiet aralığındaysa olay soakBuffer’a eklenir; pencere sonunda tek batched mesaj oluşturulur (özet listesi).

Quiet dışındaysa soak.windowSec kısa bekleme ile benzerleri toplayıp gönder.

Dedupe & Rate-Limit

dedupeKey aktifse suppress; değilse insert.

Kanal başına oran sınırı aşılırsa ilgili kanala suppress + bridge.alert(warn,"rate_limited").

Eskalasyon

severity ∈ requireAckSeverities ve ack yoksa:

Stage-1 zamanlayıcı: afterSec dolunca hâlâ ack yoksa ek kanallara gönder.

Stage-2 … (çoklu aşama destekli).

ACK geldiğinde tüm bekleyen eskalasyonlar iptal.

Şablonlama & Lokalizasyon

locale = prefs.locale || defaultLocale. TemplateEngine ile başlık/gövde üret (TR/EN).

Platform özelindeki Markdown/HTML farklarını uygula (Telegram vs Discord).

Gönderimler

bridge.notification.outgoing → adaptörler bridge.telegram.send|discord.send|email.send|webhook.send üretir.

Webhook için Signer(HMAC) ile X-Signature.

Inbound Komutlar (ACK/Resolve/Note)

bridge.inbound.command imzasını doğrula (gerekiyorsa).

incident.acknowledged veya incident.resolved.external yayınla.

İlgili thread’e ACK/RESOLVED güncellemesi gönder (kanallara küçük edit mesajı).

Telemetri

bridge.metrics her 10 sn: gönderilen/suppressed/ackMedianSec vb.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/incidentNotificationBridge.ts

src/vivo/state/bridgeStore.ts (prefs/routes/roster/soak/dedupe/rate persist)

src/vivo/lib/template.ts, src/vivo/lib/quiet.ts, src/vivo/lib/ratelimit.ts, src/vivo/lib/hmac.ts

Kanal adaptörleri: src/vivo/adapters/telegram.ts, discord.ts, email.ts, webhook.ts

__tests__/incidentNotificationBridge.test.ts

Mimari

Çekirdek: ingest(event, state, cfg) → emissions[]

Adaptörler: “send” olaylarını gerçek kanala çevirir (burada sadece arayüz; secrets/env kullanılacak).

Validasyon

Zod; şiddet map: risk.severity → bridge.severity.

Güvenlik

Webhook imzalama, inbound komutlarda imza/doğrulama opsiyonu.

Performans

p99 < 5ms; soak batch işlemi zamanlayıcıyla.

Test İskeleti (Jest)

risk.incident.open(high) → telegram+discord gönderildi, email yoksa config gereği

quiet hours → soak ile tek batched mesaj

dedupe window → ikinci aynı olay suppressed

rate limit aşıldı → suppressed + bridge.alert(warn)

ACK gelmedi → 5 dk sonra Stage-2 eskalasyon email

inbound ack → incident.acknowledged yayınlandı; eskalasyonlar iptal

webhook signature doğrulaması

locale=tr → gövde TR / locale=en → EN

threadKey tutarlılığı (incidentId bazlı)

Örnek Senaryo (Özet)

Durum

00:05 (quiet hours içinde). risk.incident.open(severity=high, type="exposure_breach", symbol="AVAXUSDT", incidentId="INC-884")

00:05:30 risk.incident.update(severity=high, slipBps=19)

00:06:10 soaking penceresi biter, ACK yok.

Beklenen Yayınlar

{
  "event":"bridge.notification.outgoing",
  "channels":["telegram:ops","discord:#incidents"],
  "title":"[high] exposure_breach AVAXUSDT",
  "body":"Olay: **exposure_breach**\nŞiddet: **high**\nSembol: AVAXUSDT\nMetrikler: risk=1.9%, slip=19bps\nÖzet: 2 güncelleme soğuruldu.",
  "severity":"high",
  "threadKey":"INC-884",
  "actions":[{"type":"ack","incidentId":"INC-884"},{"type":"resolve","incidentId":"INC-884"}],
  "ttlSec":900
}


ACK gelmezse 5. dakikada:

{"event":"bridge.email.send","to":["oncall@acme.io"],"subject":"[HIGH] exposure_breach AVAXUSDT","threadKey":"INC-884","html":"<p>…</p>"}


Telegram’dan operatör ACK tuşuna basar:

{"event":"incident.acknowledged","incidentId":"INC-884","by":{"userId":"@opslead","channel":"telegram"}}


Eskalasyon zamanlayıcıları iptal edilir; kanallara küçük “ACKed by @opslead” güncellemesi düşer.

Entegrasyon Notları

VIVO-23: risk.incident.* olaylarının incidentId’si köprüde threadKey’dir.

VIVO-27/32: telemetry.alert|slo.status kritik olanları köprülenir; düşük önemdekiler yalnızca dashboard’da kalabilir (route/prefs ile).

Geri akış: incident.acknowledged|resolved.external sinyallerini Denetim Asistanı ve Policy raporlama için dinleyebilir.

Gizlilik: E-posta/Discord’a PII koyma; linkleri imzalı panel URL’siyle ver.
_________________________________________________________________________________________________________________
VIVO-34 · backtestReplayHarness.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Tarihî verileri gerçek zamanlı akış gibi event bus’a enjekte ederek tüm VIVO zincirini uçtan uca test etmek:

Hız kontrolü (1×/2×/5×/bar-close), duraklat/başlat/geri-sar/ileri-sar/seek,

Hata/fault enjeksiyonu (jitter, kayıp paket, tekrar/çift, yeniden sıralama, kesinti),

Deterministik yürütme (seed), yerel saat (Europe/Istanbul) emülasyonu,

Oracle/Ground-Truth karşılaştırması (gerçek sonuçlarla kıyas; PnL/hit/slip farkları),

Ölçüm & raporlama (throughput, gecikme, drop/reorder sayıları, değerlendirme metrikleri).

Gerçek borsaya bağlanmadan, tüm modülleri canlı koşuyormuş gibi sürmek.

Bu modül sadece veri akıtır ve ölçer; risk/policy/karar mantığına müdahale etmez.

Girdiler (Event / JSON Şemaları)
// replay.manifest — dataset ve akış haritası
{
  "event": "replay.manifest",
  "timestamp": "iso8601",
  "datasetId": "string",
  "tz": "Europe/Istanbul",
  "range": { "start": "iso8601", "end": "iso8601" },
  "sources": [
    {
      "type": "jsonl|csv|parquet",
      "path": "file:///data/bars_M5.jsonl",
      "topic": "market.bar",                 // konu adı (aşağıdaki "out map" ile canlı olaya dönüşecek)
      "timeField": "ts",                     // epochMs | iso
      "symbolField": "symbol",
      "schemaHint": "bar_M5_v1"
    },
    {
      "type": "jsonl",
      "path": "file:///data/aggTrades.jsonl",
      "topic": "market.aggTrade",
      "timeField": "ts",
      "symbolField": "symbol",
      "schemaHint": "agg_v1"
    },
    {
      "type": "jsonl",
      "path": "file:///data/funding_8h.jsonl",
      "topic": "funding.snapshot",
      "timeField": "timestamp",
      "symbolField": "symbol",
      "schemaHint": "funding_v1"
    }
  ],
  "outMap": [
    { "from":"market.bar", "to":"market.refs" },      // bar → refs (mid/spread türetilebilir)
    { "from":"market.aggTrade", "to":"market.trade.tick" },
    { "from":"funding.snapshot", "to":"funding.snapshot" }
  ],
  "groundTruth": {
    "trades": { "type":"jsonl","path":"file:///data/oracle_trades.jsonl","idField":"tradeId" },
    "pnl":    { "type":"jsonl","path":"file:///data/oracle_pnl.jsonl","key":["tradeId"] }
  },
  "clock": { "mode":"wall|bar_close", "tickMs": 200 },  // wall: duvar saatiyle akar, bar_close: bar kapanışlarında ilerler
  "seed": "vivo34-replay"
}

// replay.control — kontrol komutları
{
  "event": "replay.control",
  "timestamp": "iso8601",
  "cmd": "load|start|pause|resume|stop|seek|speed|bookmark|restore|shutdown",
  "args": {
    "datasetId": "string|null",
    "speed": "0.25|0.5|1|2|5|10|bar",     // bar = bar_close adımı
    "seekTo": "iso8601|null",
    "filters": { "symbols": ["AVAXUSDT","BTCUSDT"], "timeframes": ["M1","M5"], "topics": ["market.*","funding.snapshot"] },
    "bookmarkId": "string|null"
  }
}

// replay.faults — hata/fault enjeksiyonu
{
  "event": "replay.faults",
  "timestamp": "iso8601",
  "dropProb": 0.00,          // 0..1
  "dupProb": 0.00,
  "reorderProb": 0.00,
  "reorderJitterMs": 150,    // yeniden sıralama için rastgele gecikme
  "latencyJitterMs": 50,     // yayın öncesi jitter
  "outages": [               // akış kesintisi pencereleri
    { "start":"iso8601","end":"iso8601","topics":["market.*"] }
  ]
}

// replay.mapping.override — alan/dönüşüm override (opsiyonel)
{
  "event": "replay.mapping.override",
  "timestamp": "iso8601",
  "map": {
    "market.bar → market.refs": { "mid":"(o+h+l+c)/4", "spreadBps":"derived_by_model" }
  }
}


Not: Bu modül, diğer modüllerin zaten tanımlı olay şemalarını yeniden kullanır: market.refs, funding.snapshot, connectivity.heartbeat, vb.

Çıktılar (Akış, Durum, Ölçüm, Değerlendirme)
// Akıtılan canlı olaylar (örnek)
{ "event":"market.refs", "timestamp":"iso8601", "symbol":"AVAXUSDT", "mid":12.34, "bestBid":12.33, "bestAsk":12.35, "spreadBps":8.1, "volZScore":1.2 }

{ "event":"funding.snapshot", "timestamp":"iso8601", "symbol":"AVAXUSDT", "period":"8h", "lastFundingRateBp":32, "nextFundingTime":"iso8601", "predictedNextRateBp":35 }

// Yapay kalp atışı (canlı saat emülasyonu)
{ "event":"replay.clock.tick", "timestamp":"iso8601", "now":"iso8601", "lagMs":"number" }

// İlerleme ve durum
{
  "event": "replay.status",
  "timestamp": "iso8601",
  "state": "idle|loaded|running|paused|stopped",
  "datasetId": "string|null",
  "speed": "number|string",
  "progress": { "cursor":"iso8601","start":"iso8601","end":"iso8601","pct":"number" },
  "filters": {"symbols":["string"],"topics":["string"]},
  "faultsActive": true
}

// Ölçümler
{
  "event": "replay.metrics",
  "timestamp": "iso8601",
  "eventsOutPerSec": "number",
  "avgLagMs": "number",
  "drops": "number",
  "dups": "number",
  "reorders": "number",
  "outageWindows": "number",
  "bufferFillPct": "number"
}

// Yer imleri (bookmark) & restore
{
  "event": "replay.bookmark.saved",
  "timestamp": "iso8601",
  "bookmarkId": "string",
  "cursor": "iso8601",
  "seed": "string",
  "filters": {"symbols":["string"],"topics":["string"]}
}

// Uyarı/Alarm
{
  "event": "replay.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"datasetId":"string","reasonCodes":["string"]}
}

// Değerlendirme: ground-truth kıyas
{
  "event": "replay.eval.sample",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "expected": {"hit":0|1,"r":"number","slipBps":"number"},
  "observed": {"hit":0|1,"r":"number","slipBps":"number"},
  "deltas": {"hit":"-1|0|+1","r":"number","slipBps":"number"},
  "reasonCodes": ["match|miss|slip_diff|rr_diff"]
}

{
  "event": "replay.eval.report",
  "timestamp": "iso8601",
  "datasetId": "string",
  "summary": {
    "samples": "number",
    "hitAcc": "number",
    "rMse": "number",
    "slipMse": "number",
    "winRateExp": {"expected":"number","observed":"number"},
    "profitFactor": {"expected":"number","observed":"number"}
  },
  "bySymbol": [{"symbol":"string","samples":"number","deltaWinRate":"number","deltaPF":"number"}]
}

TypeScript Arayüzleri (ürettir)

Inputs: ReplayManifest, ReplayControl, ReplayFaults, ReplayMappingOverride.

Outputs: ReplayClockTick, ReplayStatus, ReplayMetrics, ReplayBookmarkSaved, ReplayAlert, ReplayEvalSample, ReplayEvalReport.

Helpers: DatasetReader (jsonl/csv/parquet), StreamMapper (from→to dönüştürme), Clock, RingBuffer, Rng, FaultInjector, Bookmark, Indexer (time→offset), EvalJoiner (oracle↔observed).

Zod ile tüm giriş/çıkışlarda runtime validasyon; tarih alanları ISO, sayılar finite().

Event Bus Konuları

In: replay.manifest, replay.control, replay.faults, replay.mapping.override

Out: canlı veri (market.refs, funding.snapshot, …), replay.clock.tick, replay.status, replay.metrics, replay.bookmark.saved, replay.eval.sample, replay.eval.report, replay.alert

Konfig & Varsayılanlar
{
  io: { readBatchSize: 5000, prefetchSec: 5, maxBufferEvents: 20000 },
  speed: { default: 1, allowed: [0.25,0.5,1,2,5,10,"bar"] },
  clock: { tickMs: 200, catchUpPct: 0.25 },            // lag varsa hızlandığı oran
  filterDefaults: { symbols: [], topics: [] },         // boş = hepsi
  faults: { dropProb: 0, dupProb: 0, reorderProb: 0, reorderJitterMs: 0, latencyJitterMs: 0, outages: [] },
  eval: { joinKey: "tradeId", allowTimeSkewMs: 1500, slipToleranceBps: 2, rTolerance: 0.05 },
  seed: "vivo34-replay",
  metricsFlushSec: 5,
  tz: "Europe/Istanbul"
}

Durum Yönetimi

ReplayState (in-memory + periyodik persist data/replay.state.json):

datasetId, manifest, cursorTs, startTs, endTs, state (idle/loaded/running/paused/stopped),

filters, speed, clockMode, rng(seed), buffer (min-heap/zaman sıralı),

indexers (source→time→offset), bookmarks (id→{cursor,seed,filters}),

faults, outageWindows, lastMetrics, progress.

Idempotency: eventHash ile rewind/seek sonrası aynı olay ikinci kez yayınlanmaz (opsiyon).

Akış Dönüşümü (OutMap)

market.bar → market.refs:
mid = (open+high+low+close)/4, spreadBps ≈ clamp((high-low)/mid*1e4, 0, 200), volZScore yoksa null/0.
bestBid/Ask opsiyonel: mid ± spread/2.

market.aggTrade → market.trade.tick: alan eşle.

funding.snapshot zaten hedef formatta.

MappingOverride ile türev alanlar değiştirilebilir (örn. spread hesap yöntemi).

Algoritma (Karar Akışı)

Manifest Yükle & İndeksle

replay.manifest → Zod doğrula; her kaynak için hafif index (timestamp → byte offset) oluştur veya mevcut index’i yükle.

outMap doğrula; bilinmeyen from→to için replay.alert(error,"unknown_map").

Hazırla (load)

replay.control(cmd=load) → Reader’lar açılır, state="loaded", cursor=start.

filters uygulanır; replay.status yayınla.

Çalıştır (start/resume)

Saat modu wall: her tickMs’de clock.tick ve cursor ile now arasında kalan olayları oku → buffer’a koy.

bar_close: bir sonraki bar kapanış timestamp’ine atla; aradaki olayları toplu yayınla.

Prefetch: prefetchSec kadar ileri olayları önceden buffer’a al.

Fault Enjeksiyonu

Her event, FaultInjector’dan geçer:

dropProb → düşür,

dupProb → aynı event’i ikinci kez sıraya koy,

reorderProb → reorderJitterMs kadar rasgele gecikmeyle sırayı boz,

latencyJitterMs → yayım öncesi beklet,

outages → belirli pencerelerde/topiklerde event bastır.

Sayacı güncelle (drops/dups/reorders/outages).

Yayın

Buffer’daki zamanı gelen olayları outMap.to konularında yayınla.

Her adımda replay.clock.tick ve per metricsFlushSec replay.metrics.

Kontroller

pause → saat durur, buffer korunur; resume → devam.

seek(ts) → tüm reader’lar index ile ts’e sarılır; buffer temizlenir.

speed(x) → hız çarpanı değişir; catchUpPct ile lag varsa bir süre yüksek hız uygula.

bookmark(id) → {cursor,seed,filters} kaydet; restore(id) → aynı noktaya/seed’e geri.

Değerlendirme (Oracle)

Sistem alt modülleri koşarken, vivo.logger veya trade.summary.closed çıktılarını dinle (observed).

Oracle groundTruth.trades/pnl dosyalarıyla joinKey veya zaman+sembol yakınlığıyla eşle.

Her eşleşme için replay.eval.sample; test sonunda replay.eval.report.

Stop/Shutdown

stop → akış biter; state="stopped".

shutdown → kaynaklar kapatılır, state persist edilir.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/backtestReplayHarness.ts

src/vivo/state/replayStore.ts (manifest/state/index/bookmark persist)

src/vivo/lib/reader.ts (jsonl/csv/parquet), src/vivo/lib/fault.ts, src/vivo/lib/clock.ts, src/vivo/lib/indexer.ts, src/vivo/lib/eval.ts

__tests__/backtestReplayHarness.test.ts

Mimari

Çekirdek: advance(event, state, cfg, now) → emissions[] (deterministik state machine).

IO adaptörü: dosya okuyucular, zamanlayıcı, bus publish/subscribe.

Validasyon

Zod; tarih parse hatasında replay.alert(warn,"bad_timestamp"), event drop.

Performans

20k ev/s yayın hedef; buffer ve prefetch ile I/O gizle. p99 < 5ms event enjekte döngüsü.

Deterministiklik

RNG seed + datasetId+cursor → fault/jitter aynı şekilde tekrar üretilebilmeli.

Gün Sonu

Metrik sayaçlarını Europe/Istanbul gün sonunda sıfırla (replay bitmiyorsa rulover).

Test İskeleti (Jest)

load→start→pause→resume→stop durum geçişleri.

seek doğru çalışır; cursor ve buffer resetlenir.

speed 5× → eventsOutPerSec artar; bar modunda sadece bar kapanışlarında ilerler.

faults.dropProb=0.1 → drops sayacı ~%10 civarı.

reorderProb>0 → zaman sırasına aykırı yayınlar histerezisle düzeltilir (buffer toleransı).

bookmark/restore deterministiktir (aynı seed → aynı sıralama).

eval join doğru; tolerans altında farklar match sayılır.

outage window içinde ilgili topic’ler susar; sonra normale döner.

mapping.override ile spread formülü değişir.

Örnek Senaryo (Özet)

Manifest

bars_M5.jsonl (2025-05-01 08:00 → 2025-05-01 12:00), aggTrades.jsonl, funding_8h.jsonl.

outMap: market.bar → market.refs.

Kontroller

load(datasetId="session-avax-0501") → start(speed=2×, filters.symbols=["AVAXUSDT"]).

30 dk sonra faults: reorderProb=0.1, reorderJitterMs=120, latencyJitterMs=25.

09:30 için bookmark("b1"). 10:10’da pause, seek(09:45), resume.

Bitişte stop ve rapor.

Beklenen Yayınlar

Akış boyunca market.refs ve funding.snapshot olayları akar; replay.clock.tick ve replay.metrics düzenli gelir.

Sonunda:

{
  "event":"replay.eval.report",
  "datasetId":"session-avax-0501",
  "summary":{"samples":124,"hitAcc":0.92,"rMse":0.07,"slipMse":2.3,"winRateExp":{"expected":0.55,"observed":0.53},"profitFactor":{"expected":1.42,"observed":1.37}},
  "bySymbol":[{"symbol":"AVAXUSDT","samples":124,"deltaWinRate":-0.02,"deltaPF":-0.05}]
}

Entegrasyon Notları

Gerçek borsa yok: Sentry/Guard/Policy modülleri bu akışta canlı sanır; harness gerekli replay.clock.tick/connectivity.heartbeat sinyallerini sağlayabilir.

VIVO-22 Logger’ın trade.summary.closed çıktıları observed olarak yakalanır; oracle dosyalarıyla kıyaslanır.

VIVO-26/27’de fault/outage sinyalleri doğal tetiklenir; SLO/telemetri ölçümleri VIVO-32 ile görülebilir.

Performans/ölçek: Çok dosyalı evrende sembol başına worker (opsiyonel) ama karar sırayı bozmadan birleşik saatle yayın.
_________________________________________________________________________________________________________________
VIVO-35 · dataRetentionAndPrivacyManager.ts — Gelişmiş Prompt v3 (AI’ye verilecek kodlama yol-promptu)
Amaç

Log/veri saklama kurallarını merkezî yöneten, PII temizliği/anonimleştirme/maskeleme yapan, ihracat (export) ve silme (erasure) taleplerini işleyen gizlilik katmanı.

Kategori-bazlı saklama süreleri, data lineage & tag ile uygun silme/erken-redaksiyon; şifreleme/pseudonymization; denetim izi.

VIVO-22 Logger, VIVO-32 Telemetry, VIVO-33 Bridge dahil tüm üreticilerin log/metrik olaylarını privacy-aware hale getirir.

Bu modül yalnızca veri yaşam döngüsünü yönetir; ticaret/risk kararlarına dokunmaz.

Veri Sınıflandırma (dahili taksonomi)

PUBLIC: herkese açık; kimlik içermez (örn. aggregate metrik).

SENSITIVE_LOW: sınırlı kimlik ipuçları (örn. kullanıcı takma adları, chat id).

PII_BASIC: e-posta, telefon, kullanıcı id, IP.

PII_STRICT: ulusal kimlik no, tam ad + doğum, adres.

FINANCIAL: hesap/iban, cüzdan adresi.

SECRET: API key/token (çıktılarda asla gösterme).

Olaylar data.tags.classification ile etiketlenir; yoksa varsayılan konservatif politika uygulanır.

Girdiler (Event / JSON Şemaları)
// privacy.policy.update — saklama & maskeleme kuralları
{
  "event": "privacy.policy.update",
  "timestamp": "iso8601",
  "version": "number",
  "retention": {
    "PUBLIC": "P365D",
    "SENSITIVE_LOW": "P180D",
    "PII_BASIC": "P90D",
    "PII_STRICT": "P30D",
    "FINANCIAL": "P180D",
    "SECRET": "P0D"
  },
  "masking": {
    "PII_BASIC": {"email":"mask","phone":"mask","ip":"truncate"},
    "PII_STRICT": {"id":"hash","address":"drop"},
    "SECRET": {"api_key":"drop","token":"drop"}
  },
  "encryption": {
    "atRest": true,
    "keyAlias": "kms:vivo35-rotating",
    "rotateDays": 90
  },
  "redaction": {
    "telemetry": {"fields":["user","email","ip"], "mode":"hash"},
    "alerts": {"fields":["email","phone"], "mode":"mask"}
  },
  "defaults": {"classification":"SENSITIVE_LOW"}
}

// data.ingest — tüm modüllerin gönderdiği **ham** kayıt (VIVO-22 öncesi/sonrası)
{
  "event": "data.ingest",
  "timestamp": "iso8601",
  "source": "logger|telemetry|bridge|sentry|guard|composer|custom",
  "topic": "string",
  "payload": { "any": "json" },
  "data": {
    "tags": {
      "classification": "PUBLIC|SENSITIVE_LOW|PII_BASIC|PII_STRICT|FINANCIAL|SECRET",
      "subjectId": "string|null",           // kişi/kurum kimliği (pseudonymizable)
      "region": "TR|EU|US|...",
      "ttlOverride": "duration|null"        // ör. "P14D" (yalnız yükseltici olabilir)
    }
  },
  "audit": {"producer":"service-name","eventId":"string"}
}

// data.tagging — yukarı akıştan gelen ek etiket
{
  "event": "data.tagging",
  "timestamp": "iso8601",
  "eventId": "string",
  "add": {"classification":"...", "subjectId":"...", "labels":["string"]}
}

// privacy.scan.request — PII saptama taraması
{
  "event": "privacy.scan.request",
  "timestamp": "iso8601",
  "scope": {"since":"iso8601","until":"iso8601","sources":["logger","telemetry"],"topics":["*"]},
  "detectors": ["email","phone","ip","national_id","iban","api_key"]
}

// data.subject.request — ihracat/silme (DSR)
{
  "event": "data.subject.request",
  "timestamp": "iso8601",
  "requestId": "string",
  "type": "export|erasure|access",
  "subjectId": "string",
  "identityProof": {"method":"signed_token|email_match|manual","evidence":"string"},
  "window": {"since":"iso8601|null","until":"iso8601|null"},
  "delivery": {"format":"jsonl|zip","target":"s3://bucket/prefix|file:///..."}
}

Çıktılar (Normalize edilmiş veri, redaksiyon, silme raporları)
// data.normalized — maskeleme/pseudonymization uygulanmış çıktı (downstream’e)
{
  "event": "data.normalized",
  "timestamp": "iso8601",
  "source": "string",
  "topic": "string",
  "payload": { "sanitized": "json" },
  "data": {
    "tags": {"classification":"string","subjectIdHash":"string|null","labels":["string"]},
    "retention": {"expiresAt":"iso8601","policyVersion":"number"}
  },
  "audit": {"fromEventId":"string","maskActions":["drop:token","mask:email","hash:id"]}
}

// privacy.scan.result — PII bulguları
{
  "event": "privacy.scan.result",
  "timestamp": "iso8601",
  "scope": {"since":"iso8601","until":"iso8601"},
  "summary": {"recordsScanned":"number","findings":"number"},
  "byType": [{"type":"email","count":"number"},{"type":"api_key","count":"number"}],
  "recommendations": ["rotate_keys","tighten_masks"]
}

// retention.sweep.report — periyodik silme/redaksiyon raporu
{
  "event": "retention.sweep.report",
  "timestamp": "iso8601",
  "policyVersion": "number",
  "deleted": {"records":"number","bytes":"number"},
  "redacted": {"records":"number","bytes":"number"},
  "skipped": {"records":"number","reason":"string"}
}

// data.subject.receipt — DSR onayı
{
  "event": "data.subject.receipt",
  "timestamp": "iso8601",
  "requestId": "string",
  "type": "export|erasure|access",
  "status": "accepted|rejected|completed|failed",
  "link": "string|null",           // export paketi yolu
  "hash": "string|null",
  "reason": "string|null"
}

// privacy.alert & metrics
{
  "event": "privacy.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"eventId":"string|null","reasonCodes":["string"]}
}
{
  "event": "privacy.metrics",
  "timestamp": "iso8601",
  "throughput": "number",
  "piiDetectedRate": "number",
  "drops": "number",
  "redactions": "number",
  "exports": "number",
  "erasures": "number",
  "errors": "number"
}

TypeScript Arayüzleri (ürettir)

Inputs: PrivacyPolicyUpdate, DataIngest, DataTagging, PrivacyScanRequest, DataSubjectRequest.

Outputs: DataNormalized, PrivacyScanResult, RetentionSweepReport, DataSubjectReceipt, PrivacyAlert, PrivacyMetrics.

Helpers:
Classifier (rules + default), Masker (mask/drop/hash/truncate), Hasher (salted HMAC-SHA256; key alias),
RetentionIndex (expiresAt hesap), Vault (encrypt/decrypt; key rotation),
Scanner (regex/dictionary for email/phone/ip/national_id/iban/api_key),
ExportBuilder (stream→JSONL/ZIP), Eraser (tombstone + secure delete),
Lineage (eventId→origin), DSRValidator (identity proof).

Zod ile tüm giriş/çıkışta runtime validasyon; sayılar finite(); tarih ISO.

Event Bus Konuları

In: privacy.policy.update, data.ingest, data.tagging, privacy.scan.request, data.subject.request

Out: data.normalized, privacy.scan.result, retention.sweep.report, data.subject.receipt, privacy.alert, privacy.metrics

Konfig & Varsayılanlar
{
  // Süreler (ISO-8601)
  defaultRetention: "P180D",
  sweep: { intervalMin: 30, batchRecords: 5000 },
  export: { tmpDir: "data/exports", maxRecords: 5_000_000, partSizeMB: 64, zip: true },
  hash: { algo: "HMAC-SHA256", saltAlias: "kms:vivo35-rotating", subjectIdPepperEnv: "SUBJECT_PEPPER" },
  scan: { maxRatePerSec: 2000, detectors: ["email","phone","ip","national_id","iban","api_key"] },
  masking: { email: "a***@***.tld", phone: "***-****", ipTruncate: "/24" },
  security: { encryptAtRest: true, keyAlias: "kms:vivo35-rotating", allowDecryptionInExport: false },
  audit: { keepExportsD: 30, keepReceiptsD: 365 },
  tz: "Europe/Istanbul"
}

Durum Yönetimi

PrivacyState (in-memory + periyodik persist data/privacy.state.json):

policyVersion, retentionMap, maskingRules, keyMeta{alias,rotatedAt},

lineageIndex (eventId→storageRef), retentionIndex (expiresAt→refs),

subjectMap (subjectIdHash→refs count), pendingDSR (requestId→status),

stats (throughput, drops, redactions, exports, erasures, errors).

Idempotency: aynı eventId ikinci kez gelirse yut (hash/eTag); aynı requestId tekrar çalıştırılmaz.

Algoritma (Karar Akışı)

Politika Yükle

privacy.policy.update → doğrula, version++, mask/retention/encryption/redaction tablolarını güncelle.

Key rotasyon tarihi geldiyse Vault.rotate(); eski anahtarlarla şifrelenmiş kayıtlara read-compatible.

Ingest → Normalize

data.ingest geldiğinde:

Sınıflandırma = data.tags.classification || defaults.classification.

Masker uygula: drop/mask/hash/truncate.

subjectIdHash = HMAC(subjectId + pepper); plaintext subjectId tutma.

payloadu (gerekirse) encrypt-at-rest; storageRef üret.

expiresAt = now + retention[classification] (ttlOverride sadece kısaltabilir).

data.normalized yayınla (downstream tüketir).

RetentionIndex ve Lineage güncelle.

Ek Etiketleme

data.tagging için eventId bulunur → etiket/subjectIdHash güncellenir; gerekiyorsa retention daraltılır.

Periyodik Süpürme (Sweep)

Her sweep.intervalMin:

expiresAt ≤ now kayıtlarını secure delete (Eraser):

encrypt-at-rest ise anahtarı döndürme + tombstone (geri dönüşü olmayan).

Telemetry’ye retention.sweep.report.

Redaction-on-retain: SECRET alanlar derhal drop; PII_STRICT içeriği erken mask.

Tarama (Scan)

privacy.scan.request → Scanner ile seçili kapsamda PII/SECRET tespit; privacy.scan.result yayınla.

api_key tespiti → privacy.alert(error,"secret_leak") + key rotate öner.

DSR (Export/Erasure/Access)

DSRValidator ile identityProof doğrula (token/ eşleşen email/manuel).

Export: subjectIdHash eşleşen kayıtları maskeli biçimde topla → export package yaz → data.subject.receipt(status="completed", link, hash).

Erasure: aynı kapsamda kayıtları tombstone + secure delete → receipt(completed).

Access: export ile aynı; ancak salt/anahtar açılmadan maskeli döner (de-identify).

Redaksiyon Kuralları (Anında)

telemetry/alerts kanallarına giden olaylar için redaction.* kuralları uygulanır (örn. email→hash).

VIVO-32’ye aktarılan seriler kimliksiz kalır.

Hata & Telemetri

Şema/NaN/uygunsuz değer → olay drop + privacy.alert(warn,"invalid_payload").

10 sn’de bir privacy.metrics.

Gerçek Dünya Kuralları (Uyum)

Minimize et, gerekliyse tut: Sadece gerekli alanları tut; SECRET asla persist etme.

TTL kısaltılabilir, uzatılamaz (policy dışına taşma yok).

Export’ta varsayılan maskeli/pseudonymized çıktı; tam açılım sadece hukuki zorunlulukta ve onaylı anahtar ile (config allowDecryptionInExport=false).

SubjectId hiçbir zaman düz metin olarak yazılmaz; sadece hash (HMAC).

Right-to-be-forgotten: silme tamamlandığında tüm indeksler temizlenir; downstream yeniden üretilemez.

Kodlama Yönlendirmesi

Dosya Yapısı

src/vivo/dataRetentionAndPrivacyManager.ts

src/vivo/state/privacyStore.ts (policy+index+dsr+stats persist)

src/vivo/lib/mask.ts, src/vivo/lib/hash.ts, src/vivo/lib/vault.ts, src/vivo/lib/scan.ts, src/vivo/lib/export.ts, src/vivo/lib/erase.ts

__tests__/dataRetentionAndPrivacyManager.test.ts

Mimari

Çekirdek: ingest(event, state, cfg) → emissions[], sweep(now), handleDSR(req).

IO adaptörü: storage (append-only + tombstone), kms/vault arayüzü, event bus pub/sub.

Validasyon

Zod; classification enum, duration ISO-8601, subjectId boşsa hash alanı null.

Performans

p99 ingest < 5ms, sweep batch I/O ardışık, export streaming (back-pressure).

Güvenlik

KMS hata/bağlantı sorununda fail-secure: ingest drop + alert(error) (PII’yi şifresiz yazma!).

Test İskeleti (Jest)

ingest(PERSONAL) → mask/hash uygulanır, expiresAt doğru

ttlOverride uzatma denemesi → reddedilir

SECRET alan içeren kayıt → drop + privacy.alert(error)

scan(api_key) → findings > 0, rotate önerisi

sweep → vadesi dolan kayıtlar silinir, report sayıları tutar

DSR export (subjectId) → paket üretilir, link/hash yayınlanır

DSR erasure → tüm referanslar tombstone edilir

redaction.telemetry → email/phone hashlenir

idempotent eventId → ikinci ingest yok

Örnek Senaryo (Özet)

Girdiler

privacy.policy.update(version=7) → PII_STRICT: P30D, SECRET: P0D, redaction.telemetry {email,ip}=hash.

data.ingest (source=bridge, topic=incident.open): payload’da email ve telegramUserId var; classification PII_BASIC, subjectId="user:1234".

privacy.scan.request(since=−24h) (detectors: api_key,email).

data.subject.request(type="export", subjectId="user:1234").

Beklenen Çıktılar

{
  "event":"data.normalized",
  "data":{"tags":{"classification":"PII_BASIC","subjectIdHash":"HMAC(...)"}, "retention":{"expiresAt":"...+P90D","policyVersion":7}},
  "audit":{"maskActions":["mask:email","hash:subjectId"]}
}

{"event":"privacy.scan.result","summary":{"recordsScanned":12045,"findings":3},"byType":[{"type":"email","count":3}],"recommendations":["tighten_masks"]}

{"event":"data.subject.receipt","requestId":"DSR-88","type":"export","status":"completed","link":"file:///data/exports/DSR-88.zip","hash":"sha256:..."}


30 gün sonra retention.sweep.report silinen PII_STRICT kayıtlarını raporlar.

Entegrasyon Notları

VIVO-22 Logger: data.normalized’ı esas alarak kalıcı depoya yazar; ham data.ingest’i tutmaz.

VIVO-32 Telemetry: redaction.telemetry kurallarını uygular; kişi alanlarını kimliksiz raporlar.

VIVO-33 Bridge: bildirim gövdeleri redaction.alerts ile maskeleme yapar.

PolicyCoordinator (VIVO-29): gizlilik politikası değişimlerini privacy.policy.update olarak yayınlayabilir.
_________________________________________________________________________________________________________________
VIVO — Yeni Modüller (Ek Blok)

Aşağıdaki 8 modül, mevcut mimariye ek olacak şekilde numaralandırılmıştır.
Dosya adları src/vivo/*.ts; testler __tests__/*.test.ts.

VIVO-36 · planSafetyNet.ts — Gelişmiş Prompt v3
Amaç

Operatör onayı + bracket kurulumundan ilk 60–180 saniye içinde negatif mark-out ve/veya aşırı slip görülürse trim/cancel/tighten aksiyonlarıyla erken kaybı sınırlamak.

Girdiler (In)

order.bracket.ready: { correlationId, symbol, side, qty, slOrderId, tpOrderIds[], variant }

trade.markout.tick: { correlationId, dtSecFromEntry, markOutBps, slipBps, mid, spreadBps }

order.update, supervisor.state, policy.snapshot (eşikler), latency_slip.guard.directive

Çıktılar (Out)

plan.safety.action: { correlationId, action: "none|trim|cancel_all|tighten_sl", params:{trimPct?|newSL?|note}, reasonCodes[], audit{} }

plan.safety.metrics: { windowSec, worstMarkOutBps, maxSlipBps, actions{...} }

Konfig
{
  windowSec: { min: 60, max: 180 },
  thresholds: { markOutWarnBps: -6, markOutCutBps: -12, slipCutBps: 15 },
  trim: { pct: 0.33, minQty: 0.001 },
  tightenSL: { addTightenBps: 6, maxTimes: 2 },
  cooldownMin: 5,
  idempotencyTtlSec: 300,
  tz: "Europe/Istanbul"
}

Algoritma

order.bracket.ready → watch window başlat; idempotency anahtarı = correlationId.

Pencere içinde en kötü markOutBps ve slipBps’i izleyin.

Kurallar:

markOut ≤ markOutCutBps → cancel_all (reduce-only).

markOut ≤ markOutWarnBps → trim(pct); bir kez.

slipBps ≥ slipCutBps → tighten_sl(+addTightenBps); maxTimese kadar.

guard.directive in ["halt_entry","streams_panic"] → aksiyonları ertele, sadece tighten_sl izinli.

Tüm aksiyonlar idempotent (aynı bağlam→tek yayın). Pencere bitince metrics yayınla.

TypeScript Arayüzleri

BracketReady, MarkoutTick, PlanSafetyAction, PlanSafetyMetrics.

Event Bus

In: order.bracket.ready, trade.markout.tick, order.update, latency_slip.guard.directive, policy.snapshot

Out: plan.safety.action, plan.safety.metrics

Kodlama Yönlendirmesi

Çekirdek FSM: advance(state, event, cfg) → emissions[].
SL/TP değişimiyle çakışmaları supervisor.state ile çöz; reduce-only emir üretimini Composer/Executor yapar.

Test İskeleti

markOut -13bps@90s → cancel_all

markOut -8bps@45s → trim once

slip 17bps → tighten_sl, maxTimes sınırı

guard=halt_entry → sadece tighten

Entegrasyon

VIVO-21 (Supervisor) & VIVO-19 (Composer) ile aksiyon paylaşımı; VIVO-26 slip guard eşikleriyle tutarlılık.
_________________________________________________________________________________________________________________
VIVO-37 · scenarioPlaybookBinder.ts — Gelişmiş Prompt v3
Amaç

Rejim/news/liquidity etiketlerini uygun plan şablonlarına bağlayıp VIVO-19’a varyant + exec style önerisi üretmek.

Girdiler

gb.regime.snapshot: { symbol, timeframe, tags:["highVol","range","trend","newsWindow","thinLiq"] }

qa.tags: { tags:["open-bar","highVol","gap-open", ...] }

playbook.catalog: { id, variant, exec: "market|limit|twap|iceberg", params{}, guards{} }

Çıktılar

composition.playbook.choice: { symbol, timeframe, playbookId, variant, exec, params, constraints, reasonCodes[] }

Konfig
{
  matrix: {
    "newsWindow": { variant:"conservative", exec:"twap", constraints:{postOnly:true} },
    "highVol":    { variant:"conservative", exec:"limit", params:{offsetBps:5} },
    "thinLiq":    { exec:"iceberg", params:{displayPct:0.2} },
    "trend":      { variant:"base" },
    "range":      { variant:"conservative" }
  },
  fallback: { variant:"base", exec:"limit" },
  tz: "Europe/Istanbul"
}

Algoritma

Rejim/QA tag’lerini öncelik sırasına göre eşle.

Uyuşan playbook yoksa fallback.

Policy/Guard kısıtlarıyla son öneriyi clamp et (ör. aggressive kapalıysa düşür).

Arayüzler & Bus

In: gb.regime.snapshot, qa.tags, playbook.catalog, policy.snapshot, guard.directive

Out: composition.playbook.choice

Testler

newsWindow+highVol → twap+conservative

aggressive kapalı → conservative’a düşür
_________________________________________________________________________________________________________________
VIVO-38 · operatorConsistencyScore.ts — Gelişmiş Prompt v3
Amaç

Operatör seçimlerinin tutarlılık & sonuç skorunu hesaplayıp öneri sıralaması ve soru derinliği için sinyal üretmek.

Girdiler

operator.choice.log: { when, symbol, decision, overrides[], context{} }

vivo.feedback.raw, trade.summary.closed

Çıktılar

operator.consistency.score: { score0to1, horizonDays, strengthTags[], explanations[] }

Konfig
{
  horizonDays: 30,
  weights: { hit:0.4, expectancy:0.3, discipline:0.2, latency:0.1 },
  decayHalfLifeDays: 7,
  thresholds: { low:0.4, high:0.7 }
}

Algoritma

30 günlük pencere; EWMA ile hit/expectancy/discipline(latency & rule-break).

Skoru 0..1 normalize; low/high eşiklerine göre tag’ler.

low ise operatorDialog için ek soru bayrağı.

Bus

In: operator.choice.log, vivo.feedback.raw, trade.summary.closed

Out: operator.consistency.score

Testler

disiplin bozuldukça skor↓

son 7 günde iyileşme → skor↑ (decay etkisi)
_________________________________________________________________________________________________________________
VIVO-39 · cashRunwayAdvisor.ts — Gelişmiş Prompt v3
Amaç

Spot/nakit akışını haftalık/aylık planla; %30 spot payı hedefi, çekme/yatırma/transfer tavsiyeleri üret.

Girdiler

account.cashflow: { inflowUSD, outflowUSD, recurring[], holdings{spotUSD, futuresUSD} }

portfolio.exposure: { totalRiskPct, leverage, ddFromPeak }

daily.kpis: { pf, winRate, avgR }, policy.snapshot

Çıktılar

cash.runway.plan: { horizonDays, minUSD, actions:[{type:"topup|withdraw|rebalance", amountUSD, when}] , notes[] }

Konfig
{
  targetSpotPct: 0.30,
  minRunwayDays: 30,
  ddGuardPct: 15,
  pfFloor: 1.25,
  bufferUSD: 500,
  tz: "Europe/Istanbul"
}

Algoritma

Runway = (spotUSD + netInflowNext30d) / avgDailyOutflow.

< minRunwayDays → topup öner; ddFromPeak > ddGuard → risk azalt.

Spot payı %30’dan sapmışsa rebalance planı üret.

Bus

In: account.cashflow, portfolio.exposure, daily.kpis, policy.snapshot

Out: cash.runway.plan

Testler

runway 18g → topup + rebalance

PF<1.25 → daha muhafazakâr öneriler
_________________________________________________________________________________________________________________
VIVO-40 · dominanceShiftWatcher.ts — Gelişmiş Prompt v3
Amaç

BTC/ETH dominans kaymalarını ve beta rejimini izleyip varyant/simge ağırlık önerisi çıkarmak.

Girdiler

market.dominance: { btcD, ethD, zScores{btcD,ethD} }

portfolio.correlation: { topPairs[], betaByCluster{} }

universe.snapshot

Çıktılar

dominance.shift.signal: { regime:"btc-led|alt-led|neutral", suggest:{ variant?, reduceCluster?:{Layer1:number} }, reasonCodes[] }

Konfig
{
  zThr: { shift: 1.2, strong: 2.0 },
  hysteresis: 0.3,
  maxReducePerStep: 0.2
}

Algoritma

z(btcD)-z(ethD) farkı → rejim.

≥ strong → aggressive kapat, conservative öner; Layer1 riskini maxReducePerStep kadar azalt.

Histerezis ile flip-flop engelle.

Bus

In: market.dominance, portfolio.correlation, universe.snapshot

Out: dominance.shift.signal

Testler

fark 2.1 → alt-led; reduce Layer1 20%

geri dönüşte histerezis çalışır
_________________________________________________________________________________________________________________
VIVO-41 · strategyStabilityScore.ts — Gelişmiş Prompt v3
Amaç

Stratejiler için istikrar skoru; Bandit/Composer için düşük istikrarı işaretle.

Girdiler

Son N örnekten vivo.feedback.raw, trade.summary.closed

Çıktılar

strategy.stability.scores: [ { arm, score0to1, samples, flags:["volatile|stable"], notes[] } ]

Konfig
{
  windowTrades: 50,
  weights: { stdR:0.4, winVar:0.3, slipVar:0.2, durationVar:0.1 },
  thresholds: { volatile: 0.35, stable: 0.7 }
}

Algoritma

Normalize varyans ölçüleri → 0..1 ters skor; eşiklere göre flag.

Bus

In: vivo.feedback.raw, trade.summary.closed

Out: strategy.stability.scores

Testler

yüksek stdR → skor düşük, volatile

örnek sayısı < window → samples uyarısı
_________________________________________________________________________________________________________________
VIVO-42 · biasWeightedSignalTuner.ts — Gelişmiş Prompt v3
Amaç

LIVIA/öznel bias ağırlıklarına ve QA tag’lerine göre sinyal varyantını otomatik ayarlamak.

Girdiler

livia.bias.weights: { overconfidence:0..1, lossAversion:0..1, riskSeeking:0..1 }

qa.tags, operator.consistency.score, policy.snapshot

Çıktılar

signal.variant.tuned: { base:"base|aggressive|conservative", adjusted:"...", reasonCodes[] }

Konfig
{
  rules: {
    overconfidence_gt_0_6: { to:"conservative" },
    lossAversion_gt_0_7: { to:"base", clampTP:true },
    guardHighVol: { to:"conservative" }
  }
}

Algoritma

Kural tabanlı dönüşüm + policy clamp; aggressive yasaksa otomatik düşür.

Bus

In: livia.bias.weights, qa.tags, operator.consistency.score, policy.snapshot

Out: signal.variant.tuned

Testler

overconfidence 0.8 → conservative

policy aggressive=false → conservative zorunlu
_________________________________________________________________________________________________________________
VIVO-43 · riskToleranceVariantSelector.ts — Gelişmiş Prompt v3
Amaç

Kullanıcı/hesap geçmişine göre otomatik variant öner (base/aggressive/conservative).

Girdiler

Son 15 işlem istatistikleri: { avgDrawdownR, maxDD_R, avgHoldMin, abortRate, hitRate, expectancyR }

policy.snapshot, operator.consistency.score

Çıktılar

variant.suggestion: { suggested:"conservative|base|aggressive", confidence0to1, reasons[] }

Konfig
{
  rules: {
    highDD: { maxDD_R_gt: 3.0, to:"conservative" },
    strongEdge: { hit_gt:0.56, expR_gt:0.2, to:"aggressive" },
    slowStyle: { avgHold_gt_min:120, to:"base" }
  },
  hysteresis: { promoteAfterTrades: 10, demoteAfterTrades: 5 }
}

Algoritma

Kural eşleşmeleri → puanlama; histerezis ile yükseltme/düşürme koşulları.

Bus

In: performance.window15, policy.snapshot, operator.consistency.score

Out: variant.suggestion

Testler

maxDD_R 3.4 → conservative

hit 0.58 & expR 0.25 → aggressive

histerezis: 1–2 iyi işlemde hemen yükseltme yok

Genel Ek Notlar (bu blok için)

Dosya yapısı: her modül için state/*.ts (store), lib/*.ts (helpers) ve Jest testleri.

Audit & Telemetri: her aksiyonda audit alanı ve *.metrics olayı; p99 hedef < 5 ms.

Çakışma çözümü: Guard/Policy > Supervisor > SafetyNet sırası; idempotency hash ile çift yayın engeli.

Zamanlama: tüm sayaç/sweep resetleri Europe/Istanbul gün sonuna göre.
_________________________________________________________________________________________________________________