âœ… [1] VIVO Nihai ModÃ¼l Listesi (Tam Liste + GruplandÄ±rma)

Toplam 30 modÃ¼l, 6 iÅŸlevsel grup.

ğŸ§­ A. Piyasa DuruÅŸu & Plan Ãœretimi
ModÃ¼l	AÃ§Ä±klama
marketPostureAdvisor.js (VIVO-01)	Risk-AÃ§Ä±k/NÃ¶tr/Risk-KapalÄ± duruÅŸ + Plan A/B/C Ã¼retir.
signalHub.js (VIVO-00)	GB sinyallerini toplar, +%4 ve whitelist kapÄ±larÄ±nÄ± uygular, skorlar.
planVariantGenerator.js	AynÄ± fikri 2â€“3 yÃ¼rÃ¼tme varyantÄ±na (agresif/temkinli) Ã§evirir.
planFeasibilityChecker.js	Tick/lot/notional/limit ve allowedNotionalâ€™a gÃ¶re uygulanabilirlik.
postureMemory.js	Son 7/30 gÃ¼nde duruÅŸ/sonuÃ§ hafÄ±zasÄ±, aÄŸÄ±rlÄ±k gÃ¼ncelleme.
ğŸ§® B. Sermaye Tahsisi & PortfÃ¶y PolitikalÄ± YÃ¼rÃ¼tme
ModÃ¼l	AÃ§Ä±klama
strategyAllocator.js (VIVO-02)	PlanÄ± GB-60 tahsis kurallarÄ±yla lot/Ã§ocuk-emre Ã§evirir.
spotCashBalancer.js	Spot %30 hedefini (eÅŸik sonrasÄ±) ve nakit dengesini korur.
exposureGuard.js	GB-69 limit/deny/trim kararlarÄ±na gÃ¶re otomatik kÄ±sÄ±tlama.
pyramidingOrchestrator.js	Trend yakalamada ekleme/Ã§Ä±karma adÄ±mlarÄ±nÄ± sÄ±raya koyar.
hedgeCoordinator.js	BTC/ETH/alt sepet koruma hedgeâ€™lerini planlar.
ğŸ” C. OperatÃ¶r EtkileÅŸimi & Onay AkÄ±ÅŸÄ±
ModÃ¼l	AÃ§Ä±klama
operatorDialog.js (VIVO-03)	Telegram/CLI: Plan A/B/C + evet/hayÄ±r, timeoutâ†’korumacÄ± default.
optionCardBuilder.js	PlanÄ± okunur â€œkartâ€lara Ã§evirir (notional, exec, risk, beklenen R).
explainabilityReporter.js	â€œNeden bu plan?â€ â†’ kÄ±sa gerekÃ§e & metrikler.
guardQuestionEngine.js	Kritik kapÄ±larda (REDUCE_ONLY, +%4, whitelist) evet/hayÄ±r sorularÄ±.
rollbackPromptor.js	â€œYanlÄ±ÅŸ gidiyorâ€ tespitinde geri alma/trim Ã¶nerir.
ğŸ“Š D. CanlÄ±â€”BT UyuÅŸum & A/B Ã–ÄŸrenme
ModÃ¼l	AÃ§Ä±klama
livePaperChooser.js	A/B kol seÃ§imini yapar (mirror vs counterfactual oranÄ±).
upliftEstimator.js	Plan A vs B kÃ¢r/ PF/ slipaj farkÄ± ve gÃ¼ven aralÄ±ÄŸÄ±.
driftGapWatcher.js	Live vs BT farkÄ± â‰¤%20 izle; ihlalde alarm/plan dÃ¼zeltme.
paramFeedbackWriter.js	WF (GB-72) paramlarÄ±na kÃ¼Ã§Ã¼k dÃ¼zeltmeleri geri yazar.
executionStyleSwitcher.js	IOC/TWAP/iceberg/post-only tercihlerini CFX sonuÃ§larÄ±na gÃ¶re dÃ¶ndÃ¼rÃ¼r.
ğŸ›¡ï¸ E. Risk & Sentinellerle Uyum
ModÃ¼l	AÃ§Ä±klama
sentinelCompliance.js	GB-61/70 durumlarÄ±na gÃ¶re SLOWDOWN/ HALT/ CB uygulama.
drawdownStepDown.js	GÃ¼n-iÃ§i/haftalÄ±k DDâ€™ye gÃ¶re tahsisi kademeli dÃ¼ÅŸÃ¼r.
newsWindowTightener.js	GB-34 haber pencerelerinde otomatik sÄ±kÄ±laÅŸtÄ±rma.
liquidityAwareSizer.js	THICK/THIN likiditeye gÃ¶re boyut/offset/iceberg ayarÄ±.
capitalObjectiveRouter.js	Hedef: +%4/ PF>1.25/ MaxDDâ‰¤%15 optimizasyonunda Ã¶ncelik.
ğŸ§° F. Telemetri, Log & Test KÃ¶prÃ¼leri
ModÃ¼l	AÃ§Ä±klama
actionEmitter.js	SeÃ§ilen planÄ± GB-66/67â€™ye â€œops.actionsâ€ olarak yollar.
auditTrailWriter.js	Neden-sonuÃ§ zinciri; idempotent journal.
vivoMetricsReporter.js	Plan baÅŸÄ±na PF, hit, avgR, slipaj, mark-out; 7/30g Ã¶zet.
testHarnessAdapter.js	Entegre fuzz (GB-74) ve health (GB-75) testlerini tetikler.
configSanityChecker.js	Whitelist/+%4/spot %30 eÅŸiklerinin yÃ¼kleme testleri.
ğŸ”„ [2] ModÃ¼ller ArasÄ± Veri AlÄ±ÅŸveriÅŸi HaritasÄ± (VIVO)
â‡† Grafik Beyni (GB)

AlÄ±r: Sinyal skorlarÄ± (signalHub), WF paramlarÄ± (GB-72), yÃ¼rÃ¼tme planÄ± ÅŸablonlarÄ± (GB-66/67), RiskNet/Health (GB-70/75).

GÃ¶nderir: SeÃ§ilen planÄ±n ops.actions Ã§Ä±ktÄ±sÄ±, A/B sonuÃ§larÄ±na dayalÄ± param geri besleme (paramFeedbackWriter).

â‡† OtobilinÃ§

AlÄ±r: adaptiveBiasShield uyarÄ±larÄ± (riskli davranÄ±ÅŸ halinde sinyal baskÄ±sÄ±).

GÃ¶nderir: OperatÃ¶r onayÄ± sÄ±rasÄ±nda â€œkorumacÄ± defaultâ€ gerekÃ§eleri ve uygulanan sÄ±nÄ±rlamalar.

â‡† LIVIA

AlÄ±r: Seri kayÄ±p/ psikolojik risk durumunda â€œreduce-only/denyâ€ sinyalleri.

GÃ¶nderir: PortfÃ¶y konum deÄŸiÅŸiklikleri ve hedge koordinatlarÄ±.

â‡† Denetim AsistanÄ±

GÃ¶nderir: PostÃ¼r kararlarÄ±, reddedilen planlar, soru-cevap gÃ¼nlÃ¼ÄŸÃ¼, A/B uplift Ã¶zetleri.

ğŸ§¼ [3] Elenen VIVO ModÃ¼lleri ve GerekÃ§eler
âŒ ModÃ¼l	Neden Elendi?	AsÄ±l Sistemi
rawSignalGenerator.js	Sinyal Ã¼retimi GBâ€™nin gÃ¶revi.	Grafik Beyni
pnlAttributionCore.js	TCA/PnL ayrÄ±ÅŸtÄ±rma GB-36â€™da.	Grafik Beyni
deepRiskEngine.js	VaR/limit yÃ¶netimi GB-69/70â€™te.	GB RiskNet
behaviorOverrideKernel.js	Psikolojik baskÄ±lama OtobilinÃ§â€™te.	OtobilinÃ§
venueSwitcher.js	Ã‡oklu borsa meta-router ileride GB-76.	Grafik Beyni (opsiyonel)
ğŸ§© [4] Yeni VIVO ModÃ¼l Ã–nerileri (boÅŸluk kapatma)

planSafetyNet.js â€“ Onaydan sonra 60â€“180 sn iÃ§inde â€œmark-out < âˆ’X bpâ€ ise otomatik trim/iptal.

scenarioPlaybookBinder.js â€“ Senaryo (rejim/news/liquidity) â†” plan ÅŸablonlarÄ± eÅŸleÅŸtirme matrisi.

operatorConsistencyScore.js â€“ OperatÃ¶r seÃ§imlerinin tutarlÄ±lÄ±k ve performans skoru; Ã¶neri aÄŸÄ±rlÄ±klarÄ±nÄ± etkiler.

cashRunwayAdvisor.js â€“ Spot/nakit akÄ±ÅŸ planÄ± (haftalÄ±k/aylÄ±k), Ã§ekme-yatÄ±rma Ã¶nerileri.

dominanceShiftWatcher.js â€“ BTC.D/ETH rel. gÃ¼Ã§ kaymasÄ± olduÄŸunda Plan Bâ€™ye otomatik geÃ§iÅŸ Ã¶nerisi.

ğŸ§± VIVO â€“ Temel Kodlama Promptu (BirleÅŸik V2+V3 StandardÄ±)

AmaÃ§: VIVO, sinyalâ†’planâ†’tahsisâ†’onayâ†’eylem zincirinin â€œinsan-seÃ§imiyle uyumluâ€ orkestra katmanÄ±dÄ±r. +%4 hedef, whitelist, spot %30 politikalarÄ±na her zaman uyar; GB risk/sentinel kapÄ±larÄ±na Ã¶ncelik verir.

GerÃ§ek DÃ¼nya KurallarÄ±:

KapanmamÄ±ÅŸ bar yok; modeled vs realized maliyetler dahil.

Binance filtreleri (tick/lot/notional/position/trailing/OCO), rate-limit/backoff.

RiskNet: AMBERâ†’SLOWDOWN, REDâ†’HALT/ CB + reduce-only.

Live-BT gap â‰¤ %20; A/B uplift Ã¶lÃ§Ã¼mÃ¼.

ArayÃ¼zler (TS) â€“ Ã¶rnek:

export interface VIVOPlan {
  id: "A"|"B"|"C"; title: string;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  trend?: { atrK:number; pyramid?:{maxAdds:number; addEveryPct:number; sizePct:number} };
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
}
export interface VIVOAsk { q: string; choices: string[]; default: string; timeoutSec: number; }
export interface VIVOOutput { posture:"RISK_ON"|"NEUTRAL"|"RISK_OFF"; plans: VIVOPlan[]; ask: VIVOAsk[]; }


Event Bus (pub-sub):

Publish: vivo.posture (VIVOOutput), ops.actions (seÃ§ilen plan), audit.log.

Subscribe: gb.signal, gb.health, gb.tca, ops.actions (geri bildirim), OtobilinÃ§/LIVIA uyarÄ±larÄ±.

Validasyon & Tip:

GiriÅŸte whitelist ve minTargetPct=4 zorunlu; exchangeInfo ile quantize.

Runtime guard (zod/ajv veya hafif guard) + TS tip gÃ¼venliÄŸi.

Hata & Logging:

{ code,message,details,retriable } formunda; merkezi logger + audit.log.

Idempotent aksiyonlar; aynÄ± corrId tekrarÄ± yutulur.

Test PlanÄ±:

Birim: plan Ã¼retimi, politika kapÄ±larÄ±, sentinel etkisi, invalid sembol/ notional.

Entegrasyon: Plan A/B/C â†’ strategyAllocator â†’ actionEmitter zinciri; live-BT gap alarmÄ±; OtobilinÃ§ baskÄ± senaryosu.
_________________________________________________________________________________________________________________
VIVO-01 Â· marketPostureAdvisor.ts

AmaÃ§ (tek cÃ¼mle):
Grafik Beyni + RiskNet + politika kapÄ±larÄ±nÄ± (whitelist, +%4 hedef, spot %30) birleÅŸtirip gÃ¼nÃ¼n duruÅŸunu (Risk-AÃ§Ä±k/NÃ¶tr/Risk-KapalÄ±) ve Plan A/B/C Ã¶nerilerini Ã¼retir; operatÃ¶re onay sorularÄ± hazÄ±rlar.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; expectedMove/ATR kapanmÄ±ÅŸ barlarla.

Slipaj/komisyon/funding etkileri (GB-22/36) plan notlarÄ±nda dikkate alÄ±nÄ±r.

Binance kÄ±sÄ±tlarÄ± (tick/lot/notional/position) VIVO-02â€™de uygulanÄ±r; VIVO-01 yalnÄ±z uygulanabilirlik bayraÄŸÄ± ekler.

Risk sentinel (GB-61/70): AMBERâ†’SLOWDOWN (temkinli varyant), RED/CBâ†’Risk-KapalÄ± (reduce-only Ã¶nerileri).

Politika: +%4 min hedef, whitelist 20 coin, spot %30 (equity eÅŸiÄŸi sonrasÄ±).

ArayÃ¼zler (TypeScript/JSDoc)
// vivo/types.ts
export type ISODate = string;
export type Level = "GREEN"|"AMBER"|"RED";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface Policy {
  minTargetPct: number;           // >= 4
  whitelist: string[];            // 20-coin
  spot: { targetPct: number; equityThresholdUsd: number };
}

export interface RiskNetState {
  level: Level;                   // GB-70
  sentinel: "NORMAL"|"WATCH"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER"; // GB-61/75
}

export interface WFParams {
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  trend?: { atrK:number; pyramid?:{ maxAdds:number; addEveryPct:number; sizePct:number } };
}

export interface LedgerSnap {
  equityUsd: number; spotPct: number; ddPct: number;
}

export interface Dominance {
  btcD:number;            // proxy
  ethRel:number;          // ETH vs BTC gÃ¼Ã§
  altRet:number;          // alt sepet 1d getiri
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;    // TRIM/ALLOW iÃ§in
}
export type ExposureMap = Record<string, ExposureGate>;

export interface AnalyticsRow {
  expectedMovePct:number; // kapanmÄ±ÅŸ bar
  R_multiple:number;      // â‰¥1.2 tercih
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

// ---- VIVO-01 Ã§Ä±ktÄ±larÄ± ----
export interface VIVOPlan {
  id:"A"|"B"|"C"; title:string;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: WFParams["exec"];
  trend?: WFParams["trend"];
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
  applicability?: {                              // VIVO-02 iÃ§in erken iÅŸaretler
    whitelistOk:boolean; minTargetOk:boolean; exposureOk:boolean;
  }
}
export interface VIVOAsk { q:string; choices:string[]; default:string; timeoutSec:number; }
export interface VIVOOutput {
  asOf:ISODate; posture:Posture; plans:VIVOPlan[]; ask:VIVOAsk[]; audit:string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

export interface VIVO01Input {
  risk: RiskNetState;
  wf: WFParams;
  ledger: LedgerSnap;
  dominance: Dominance;
  policy: Policy;
  exposure: ExposureMap;
  analytics: AnalyticsMap;         // yalnÄ±z whitelist iÃ§inden kullanÄ±lacak
}

Event Bus (publish/subscribe)

Subscribe: vivo.posture:input (VIVO-01â€™e girdi enveloper), gb.signal (opsiyonel direkt skor beslemesi).

Publish: vivo.posture (VIVOOutput), audit.log (karar izleri).

Validasyon & Tip Kontrolleri

GiriÅŸte: policy.minTargetPct â‰¥ 4, policy.whitelist dolu, ledger.equityUsd > 0.

Semboller whitelist dÄ±ÅŸÄ±ndaysa atlanÄ±r.

analytics[symbol].expectedMovePct â‰¥ policy.minTargetPct ve R_multiple â‰¥ 1.2 deÄŸilse plana dahil edilmez.

Risk sentinel RED/CB â‡’ sadece Plan C (Nakit+Spot/Reduce-only) Ã¼retilir.

Hata YÃ¶netimi & Logging

Standart hata: { code, message, details, retriable }

audit.logâ€™a: posture kararÄ±, filtrelenen semboller, neden listeleri (whitelist dÄ±ÅŸÄ±, +%4 altÄ±, R<1.2, exposure=DENY/REDUCE_ONLY, risk=RED).

Kod Ä°skeleti (TypeScript/Node.js)
// vivo/marketPostureAdvisor.ts
import { EventEmitter } from "events";
import type {
  VIVO01Input, VIVOOutput, VIVOPlan, VIVOAsk, Posture, Level, StdError
} from "./types";
import { bus } from "../core/bus";     // ee sarmalayÄ±cÄ± (Ã¶nceden tanÄ±mlÄ±)
import { logger } from "../core/logger";

export class MarketPostureAdvisor extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-01";

  constructor() { super(); }

  run(x: VIVO01Input): VIVOOutput | { error: StdError } {
    try {
      const valErr = this.validate(x);
      if (valErr) return this.err("VALIDATION_ERROR", valErr);

      const posture = this.decidePosture(x.risk);
      const plans = this.buildPlans(x, posture);
      const ask = this.buildQuestions(x, posture, plans);
      const out: VIVOOutput = {
        asOf: new Date().toISOString(),
        posture, plans, ask,
        audit: this.auditLines(x, posture, plans)
      };
      bus.emit<VIVOOutput>("vivo.posture", out);
      return out;
    } catch (e:any) {
      return this.err("VIVO01_FAILED", e?.message || "unknown", { stack: e?.stack });
    }
  }

  private validate(x: VIVO01Input): string | null {
    if (!x || !x.policy) return "policy missing";
    if ((x.policy.minTargetPct ?? 0) < 4) return "minTargetPct must be â‰¥ 4";
    if (!Array.isArray(x.policy.whitelist) || x.policy.whitelist.length === 0) return "whitelist empty";
    if (!x.ledger || !Number.isFinite(x.ledger.equityUsd) || x.ledger.equityUsd <= 0) return "equity invalid";
    return null;
  }

  private decidePosture(r: VIVO01Input["risk"]): Posture {
    if (r.sentinel !== "NORMAL" || r.level === "RED") return "RISK_OFF";
    if (r.level === "AMBER") return "NEUTRAL";
    return "RISK_ON";
  }

  private buildPlans(x: VIVO01Input, posture: Posture): VIVOPlan[] {
    const plans: VIVOPlan[] = [];
    // C) Nakit + Spot (her durumda Ã¶neri olarak bulunsun)
    plans.push(this.planSpot(x, posture));

    if (posture === "RISK_OFF") return plans; // yalnÄ±z Plan C

    // A) BTC+ETH Trend
    const planA = this.planTrendBluechips(x);
    if (planA) plans.unshift(planA); // Aâ€™yÄ± baÅŸa koy

    // B) Alt Momentum Sepeti
    const planB = this.planAltBasket(x);
    if (planB) plans.splice(1, 0, planB);

    return plans;
  }

  private planTrendBluechips(x: VIVO01Input): VIVOPlan | null {
    const picks = this.pickSymbols(x, ["BTCUSDT","ETHUSDT"]);
    if (picks.length === 0) return null;

    const exec = {
      ...x.wf.exec,
      twapMs: x.risk.level==="AMBER" ? x.wf.exec.twapMs + 200 : x.wf.exec.twapMs
    };
    return {
      id:"A", title:"Trend Yakala: BTC+ETH",
      symbols: picks,
      exec, trend: x.wf.trend ?? { atrK: 2.8, pyramid:{ maxAdds:2, addEveryPct:5, sizePct:0.33 } },
      notes: this.notesFrom(x),
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private planAltBasket(x: VIVO01Input): VIVOPlan | null {
    // whitelistâ€™ten BTC/ETH hariÃ§, uygun skorlu ilk 5â€“6
    const universe = x.policy.whitelist.filter(s => s!=="BTCUSDT" && s!=="ETHUSDT");
    const picks = this.pickSymbols(x, universe, { perSymbolFrac: 0.10, maxCount: 6 });
    if (picks.length === 0) return null;

    const exec = {
      ...x.wf.exec,
      limitOffsetBps: x.wf.exec.limitOffsetBps + 1,
      twapMs: x.wf.exec.twapMs + (x.risk.level==="AMBER" ? 300 : 100),
      iceberg: Math.max(0.10, (x.wf.exec.iceberg ?? 0.12) - 0.02)
    };
    return {
      id:"B", title:"Alt Momentum Sepeti",
      symbols: picks, exec, trend: { atrK: 2.6, pyramid:{ maxAdds:1, addEveryPct:5, sizePct:0.5 } },
      notes: this.notesFrom(x),
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private planSpot(x: VIVO01Input, posture: Posture): VIVOPlan {
    const need = this.spotTopupAmount(x.policy.spot, x.ledger);
    return {
      id:"C", title:"Nakit + Spot Top-Up",
      symbols: [],
      exec: x.wf.exec,
      spotTopup: need>0 ? { targetPct: x.policy.spot.targetPct, amountUsd: Math.round(need) } : null,
      notes: [ posture==="RISK_OFF" ? "Risk-KapalÄ±: yeni giriÅŸ yok, reduce-only" : "NÃ¶tr/Risk-On: sÄ±nÄ±rlÄ± giriÅŸ" ],
      applicability:{ whitelistOk:true, minTargetOk:true, exposureOk:true }
    };
  }

  private pickSymbols(
    x: VIVO01Input,
    pool: string[],
    opt: { perSymbolFrac?:number; maxCount?:number } = {}
  ): Array<Record<string, number>> {
    const frac = opt.perSymbolFrac ?? 0.25;           // equity * 0.25 * 0.2 = ~%5 varsayÄ±lan
    const maxN = opt.maxCount ?? 2;

    const chosen: Array<Record<string, number>> = [];
    for (const s of pool) {
      if (!x.policy.whitelist.includes(s)) continue;
      const an = x.analytics[s]; if (!an) continue;
      if (an.expectedMovePct < x.policy.minTargetPct || (an.R_multiple ?? 0) < 1.2) continue;
      const gate = x.exposure[s]; if (!gate || gate.decision==="DENY" || gate.decision==="REDUCE_ONLY") continue;

      const base = x.ledger.equityUsd * frac * 0.2;    // risk bÃ¼tÃ§esi ~%20 Ã§arpanÄ±
      const notional = gate.decision==="TRIM" ? (gate.allowedNotionalUsd ?? base) : base;
      if (notional <= 0) continue;

      chosen.push({ [s]: Math.round(notional) });
      if (chosen.length >= maxN) break;
    }
    return chosen;
  }

  private spotTopupAmount(spotPol: VIVO01Input["policy"]["spot"], led: VIVO01Input["ledger"]){
    if (led.equityUsd < spotPol.equityThresholdUsd){
      const target = Math.min(0.15, spotPol.targetPct * (led.equityUsd / spotPol.equityThresholdUsd));
      return Math.max(0, (target - (led.spotPct||0))) * led.equityUsd;
    }
    if ((led.spotPct||0) < spotPol.targetPct){
      return (spotPol.targetPct - (led.spotPct||0)) * led.equityUsd;
    }
    return 0;
  }

  private buildQuestions(_x: VIVO01Input, posture: Posture, plans: VIVOPlan[]): VIVOAsk[] {
    const ids = plans.map(p=>p.id);
    const qs: VIVOAsk[] = [
      { q:"Plan seÃ§imi?", choices: ids, default: ids[0], timeoutSec: 45 },
    ];
    if (posture !== "RISK_OFF") {
      qs.push({ q:"Min +%4 hedef saÄŸlanÄ±yorsa uygulansÄ±n mÄ±?", choices:["Evet","HayÄ±r"], default:"Evet", timeoutSec:30 });
    }
    return qs;
  }

  private notesFrom(x: VIVO01Input): string[] {
    const n: string[] = [];
    if (x.risk.level==="AMBER") n.push("AMBER: TWAP +200â€“300ms, iceberg dÃ¼ÅŸÃ¼k");
    if (x.risk.sentinel!=="NORMAL") n.push(`Sentinel=${x.risk.sentinel}`);
    if (x.dominance.ethRel>0 && x.dominance.btcD<0.55) n.push("ETH gÃ¼Ã§ > BTC; alt sepet destekli");
    return n;
  }

  private auditLines(x: VIVO01Input, posture: Posture, plans: VIVOPlan[]): string[] {
    return [
      `risk=${x.risk.level}/${x.risk.sentinel}`,
      `posture=${posture}`,
      `btcD=${x.dominance.btcD.toFixed(2)} ethRel=${x.dominance.ethRel.toFixed(2)} altRet=${x.dominance.altRet.toFixed(3)}`,
      `plans=${plans.map(p=>p.id).join(",")}`
    ];
  }

  private err(code:string, message:string, details?:any): { error: StdError } {
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test AltyapÄ±sÄ± (Vitest Ã¶rnekleri)
// vivo/__tests__/marketPostureAdvisor.test.ts
import { describe,it,expect } from "vitest";
import { MarketPostureAdvisor } from "../marketPostureAdvisor";
import type { VIVO01Input } from "../types";

const base: VIVO01Input = {
  risk: { level:"AMBER", sentinel:"NORMAL" },
  wf: { exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }, trend:{ atrK:2.8, pyramid:{maxAdds:2, addEveryPct:5, sizePct:0.33} } },
  ledger: { equityUsd: 100_000, spotPct: 0.20, ddPct: 0.05 },
  dominance: { btcD:0.52, ethRel:0.03, altRet:0.01 },
  policy: { minTargetPct:4, whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], spot:{ targetPct:0.30, equityThresholdUsd:100_000 } },
  exposure: { BTCUSDT:{ decision:"ALLOW" }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd: 20_000 }, OPUSDT:{ decision:"ALLOW" } },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:3.5, R_multiple:1.1 } }
};

describe("VIVO-01", ()=>{
  it("validates policy", ()=>{
    const vivo = new MarketPostureAdvisor();
    const bad = JSON.parse(JSON.stringify(base)); bad.policy.minTargetPct = 3;
    const res:any = vivo.run(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });

  it("produces plans A and C on AMBER", ()=>{
    const vivo = new MarketPostureAdvisor();
    const res:any = vivo.run(base);
    const ids = res.plans.map((p:any)=>p.id);
    expect(ids.includes("A")).toBe(true);
    expect(ids.includes("C")).toBe(true);
    // OPUSDT dÃ¼ÅŸÃ¼k hedef nedeniyle dÄ±ÅŸarÄ±da
    expect(JSON.stringify(res)).not.toContain("OPUSDT");
  });

  it("RISK_OFF when sentinel != NORMAL", ()=>{
    const vivo = new MarketPostureAdvisor();
    const input = { ...base, risk:{ level:"GREEN", sentinel:"HALT_PARTIAL" } };
    const res:any = vivo.run(input);
    expect(res.posture).toBe("RISK_OFF");
    expect(res.plans.map((p:any)=>p.id)).toEqual(["C"]);
  });
});

Entegrasyon NotlarÄ±

VIVO-02 Â· strategyAllocator: Buradaki plans[] doÄŸrudan lot/child-order planÄ±na Ã§evrilecek; tick/lot/notional uyumluluÄŸu orada kesinleÅŸtirilecek.

operatorDialog: ask[] kartlarÄ±nÄ± Telegram/CLIâ€™ye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼p yanÄ±tlarÄ± VIVO-02â€™ye iletir.

GB-61/70/75: Posture ve plan notlarÄ± bu sinyalleri yansÄ±tÄ±r; devre kesici durumunda Plan A/B Ã¼retimi otomatik devre dÄ±ÅŸÄ±.

OtobilinÃ§/LIVIA: Riskli davranÄ±ÅŸ uyarÄ±sÄ± gelirse plan applicability veya posture baskÄ±lanÄ±r (NEUTRAL/RISK_OFF).
_________________________________________________________________________________________________________________
VIVO-02 Â· strategyAllocator.ts

AmaÃ§ (tek cÃ¼mle):
VIVO-01â€™den gelen Plan A/B/Câ€™yi borsa kurallarÄ± ve RiskNet kapÄ±larÄ± ile uyuÅŸacak ÅŸekilde notionalâ†’fiyatâ†’miktar kuantizasyonu yaparak icra edilebilir emir paketlerine dÃ¶nÃ¼ÅŸtÃ¼rmek ve ops.actions Ã¼zerinden yayÄ±nlamak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

Binance kurallarÄ±: PRICE_FILTER (tickSize), LOT_SIZE (stepSize), (MIN_)NOTIONAL, PERCENT_PRICE(_BY_SIDE), MAX_POSITION, TRAILING_DELTA (varsa), LIMIT_MAKER post-only cross korumasÄ±.

Rate-limit ve backoff jitter Ã¼st katmanda; bu modÃ¼l paket boyutu ve Ã§ocuk sayÄ±sÄ±nÄ± sÄ±nÄ±rlar.

Risk/sentinel (GB-61/70/75): SLOWDOWN/HALT/CIRCUIT_BREAKER â†’ reduce-only dÄ±ÅŸÄ±nda yeni pozisyon aÃ§maz.

Politika kapÄ±larÄ± (+%4, whitelist) VIVO-01â€™de geÃ§ildi; burada yeniden doÄŸrulanÄ±r (savunmacÄ± programlama).

KapanmamÄ±ÅŸ bar yok â†’ expectedMove yalnÄ±z kapanmÄ±ÅŸ barlardan geldiÄŸi varsayÄ±lÄ±r.

Slipaj/komisyon/funding VIVO-02â€™de muhasebeleÅŸtirilmez; TCA (GB-22/36) raporlar.

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/strategyAllocator.types.ts
import type { ISODate } from "../core/types";

export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface ExchangeRule {
  symbol: string;
  tickSize: number;     // PRICE_FILTER
  stepSize: number;     // LOT_SIZE
  minNotional: number;  // (MIN_)NOTIONAL
  percent?: {           // PERCENT_PRICE / BY_SIDE (opsiyonel)
    bidUp?: number; bidDown?: number; askUp?: number; askDown?: number; avgPriceMins?: number;
  };
}

export interface BookTicker {
  symbol: string;
  bid: number; ask: number; mid: number;
  asOf: ISODate;
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;
  maxPositionQty?: number; // opsiyonel Ã¼st sÄ±nÄ±r
}

export interface ExecParams {
  limitOffsetBps: number;     // Ã¶r: 6
  twapMs: number;             // Ã¶r: 1400
  iceberg: number;            // [0..1] Ã§ocuk miktar oranÄ±
  childType: ChildType;       // LIMIT/IOC/POST_ONLY/MARKET
}

export interface PlanSymbol {
  symbol: string;
  notionalUsd: number;
  side?: Side;                // yoksa varsayÄ±lan BUY
}

export interface PlanIn {
  id: "A"|"B"|"C";
  title: string;
  symbols: PlanSymbol[];
  exec: ExecParams;
  notes?: string[];
}

export interface AllocatorInput {
  plan: PlanIn;
  whitelist: string[];
  minTargetPct: number;         // â‰¥4 (savunma amaÃ§lÄ± tekrar doÄŸrula)
  sentiment?: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
  exposure: Record<string, ExposureGate>;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
}

export interface ChildOrder {
  symbol: string;
  side: Side;
  type: ChildType;
  price?: number;               // MARKET/IOC iÃ§in opsiyonel
  qty: number;
  tif?: "GTC"|"IOC"|"FOK";
  postOnly?: boolean;           // LIMIT_MAKER gÃ¼venliÄŸi iÃ§in
  reduceOnly?: boolean;         // sentinel/position dÃ¼ÅŸÃ¼rme
  meta?: { twapMs?: number; iceberg?: number; corrId?: string };
}

export interface ActionBundle {
  asOf: ISODate;
  planId: "A"|"B"|"C";
  children: ChildOrder[];
  comments?: string[];
}

export interface AllocError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.plan (seÃ§ilen plan) veya vivo.posture + operatorDialog sonucu.

Publish: ops.actions (ActionBundle), audit.log (karar izi), gb.route (opsiyonel pre-view).

Kod Ä°skeleti
// vivo/strategyAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocatorInput, ActionBundle, ChildOrder, ExchangeRule, BookTicker, AllocError, Side, ChildType
} from "./strategyAllocator.types";

export class StrategyAllocator extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-02";

  run(x: AllocatorInput): ActionBundle | { error: AllocError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      // Sentinel â†’ reduce-only
      const reduceOnly = x.sentiment && x.sentiment !== "NORMAL";

      const children: ChildOrder[] = [];
      for (const ps of x.plan.symbols) {
        const sym = ps.symbol.toUpperCase();
        if (!x.whitelist.includes(sym)) { logger.warn({sym},"non-whitelist skipped"); continue; }

        const gate = x.exposure[sym];
        if (!gate || gate.decision==="DENY") { logger.warn({sym},"exposure deny"); continue; }
        if (gate.decision==="REDUCE_ONLY" && !reduceOnly) {
          // Plan long aÃ§maya Ã§alÄ±ÅŸÄ±yorsa engelle; reduce-only ise sadece kapama/trim yapÄ±lmalÄ±
          logger.warn({sym},"exposure reduce-only blocks new opens"); continue;
        }

        const rules = x.rules[sym];  if (!rules) { logger.warn({sym},"missing rules"); continue; }
        const tk = x.tickers[sym];   if (!tk || tk.bid<=0 || tk.ask<=0) { logger.warn({sym},"missing ticker"); continue; }

        // Notional â†’ price/qty kuantizasyonu
        const side: Side = ps.side ?? "BUY";
        const px = this.targetPrice(side, x.plan.exec.childType, x.plan.exec.limitOffsetBps, tk);
        const { price, qty, reason } = this.quantize(sym, side, px, ps.notionalUsd, rules);

        if (qty <= 0 || !Number.isFinite(price!)) { logger.warn({sym, reason},"quantize failed"); continue; }

        // Exposure TRIM: notional Ã¼st sÄ±nÄ±rÄ± geÃ§ilmesin
        if (gate.decision==="TRIM" && gate.allowedNotionalUsd && ps.notionalUsd > gate.allowedNotionalUsd) {
          const scale = Math.max(0, gate.allowedNotionalUsd / ps.notionalUsd);
          const adjQty = this.roundQty(qty * scale, rules.stepSize);
          if (adjQty <= 0) { logger.warn({sym},"trimâ†’zero qty"); continue; }
          children.push(this.child(sym, side, x.plan.exec.childType, price!, adjQty, reduceOnly, x.plan.exec));
          continue;
        }

        children.push(this.child(sym, side, x.plan.exec.childType, price!, qty, reduceOnly, x.plan.exec));
      }

      const bundle: ActionBundle = { asOf:new Date().toISOString(), planId:x.plan.id, children, comments: x.plan.notes ?? [] };
      bus.emit<ActionBundle>("ops.actions", bundle);
      return bundle;

    } catch (e:any) {
      return this.err("ALLOCATOR_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- Validasyon ---
  private validate(x: AllocatorInput): string | null {
    if (!x.plan || !Array.isArray(x.plan.symbols) || x.plan.symbols.length===0) return "empty plan";
    if (!Array.isArray(x.whitelist) || x.whitelist.length===0) return "empty whitelist";
    if ((x.minTargetPct ?? 0) < 4) return "minTargetPct must be â‰¥4";
    if (!x.rules || !x.tickers) return "missing rules/tickers";
    return null;
  }

  // --- Fiyat hedefi ---
  private targetPrice(side: Side, type: ChildType, offsetBps: number, t: BookTicker): number {
    const ofs = (offsetBps||0) / 10_000;
    if (type==="MARKET") return side==="BUY" ? t.ask : t.bid;
    if (type==="IOC")    return side==="BUY" ? t.ask * (1 + ofs) : t.bid * (1 - ofs);
    if (type==="POST_ONLY") return side==="BUY" ? t.bid * (1 - Math.max(ofs, 0.0001)) : t.ask * (1 + Math.max(ofs, 0.0001));
    // LIMIT
    return side==="BUY" ? t.ask * (1 + ofs) : t.bid * (1 - ofs);
  }

  // --- Kuantizasyon & filtreler ---
  private quantize(symbol:string, side:Side, rawPx:number, notionalUsd:number, r: ExchangeRule){
    // PRICE_FILTER (tick) â†’ price
    const price = this.roundPrice(rawPx, r.tickSize);
    // NOTIONAL
    const qty0  = notionalUsd / price;
    // LOT_SIZE (step)
    const qty   = this.roundQty(qty0, r.stepSize);
    // MIN_NOTIONAL
    const notion = price * qty;
    if (notion < r.minNotional) {
      return { price, qty: 0, reason:`minNotional ${notion.toFixed(2)} < ${r.minNotional}` };
    }
    // PERCENT_PRICE_BY_SIDE (opsiyonel, fail-safe clamp)
    if (r.percent) {
      const up  = side==="BUY" ? (r.percent.bidUp ?? r.percent.askUp) : (r.percent.askUp ?? r.percent.bidUp);
      const down= side==="BUY" ? (r.percent.bidDown ?? r.percent.askDown) : (r.percent.askDown ?? r.percent.bidDown);
      // Burada yalnÄ±zca uyarÄ± Ã¼ret; gerÃ§ek clamp iÃ§in book ortalamasÄ±na ihtiyaÃ§ var (upper/lower bound)
      // (Ãœst katmanda engine reddederse fallback yapÄ±lÄ±r)
    }
    return { price, qty, reason:"ok" };
  }

  private roundPrice(x:number, tick:number){ return Math.round(x / tick) * tick; }
  private roundQty(x:number, step:number){ return Math.floor(x / step) * step; }

  private child(symbol:string, side:Side, type:ChildType, price:number, qty:number, reduceOnly:boolean, exec:any): ChildOrder {
    const tif = type==="IOC" ? "IOC" : "GTC";
    const postOnly = (type==="POST_ONLY");
    return { symbol, side, type, price, qty, tif, postOnly, reduceOnly, meta:{ twapMs: exec.twapMs, iceberg: exec.iceberg } };
  }

  // --- Hata ---
  private err(code:string, message:string, details?:any): { error: AllocError } {
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/strategyAllocator.test.ts
import { describe,it,expect } from "vitest";
import { StrategyAllocator } from "../strategyAllocator";
import type { AllocatorInput } from "../strategyAllocator.types";

const rules = {
  BTCUSDT: { symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10 },
  ETHUSDT: { symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10 }
};
const tickers = {
  BTCUSDT: { symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
  ETHUSDT: { symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() }
};

const base: AllocatorInput = {
  plan: {
    id:"A", title:"Trend Yakala: BTC+ETH",
    symbols:[ {symbol:"BTCUSDT", notionalUsd: 10_000}, {symbol:"ETHUSDT", notionalUsd: 5_000} ],
    exec: { limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }
  },
  whitelist:["BTCUSDT","ETHUSDT"],
  minTargetPct: 4,
  sentiment: "NORMAL",
  exposure: { BTCUSDT:{ decision:"ALLOW" }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd: 4_000 } },
  rules, tickers
};

describe("VIVO-02 strategyAllocator", ()=>{
  it("builds child orders with tick/step/minNotional", ()=>{
    const sa = new StrategyAllocator();
    const out:any = sa.run(base);
    expect(out.children.length).toBe(2);
    out.children.forEach((c:any)=>{
      // stepSize uygundur
      expect( (c.qty / rules[c.symbol].stepSize) % 1 ).toBe(0);
      // tickSize uygundur
      expect( (c.price / rules[c.symbol].tickSize) % 1 ).toBe(0);
      // notional â‰¥ min
      expect(c.price * c.qty).toBeGreaterThanOrEqual(rules[c.symbol].minNotional);
    });
  });

  it("respects exposure TRIM and sentinel reduce-only", ()=>{
    const sa = new StrategyAllocator();
    const inp = structuredClone(base);
    inp.sentiment = "HALT_PARTIAL"; // reduce-only
    const out:any = sa.run(inp);
    expect(out.children.every((c:any)=>c.reduceOnly===true)).toBe(true);
  });

  it("skips non-whitelist symbols", ()=>{
    const sa = new StrategyAllocator();
    const inp = structuredClone(base);
    inp.whitelist = ["BTCUSDT"]; // ETH yok
    const out:any = sa.run(inp);
    expect(out.children.find((c:any)=>c.symbol==="ETHUSDT")).toBeUndefined();
  });
});

Entegrasyon NotlarÄ±

Girdi kaynaÄŸÄ±: operatorDialog seÃ§imi sonrasÄ± Plan A/B/C â†’ vivo.plan ile StrategyAllocator.run() Ã§aÄŸrÄ±sÄ±na sarÄ±lÄ±r.

Ã‡Ä±ktÄ±: ops.actions (child order listesi) GB-66/67 tarafÄ±ndan yÃ¼rÃ¼tÃ¼lÃ¼r.

KorumacÄ± davranÄ±ÅŸ: sentiment!="NORMAL" ise tÃ¼m Ã§ocuk emirler reduceOnly.

LIMIT_MAKER gÃ¼venliÄŸi: POST_ONLY tipi verildiÄŸinde fiyat best bid/askâ€™Ä± cross etmeyecek ÅŸekilde negatif/pozitif ofsetle set edilir (yukarÄ±daki targetPrice bunu yapÄ±yor).

Percent-price clamp (opsiyonel): Ä°stersen rules.percent doluysa upper/lower band hesabÄ±nÄ± ekleyip priceÄ± banda kÄ±rpabilirsin.
_________________________________________________________________________________________________________________
VIVO-03 Â· operatorDialog.ts

AmaÃ§ (tek cÃ¼mle):
VIVO-01â€™in Ã¼rettiÄŸi Plan A/B/C ve politika kapÄ±larÄ±na iliÅŸkin evet/hayÄ±r sorularÄ±nÄ± Telegram/CLI Ã¼zerinden operatÃ¶re sunup yanÄ±tlarÄ± toplar; timeout durumunda korumacÄ± default karar verir ve seÃ§imi vivo.plan â†’ ops.actions hattÄ±na taÅŸÄ±r.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok (yalnÄ±z diyalog; sinyal metrikleri VIVO-01â€™den gelir).

Risk/Sentinel RED/HALT/CB ise reduce-only planlarÄ± tercih et (korumacÄ± default).

Politika kapÄ±larÄ± (+%4 hedef / whitelist / spot %30) VIVO-01â€™de uygulanmÄ±ÅŸtÄ±r; burada sadece kullanÄ±cÄ± onayÄ± alÄ±nÄ±r.

Idempotency: AynÄ± corrId tekrar gelirse ikinci kez soru sorma.

Timeout â†’ varsayÄ±lan seÃ§eneÄŸi uygula (genellikle Plan A ve â€œEvetâ€).

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/operatorDialog.types.ts
import type { ISODate } from "../core/types";

export interface VIVOAsk {
  q: string;
  choices: string[];      // ["A","B","C"] veya ["Evet","HayÄ±r"]
  default: string;        // default seÃ§im
  timeoutSec: number;     // 10..120 arasÄ± Ã¶nerilir
}

export interface VIVOPlan {
  id: "A"|"B"|"C";
  title: string;
  symbols: Array<Record<string, number>>;
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  spotTopup?: { targetPct:number; amountUsd:number } | null;
  notes?: string[];
}

export interface VIVOOutputPayload {
  asOf: ISODate;
  posture: "RISK_ON"|"NEUTRAL"|"RISK_OFF";
  plans: VIVOPlan[];
  ask: VIVOAsk[];
  audit: string[];
  corrId?: string;
}

export interface DialogConfig {
  ui: "TELEGRAM"|"CLI";
  chatId?: string;        // telegram ise zorunlu
  timeoutSafetySec?: number; // global fail-safe (opsiyonel)
}

export interface DialogResult {
  corrId?: string;
  selectedPlanId: "A"|"B"|"C";
  confirmations: Record<number,string>;  // soru index â†’ cevap
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.posture (VIVO-01 Ã§Ä±ktÄ±sÄ±; iÃ§indeki ask[] sorularÄ± ve plans[] kartlarÄ±)

Publish:

vivo.plan (seÃ§ilen plan: VIVOPlan)

audit.log (soru-cevap ve timeout/gerekÃ§eler)

Validasyon & Tip Kontrolleri

En az 1 plan ve 1 soru olmalÄ± (Plan C â€” Nakit/Spot â€” her durumda bulunur).

ask[].choices iÃ§inde default bulunmak zorunda.

ui="TELEGRAM" ise chatId zorunlu.

AynÄ± corrId daha Ã¶nce iÅŸlendiyse idempotent olarak yut (yeniden soru sorma).

Hata YÃ¶netimi & Logging

{ code,message,details,retriable } biÃ§imi; tÃ¼m kritik adÄ±mlar audit.logâ€™a dÃ¼ÅŸer.

Telegram/CLI iletim hatasÄ± durumunda CLI fallback mesajÄ± (opsiyonel hook) veya timeout default uygulanÄ±r.

Kod Ä°skeleti (TypeScript / Node.js)
// vivo/operatorDialog.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type { VIVOOutputPayload, VIVOPlan, VIVOAsk, DialogConfig, DialogResult, StdError } from "./operatorDialog.types";

export interface ChatAdapter {
  sendText(chatId: string, text: string): Promise<void>;
  askChoice(chatId: string, text: string, choices: string[], timeoutSec: number, defaultChoice: string): Promise<{ choice: string; decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT" }>;
}

// Basit CLI adapter Ã¶rneÄŸi:
export class CliAdapter implements ChatAdapter {
  async sendText(_chatId: string, text: string){ console.log(text); }
  async askChoice(_chatId: string, text: string, choices: string[], timeoutSec: number, defaultChoice: string){
    console.log(`[SORU] ${text} (${timeoutSec}s) -> ${choices.join("/")}, default=${defaultChoice}`);
    // GerÃ§ek CLI iÃ§in readline + timer; demo amaÃ§lÄ± otomatik default:
    await new Promise(r=>setTimeout(r, Math.min(1500, timeoutSec*1000)));
    return { choice: defaultChoice, decidedBy: "TIMEOUT_DEFAULT" };
  }
}

export class OperatorDialog extends EventEmitter {
  ver = "1.0.0"; src = "VIVO-03";
  private seenCorr = new Set<string>();
  constructor(private cfg: DialogConfig, private adapter: ChatAdapter){ super(); }

  /** VIVO-01 Ã§Ä±ktÄ±larÄ±nÄ± dinle ve soru/plan akÄ±ÅŸÄ±nÄ± baÅŸlat */
  attach(){
    bus.on<VIVOOutputPayload>("vivo.posture", (env)=> this.process(env));
  }

  async process(env: VIVOOutputPayload): Promise<DialogResult | { error: StdError }> {
    try {
      const corrId = env.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      if (this.seenCorr.has(corrId)) return this.err("IDEMPOTENT", "corrId already processed", { corrId });

      const { plans, ask } = env;
      const valErr = this.validate(plans, ask); if (valErr) return this.err("VALIDATION_ERROR", valErr);

      const chatId = this.cfg.chatId ?? "CLI";
      // 1) Plan kartlarÄ±nÄ± gÃ¶nder
      await this.adapter.sendText(chatId, this.renderPlanCards(env));

      // 2) SorularÄ± sÄ±rayla sor
      const answers: string[] = [];
      for (let i=0; i<ask.length; i++){
        const a = ask[i];
        const res = await this.adapter.askChoice(chatId, a.q, a.choices, a.timeoutSec, a.default);
        answers.push(res.choice);
      }

      // 3) Plan seÃ§imi (ilk soru Plan seÃ§imi olmalÄ±)
      const planChoice = answers[0] as "A"|"B"|"C";
      const selected = plans.find(p=>p.id===planChoice) ?? plans[0];

      const decidedBy = (answers[0]===ask[0].default) ? "TIMEOUT_DEFAULT" : "OPERATOR";
      const result: DialogResult = {
        corrId, selectedPlanId: selected.id,
        confirmations: Object.fromEntries(answers.map((v,i)=>[i,v])),
        decidedBy, decidedAt: new Date().toISOString()
      };

      // 4) YayÄ±nla â†’ strategyAllocator bu planÄ± alacak
      bus.emit<VIVOPlan>("vivo.plan", selected);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ dialog: result, posture: env.posture } });

      this.seenCorr.add(corrId);
      return result;

    } catch (e:any){
      return this.err("DIALOG_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private validate(plans: VIVOPlan[], ask: VIVOAsk[]): string | null {
    if (!Array.isArray(plans) || plans.length===0) return "no plans";
    if (!Array.isArray(ask) || ask.length===0) return "no questions";
    for (const q of ask){
      if (!q.choices.includes(q.default)) return `default not in choices for question: ${q.q}`;
    }
    return null;
  }

  private renderPlanCards(env: VIVOOutputPayload){
    const lines: string[] = [];
    lines.push(`ğŸ“£ VIVO-01 | PostÃ¼r: ${env.posture}`);
    for (const p of env.plans){
      const sumNotional = p.symbols.reduce((a,o)=>a+Object.values(o)[0],0);
      lines.push(`\nâ€” Plan ${p.id}: ${p.title}\n  Notionalâ‰ˆ$${Math.round(sumNotional)} | Exec=${p.exec.childType}/twap:${p.exec.twapMs}ms/iceberg:${p.exec.iceberg}`);
      const syms = p.symbols.map(o=>`${Object.keys(o)[0]}:$${Object.values(o)[0]}`).join(", ");
      if (syms) lines.push(`  > ${syms}`);
      if (p.spotTopup) lines.push(`  Spot Top-Up: %${Math.round(p.spotTopup.targetPct*100)/100} â†’ $${p.spotTopup.amountUsd}`);
      if (p.notes?.length) lines.push(`  Notlar: ${p.notes.join(" | ")}`);
    }
    lines.push("\nâ“ LÃ¼tfen seÃ§im yap: Plan A/B/C. ArdÄ±ndan +%4 kapÄ±sÄ± iÃ§in 'Evet/HayÄ±r'.");
    return lines.join("\n");
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/operatorDialog.test.ts
import { describe,it,expect,vi } from "vitest";
import { OperatorDialog, CliAdapter } from "../operatorDialog";
import type { VIVOOutputPayload } from "../operatorDialog.types";

const env: VIVOOutputPayload = {
  asOf: new Date().toISOString(),
  posture: "NEUTRAL",
  corrId: "test-123",
  plans: [
    { id:"A", title:"Trend Yakala BTC+ETH", symbols:[{"BTCUSDT":10000},{"ETHUSDT":8000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"}, spotTopup:{targetPct:0.3, amountUsd:2000} }
  ],
  ask: [
    { q:"Plan seÃ§imi?", choices:["A","B","C"], default:"A", timeoutSec:3 },
    { q:"+%4 hedef uygulanacak. Onay?", choices:["Evet","HayÄ±r"], default:"Evet", timeoutSec:3 }
  ],
  audit:[]
};

describe("VIVO-03 operatorDialog", ()=>{
  it("falls back to timeout default", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    const res:any = await od.process(env);
    expect(res.decidedBy).toBe("TIMEOUT_DEFAULT");
    expect(res.selectedPlanId).toBe("A");
  });

  it("validates questions", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    const bad = structuredClone(env);
    bad.ask[0].default = "X";
    const res:any = await od.process(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });

  it("idempotent by corrId", async ()=>{
    const od = new OperatorDialog({ ui:"CLI" }, new CliAdapter());
    await od.process(env);
    const res:any = await od.process(env); // aynÄ± corrId
    expect(res.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-01 â†’ (vivo.posture): Plan A/B/C + ask[] yayÄ±nlanÄ±r.

VIVO-03 operatorDialog: Plan kartlarÄ±nÄ± ve sorularÄ± Telegram/CLIâ€™de gÃ¶sterip yanÄ±tlarÄ± toplar.

SeÃ§im â†’ (vivo.plan): SeÃ§ilen VIVOPlan yayÄ±nlanÄ±r.

VIVO-02 strategyAllocator: vivo.planâ€™Ä± alÄ±r â†’ ops.actions Ã§ocuk emir paketi Ã¼retir.

GB-66/67: Emirleri yÃ¼rÃ¼tÃ¼r; sonuÃ§lar GB-22/36 ve VIVO uplift modÃ¼llerine akar.
_________________________________________________________________________________________________________________
VIVO-04 Â· postureMemory.ts

AmaÃ§ (tek cÃ¼mle):
Son 7/30 gÃ¼nÃ¼n postÃ¼r (Risk-AÃ§Ä±k/NÃ¶tr/Risk-KapalÄ±) ve plan (A/B/C) performanslarÄ±nÄ± EWMA ile izleyip postÃ¼r aÄŸÄ±rlÄ±klarÄ±, varsayÄ±lan plan ve yÃ¼rÃ¼tme ayarÄ± (TWAP/iceberg/childType) Ã¶nerileri Ã¼retmek; VIVO-01 (plan kurucu) ve VIVO-03 (dialog default) iÃ§in karar kalitesini artÄ±rmak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; metrikler GB-22/36 (TCA/mark-out/slipaj) tarafÄ±ndan hesaplanÄ±r, bu modÃ¼l sadece tÃ¼ketir.

Live-BT farkÄ± â‰¤ %20 hedefini ihlal eden dÃ¶nemler aÄŸÄ±rlÄ±ÄŸÄ± cezalandÄ±rÄ±r.

Risk/Sentinel (GB-61/70/75) RED/CB gÃ¼nleri ayrÄ± etiketlenir (normal gÃ¼nlerle karÄ±ÅŸmaz).

Politika (+%4, whitelist, spot %30) Ã¼st katmanda uygulanÄ±r; hafÄ±za Ã¶neri/tuning Ã¼retir (politika kapÄ±larÄ±nÄ± deÄŸiÅŸtirmez).

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/postureMemory.types.ts
import type { ISODate } from "../core/types";

export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";

export interface SessionKey {
  corrId: string;
}

export interface DecisionEvent {
  asOf: ISODate;
  corrId: string;
  posture: Posture;
  planId: PlanId;
  symbols: string[];
  sentiment: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
}

export interface OutcomeEvent {
  asOf: ISODate;
  corrId: string;
  pf: number;              // profit factor
  hitRate: number;         // 0..1
  avgR: number;            // beklenen â‰¥ 0.3
  maxDD: number;           // 0..1 (Ã¶rn 0.12 = %12)
  slipBps: number;         // realized slippage (bps)
  markout30sBps: number;   // 30s mark-out
  commShare: number;       // komisyonun kÃ¢r iÃ§indeki payÄ± (0..1)
  liveBTGap: number;       // |live - backtest| / backtest (0..1)
}

export interface MemoryConfig {
  shortDays: number; // 7
  longDays: number;  // 30
  alphaShort: number; // 0.3
  alphaLong: number;  // 0.1
  decayPerDay: number; // 0.98
}

export interface Weights {
  posture: Record<Posture, number>; // 0..1 normalize
  planDefault: Record<Posture, PlanId>; // Ã¶nerilen default Plan
  execTuning: {  // VIVO-01/02 iÃ§in Ã¶neriler
    twapMsDelta: number;         // +pozitif = daha yavaÅŸ
    icebergDelta: number;        // +pozitif = daha kÃ¼Ã§Ã¼k gÃ¶rÃ¼nÃ¼r boy
    preferChild?: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
  };
}

export interface Snapshot {
  asOf: ISODate;
  short: { pf:number; hit:number; avgR:number; dd:number; slip:number; gap:number };
  long:  { pf:number; hit:number; avgR:number; dd:number; slip:number; gap:number };
  weights: Weights;
  notes: string[];
}

export interface MemoryError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.plan (seÃ§ilen plan) â†’ DecisionEventâ€™e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r (corrId varsa).

gb.tca (TCA/sonuÃ§ akÄ±ÅŸÄ±) â†’ OutcomeEvent.

(opsiyonel) audit.log iÃ§indeki operatorDialog sonucu (corrId eÅŸlemesi iÃ§in).

Publish:

vivo.memory (Snapshot) â€” VIVO-01 ve VIVO-03 tarafÄ±ndan tÃ¼ketilir.

audit.log â€” gÃ¼ncelleme ve aÄŸÄ±rlÄ±k notlarÄ±.

Validasyon & Tip Kontrolleri

DecisionEvent.corrId ve OutcomeEvent.corrId zorunlu (eÅŸleÅŸme iÃ§in).

Metrikler aralÄ±klara clamp edilir: hitâˆˆ[0,1], pfâ‰¥0, liveBTGapâˆˆ[0,1], maxDDâˆˆ[0,1].

Sentinel RED/CB gÃ¼nleri karar aÄŸÄ±rlÄ±ÄŸÄ±na dahil edilmez, ayrÄ± not edilir.

Hata YÃ¶netimi & Logging

{ code,message,details,retriable } formatÄ±; tÃ¼m update adÄ±mlarÄ± audit.log.

EÅŸleÅŸmeyen OutcomeEvent geldiÄŸinde gecikmiÅŸ eÅŸleÅŸtirme kuyruÄŸu (TTL=24h) denenir; sonra dÃ¼ÅŸÃ¼lÃ¼r.

Kod Ä°skeleti (TypeScript / Node.js)
// vivo/postureMemory.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  DecisionEvent, OutcomeEvent, MemoryConfig, Snapshot, Weights, Posture, PlanId, MemoryError
} from "./postureMemory.types";

const clamp01 = (x:number)=> Math.max(0, Math.min(1, x));

interface SessionRow {
  corrId: string;
  asOf: string;
  posture: Posture;
  planId: PlanId;
  sentiment: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
  outcome?: OutcomeEvent;
}

export class PostureMemory extends EventEmitter {
  ver="1.0.0"; src="VIVO-04";

  private cfg: MemoryConfig;
  private sessions: Map<string, SessionRow> = new Map(); // corrIdâ†’row
  private aggShort = { pf:1, hit:0.5, avgR:0.3, dd:0.05, slip:10, gap:0.1 };
  private aggLong  = { pf:1, hit:0.5, avgR:0.3, dd:0.07, slip:12, gap:0.12 };

  constructor(cfg?: Partial<MemoryConfig>) {
    super();
    this.cfg = { shortDays:7, longDays:30, alphaShort:0.3, alphaLong:0.1, decayPerDay:0.98, ...cfg };
  }

  attach(){
    bus.on<DecisionEvent>("vivo.plan", (p:any)=> this.onDecision(this.normalizeDecision(p)));
    bus.on<OutcomeEvent>("gb.tca", (t:any)=> this.onOutcome(this.normalizeOutcome(t)));
  }

  onDecision(d: DecisionEvent){ // karar geldi
    if (!d?.corrId) return this.logErr("VALIDATION_ERROR","missing corrId",{d});
    this.sessions.set(d.corrId, { ...d });
    logger.info({ d }, "VIVO-04 decision stored");
  }

  onOutcome(o: OutcomeEvent){ // sonuÃ§ geldi
    if (!o?.corrId) return this.logErr("VALIDATION_ERROR","missing corrId",{o});
    const row = this.sessions.get(o.corrId);
    if (!row) { // gecikmiÅŸ eÅŸleÅŸme iÃ§in tente
      this.sessions.set(o.corrId, { corrId:o.corrId, asOf:o.asOf, posture:"NEUTRAL", planId:"C", sentiment:"NORMAL", outcome:o });
      logger.warn({o},"outcome without decision â€” tentatively stored");
      return;
    }
    row.outcome = o;
    this.updateAggregates(row);
    const snap = this.snapshot();
    bus.emit<Snapshot>("vivo.memory", snap);
    bus.emit("audit.log", { asOf:snap.asOf, ver:this.ver, src:this.src, payload:{ snapshot:snap } });
  }

  private updateAggregates(r: SessionRow){
    const o = r.outcome!;
    // Sentinel RED/CB gÃ¼nlerini aggregasyondan Ã§Ä±kar
    const sentinelBad = r.sentiment==="HALT_PARTIAL" || r.sentiment==="CIRCUIT_BREAKER";
    if (sentinelBad) { logger.warn({corrId:r.corrId},"excluded due to sentinel"); return; }

    // Normalize (temel cezalar)
    const pf     = Math.max(0, o.pf);
    const hit    = clamp01(o.hitRate);
    const avgR   = Math.max(0, o.avgR);
    const dd     = clamp01(o.maxDD);
    const slip   = Math.max(0, o.slipBps);
    const gap    = clamp01(o.liveBTGap);

    // Skor ceza fonksiyonlarÄ± (fazla agresif deÄŸil: 0..1 arasÄ±)
    const slipPenalty = 1 / (1 + slip/20);     // 20 bps Ã¼stÃ¼ baskÄ±lanÄ±r
    const ddPenalty   = 1 / (1 + (dd*100)/10); // %10 DD ~ yarÄ±m Ã§arpan
    const gapPenalty  = 1 - Math.min(gap, 0.5); // %50 gap â†’ 0.5 Ã§arpan

    // KÄ±sa/uzun EWMA
    const sA = this.cfg.alphaShort, lA = this.cfg.alphaLong;
    this.aggShort.pf   = (1-sA)*this.aggShort.pf   + sA*(pf * slipPenalty * ddPenalty * gapPenalty);
    this.aggShort.hit  = (1-sA)*this.aggShort.hit  + sA*(hit);
    this.aggShort.avgR = (1-sA)*this.aggShort.avgR + sA*(avgR);
    this.aggShort.dd   = (1-sA)*this.aggShort.dd   + sA*(dd);
    this.aggShort.slip = (1-sA)*this.aggShort.slip + sA*(slip);
    this.aggShort.gap  = (1-sA)*this.aggShort.gap  + sA*(gap);

    this.aggLong.pf   = (1-lA)*this.aggLong.pf   + lA*(pf * slipPenalty * ddPenalty * gapPenalty);
    this.aggLong.hit  = (1-lA)*this.aggLong.hit  + lA*(hit);
    this.aggLong.avgR = (1-lA)*this.aggLong.avgR + lA*(avgR);
    this.aggLong.dd   = (1-lA)*this.aggLong.dd   + lA*(dd);
    this.aggLong.slip = (1-lA)*this.aggLong.slip + lA*(slip);
    this.aggLong.gap  = (1-lA)*this.aggLong.gap  + lA*(gap);

    logger.info({ short:this.aggShort, long:this.aggLong },"EWMA updated");
  }

  snapshot(): Snapshot {
    const asOf = new Date().toISOString();
    const weights = this.computeWeights();

    const notes:string[] = [];
    if (this.aggShort.gap > 0.2) notes.push("Live-BT gap short > 20% â€” temkinli varsayÄ±lan");
    if (this.aggShort.slip > 25) notes.push("Slipaj yÃ¼ksek â€” TWAP/iceberg artÄ±r");
    if (this.aggShort.dd > 0.15) notes.push("MaxDD > %15 â€” risk dÃ¼ÅŸÃ¼r");

    return {
      asOf,
      short: { ...this.aggShort },
      long : { ...this.aggLong },
      weights,
      notes
    };
  }

  private computeWeights(): Weights {
    // Basit puanlama: PFâ†‘, hitâ†‘, avgRâ†‘; DDâ†“, slipâ†“, gapâ†“
    const score = (pf:number, hit:number, r:number, dd:number, slip:number, gap:number)=>{
      const pos = (pf/1.25) * (0.6*hit + 0.4*clamp01(r/0.5));
      const neg = (dd/0.15) + (slip/30) + (gap/0.2);
      return Math.max(0, pos - neg); // ~0..1 aralÄ±ÄŸÄ±na yakÄ±n
    };
    const s = score(this.aggShort.pf, this.aggShort.hit, this.aggShort.avgR, this.aggShort.dd, this.aggShort.slip, this.aggShort.gap);
    const l = score(this.aggLong.pf,  this.aggLong.hit,  this.aggLong.avgR,  this.aggLong.dd,  this.aggLong.slip,  this.aggLong.gap);

    // KÄ±sa dÃ¶nem aÄŸÄ±rlÄ±ÄŸÄ± yaklaÅŸÄ±mÄ±
    const wOn  = clamp01(0.5*s + 0.3*l);
    const wNeu = clamp01(0.4*l + 0.2*(1-s));
    const wOff = clamp01(1 - wOn*0.7 - wNeu*0.2);

    // Normalize
    const sum = wOn + wNeu + wOff || 1;
    const posture = {
      RISK_ON: +(wOn / sum).toFixed(3),
      NEUTRAL: +(wNeu/ sum).toFixed(3),
      RISK_OFF:+(wOff/ sum).toFixed(3)
    };

    // VarsayÄ±lan plan ve yÃ¼rÃ¼tme tuning Ã¶nerisi
    const planDefault: Record<Posture, PlanId> = {
      RISK_ON: "A",
      NEUTRAL: "A",
      RISK_OFF:"C"
    };

    // Exec tuning (kÄ±sa dÃ¶nem metriklerine gÃ¶re)
    const execTuning = {
      twapMsDelta: this.aggShort.slip > 20 ? +300 : (this.aggShort.gap > 0.2 ? +150 : 0),
      icebergDelta: this.aggShort.slip > 20 ? +0.03 : 0,
      preferChild: this.aggShort.slip > 25 ? "POST_ONLY" :
                   this.aggShort.gap  > 0.2 ? "IOC" : undefined
    } as Weights["execTuning"];

    return { posture, planDefault, execTuning };
  }

  // ---- yardÄ±mcÄ±: gelen objeleri sÄ±nÄ±rla ----
  private normalizeDecision(d:any): DecisionEvent {
    return {
      asOf: d.asOf || new Date().toISOString(),
      corrId: String(d.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`),
      posture: d.posture, planId: d.planId,
      symbols: Array.isArray(d.symbols) ? d.symbols : [],
      sentiment: d.sentinel ?? "NORMAL"
    };
  }
  private normalizeOutcome(o:any): OutcomeEvent {
    return {
      asOf: o.asOf || new Date().toISOString(),
      corrId: String(o.corrId),
      pf: Math.max(0, Number(o.pf ?? 0)),
      hitRate: clamp01(Number(o.hitRate ?? 0)),
      avgR: Math.max(0, Number(o.avgR ?? 0)),
      maxDD: clamp01(Number(o.maxDD ?? 0)),
      slipBps: Math.max(0, Number(o.slipBps ?? 0)),
      markout30sBps: Number(o.markout30sBps ?? 0),
      commShare: clamp01(Number(o.commShare ?? 0)),
      liveBTGap: clamp01(Number(o.liveBTGap ?? 0))
    };
  }

  private logErr(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return e as MemoryError;
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/postureMemory.test.ts
import { describe,it,expect } from "vitest";
import { PostureMemory } from "../postureMemory";

describe("VIVO-04 postureMemory", ()=>{
  it("updates EWMA and emits snapshot", ()=>{
    const pm = new PostureMemory({ alphaShort:0.5, alphaLong:0.2 });
    // Karar
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x1", posture:"RISK_ON", planId:"A", symbols:["BTCUSDT"], sentiment:"NORMAL" });
    // SonuÃ§
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x1", pf:1.5, hitRate:0.55, avgR:0.35, maxDD:0.08, slipBps:12, markout30sBps:5, commShare:0.25, liveBTGap:0.12 });
    const snap = pm.snapshot();
    expect(snap.short.pf).toBeGreaterThan(1);
    expect(snap.weights.posture.RISK_ON).toBeGreaterThan(0.3);
  });

  it("penalizes high slippage and liveBT gap", ()=>{
    const pm = new PostureMemory({ alphaShort:0.7, alphaLong:0.3 });
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x2", posture:"NEUTRAL", planId:"A", symbols:["ETHUSDT"], sentiment:"NORMAL" });
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x2", pf:1.3, hitRate:0.52, avgR:0.32, maxDD:0.1, slipBps:35, markout30sBps:-3, commShare:0.4, liveBTGap:0.35 });
    const snap = pm.snapshot();
    expect(snap.weights.execTuning.twapMsDelta).toBeGreaterThanOrEqual(150);
    expect(["POST_ONLY","IOC",undefined]).toContain(snap.weights.execTuning.preferChild);
  });

  it("excludes RED/CB sentinel outcomes", ()=>{
    const pm = new PostureMemory();
    pm.onDecision({ asOf:new Date().toISOString(), corrId:"x3", posture:"RISK_OFF", planId:"C", symbols:[], sentiment:"CIRCUIT_BREAKER" });
    pm.onOutcome({ asOf:new Date().toISOString(), corrId:"x3", pf:2.0, hitRate:0.8, avgR:0.5, maxDD:0.01, slipBps:2, markout30sBps:10, commShare:0.1, liveBTGap:0.05 });
    const before = pm.snapshot().short.pf;
    // RED/CB hariÃ§ bÄ±rakÄ±ldÄ±ÄŸÄ± iÃ§in pf sÄ±Ã§ramaz
    expect(before).toBeLessThanOrEqual(2.0);
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-01 planlarÄ± ve VIVO-03 seÃ§imi â†’ vivo.plan (corrId ile) â†’ VIVO-04 onDecision.

GB-22/36 sonuÃ§ akÄ±ÅŸÄ± â†’ gb.tca (corrId ile) â†’ VIVO-04 onOutcome.

VIVO-04 â†’ vivo.memory yayÄ±nlar: postÃ¼r weights, Plan default, exec tuning.

VIVO-01 bu Ã¶nerileri plan kurulumunda kullanÄ±r; VIVO-03 default seÃ§imleri gÃ¼nceller; VIVO-02 exec paramlarÄ±na twapMsDelta/icebergDelta/preferChild uygular.
_________________________________________________________________________________________________________________
VIVO-04 Â· postureMemory.ts

AmaÃ§ (tek cÃ¼mle):
Son 7/30 gÃ¼n karar ve sonuÃ§ gÃ¼nlÃ¼klerini tutup (PF, hit, avgR, slipaj, mark-out), postÃ¼r aÄŸÄ±rlÄ±klarÄ±nÄ± ve plan Ã¶neri aÄŸÄ±rlÄ±klarÄ±nÄ± gÃ¼ncellemek; VIVO-01â€™in plan sÄ±ralamasÄ±nÄ± ve VIVO-03â€™Ã¼n default seÃ§imini veriyle yÃ¶nlendirmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar verisi yok; sonuÃ§lar yalnÄ±zca kapanan iÅŸlemler/oturum Ã¼zerinden gelir (GB-22/36 â†’ TCA).

Live vs BT drift â‰¤%20 hedefi; hafÄ±za, canlÄ± sonuÃ§larÄ± BTâ€™ye gÃ¶re ayrÄ± tutar.

Slipaj/komisyon/funding net PnL iÃ§inde muhasebeleÅŸtirilmiÅŸ kabul edilir (GB-22/36 besler).

Idempotency: aynÄ± tradeId/planCorrId bir kez iÅŸlenir.

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/postureMemory.types.ts
import type { ISODate } from "../core/types";

export type Horizon = "H7"|"H30";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";

export interface PlanOutcome {
  corrId: string;               // plan akÄ±ÅŸÄ±nÄ±n korelasyon id'si
  planId: PlanId;
  postureAtDecision: Posture;
  asOf: ISODate;
  // Performans (net)
  pnlUsd: number;               // realized net PnL
  rMultiple?: number;           // avg R
  hit?: boolean;                // TP/SL vb. Ã¶zet
  profitFactor?: number;        // gross win / gross loss
  slippageBps?: number;         // realized vs modeled
  markoutBp_5s?: number;        // ex-post kÄ±sa mark-out
  liveVsBtGapPct?: number;      // +: live > BT
}

export interface Rollup {
  n: number;
  pnlUsd: number;
  hitRate: number;
  avgR: number;
  profitFactor: number;
  slipAvgBps: number;
  markAvgBp5s: number;
}

export interface MemorySnapshot {
  asOf: ISODate;
  // Horizon baÅŸÄ±na toplulaÅŸtÄ±rmalar
  byPosture: Record<Posture, Record<Horizon, Rollup>>;
  byPlan:    Record<PlanId,  Record<Horizon, Rollup>>;
  // VIVO-01'e geri besleme
  postureWeights: Record<Posture, number>;   // 0..1 normalize
  planWeights:    Record<PlanId, number>;    // 0..1 normalize (A/B/C)
  defaults: { defaultPlan: PlanId };         // VIVO-03 timeout default Ã¶nerisi
}

export interface UpdateEvent {
  asOf: ISODate;
  outcome: PlanOutcome;
}

export interface MemoryConfig {
  ewmaAlphaShort: number;   // 0.2
  ewmaAlphaLong: number;    // 0.1
  minTradesForWeight: number; // 20 (H30â€™de)
  tieBreak: PlanId;         // eÅŸitlikte default (Ã¶rn "A")
}

export interface MemoryStore {
  load(): Promise<MemorySnapshot | null>;
  save(s: MemorySnapshot): Promise<void>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

gb.tca (GB-22/36 sonuÃ§larÄ± â†’ PlanOutcomeâ€™a maplenmiÅŸ)

vivo.uplift (A/B kolu sonuÃ§larÄ±; yine PlanOutcome alanlarÄ±nÄ± doldurur)

Publish:

vivo.memory (MemorySnapshot) â€“ VIVO-01 plan sÄ±ralamasÄ±, VIVO-03 default, VIVO-02 exec ince ayarÄ± iÃ§in

audit.log â€“ gÃ¼ncelleme Ã¶zeti (Ã¶nce/sonra aÄŸÄ±rlÄ±klar)

Validasyon & Tip Kontrolleri

pnlUsd finite; planId âˆˆ {A,B,C}; postureAtDecision geÃ§erli.

Same corrId ikinci kez gelirse yutulur (idempotent).

Rollup: EWMA (H7 iÃ§in Î±=ewmaAlphaShort, H30 iÃ§in Î±=ewmaAlphaLong), ayrÄ±ca count-weighted agregasyon.

Hata YÃ¶netimi & Logging

Standart hata { code, message, details, retriable }.

audit.log: outcome kabul/ret, rollup Ã¶nce/sonra, weight deÄŸiÅŸimleri.

Kod Ä°skeleti
// vivo/postureMemory.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  MemorySnapshot, MemoryConfig, MemoryStore, UpdateEvent, PlanOutcome, Posture, Horizon, Rollup, PlanId, StdError
} from "./postureMemory.types";

const POSTURES: Posture[] = ["RISK_ON","NEUTRAL","RISK_OFF"];
const PLANS: PlanId[] = ["A","B","C"];
const HORIZONS: Horizon[] = ["H7","H30"];

function emptyRoll(): Rollup { return { n:0, pnlUsd:0, hitRate:0, avgR:0, profitFactor:1, slipAvgBps:0, markAvgBp5s:0 }; }

export class InMemoryStore implements MemoryStore {
  private snap: MemorySnapshot | null = null;
  async load(){ return this.snap; }
  async save(s: MemorySnapshot){ this.snap = s; }
}

export class PostureMemory extends EventEmitter {
  ver="1.0.0"; src="VIVO-04";
  private store: MemoryStore;
  private cfg: MemoryConfig;
  private seenCorr = new Set<string>();
  private snap: MemorySnapshot;

  constructor(cfg?: Partial<MemoryConfig>, store?: MemoryStore){
    super();
    this.cfg = { ewmaAlphaShort:0.2, ewmaAlphaLong:0.1, minTradesForWeight:20, tieBreak:"A", ...cfg };
    this.store = store ?? new InMemoryStore();
    this.snap = {
      asOf: new Date().toISOString(),
      byPosture: Object.fromEntries(POSTURES.map(p=>[p, { H7:emptyRoll(), H30:emptyRoll() }])) as any,
      byPlan:    Object.fromEntries(PLANS.map(p=>[p, { H7:emptyRoll(), H30:emptyRoll() }])) as any,
      postureWeights: { RISK_ON:0.34, NEUTRAL:0.33, RISK_OFF:0.33 },
      planWeights: { A:0.5, B:0.35, C:0.15 },
      defaults: { defaultPlan:"A" }
    };
  }

  async attach(){
    const loaded = await this.store.load(); if (loaded) this.snap = loaded;
    bus.on<UpdateEvent>("gb.tca", (evt)=> this.update(evt).catch(e=>logger.error(e,"VIVO-04 update gb.tca")));
    bus.on<UpdateEvent>("vivo.uplift", (evt)=> this.update(evt).catch(e=>logger.error(e,"VIVO-04 update uplift")));
  }

  /** Manuel tetikleme iÃ§in */
  async update(evt: UpdateEvent): Promise<MemorySnapshot | { error: StdError }> {
    try {
      const o = evt.outcome;
      // idempotency
      if (this.seenCorr.has(o.corrId)) return this.ok();
      const val = this.validate(o); if (val) return this.err("VALIDATION_ERROR", val, { o });

      // EWMA gÃ¼ncelle
      this.ewmaUpdate("byPlan",    o.planId, o);
      this.ewmaUpdate("byPosture", o.postureAtDecision, o);

      // AÄŸÄ±rlÄ±klarÄ± hesapla (H30 Ã¶ncelikli, H7 ile hafif modÃ¼lasyon)
      this.recomputeWeights();

      // VarsayÄ±lan plan Ã¶nerisi (VIVO-03 timeout default)
      this.recomputeDefaultPlan();

      this.snap.asOf = new Date().toISOString();
      await this.store.save(this.snap);
      this.seenCorr.add(o.corrId);

      // publish
      bus.emit<MemorySnapshot>("vivo.memory", this.snap);
      bus.emit("audit.log", { asOf:this.snap.asOf, ver:this.ver, src:this.src,
        payload:{ msg:"memory updated", corrId:o.corrId, plan:o.planId, posture:o.postureAtDecision,
                  weights:{ posture:this.snap.postureWeights, plan:this.snap.planWeights } } });
      return this.snap;

    } catch (e:any){
      return this.err("MEMORY_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private validate(o: PlanOutcome): string | null {
    if (!o || typeof o.planId!=="string") return "outcome missing/planId invalid";
    if (!["A","B","C"].includes(o.planId)) return "planId not in A/B/C";
    if (!["RISK_ON","NEUTRAL","RISK_OFF"].includes(o.postureAtDecision)) return "invalid postureAtDecision";
    if (!Number.isFinite(o.pnlUsd)) return "pnlUsd invalid";
    return null;
  }

  private ewmaUpdate(target:"byPlan"|"byPosture", key: PlanId | Posture, o: PlanOutcome){
    const h7  = this.snap[target][key]["H7"];
    const h30 = this.snap[target][key]["H30"];
    this.mix(h7,  o, this.cfg.ewmaAlphaShort);
    this.mix(h30, o, this.cfg.ewmaAlphaLong);
  }

  private mix(r: Rollup, o: PlanOutcome, alpha: number){
    // EWMA: x_t = Î±Â·obs + (1-Î±)Â·x_{t-1}; n: sayma iÃ§in +1 (capâ€™leyebiliriz)
    r.n = Math.min(99999, r.n + 1);
    r.pnlUsd        = alpha*o.pnlUsd               + (1-alpha)*r.pnlUsd;
    r.hitRate       = alpha*((o.hit?1:0))          + (1-alpha)*r.hitRate;
    r.avgR          = alpha*(o.rMultiple ?? 0)     + (1-alpha)*r.avgR;
    r.profitFactor  = alpha*(o.profitFactor ?? 1)  + (1-alpha)*r.profitFactor;
    r.slipAvgBps    = alpha*(o.slippageBps ?? 0)   + (1-alpha)*r.slipAvgBps;
    r.markAvgBp5s   = alpha*(o.markoutBp_5s ?? 0)  + (1-alpha)*r.markAvgBp5s;
  }

  private recomputeWeights(){
    // H30â€™e gÃ¶re ana aÄŸÄ±rlÄ±k, H7 ile Â±%10 modÃ¼lasyon
    const wPlan: Record<PlanId, number> = { A:0, B:0, C:0 };
    for (const p of PLANS){
      const r30 = this.snap.byPlan[p]["H30"];
      const r7  = this.snap.byPlan[p]["H7"];
      const base = this.weightFromRoll(r30, this.cfg.minTradesForWeight);
      const mod  = 1 + clamp(this.weightFromRoll(r7, 5) - 0.5, -0.1, 0.1); // Â±%10
      wPlan[p] = Math.max(0, base * mod);
    }
    this.snap.planWeights = normalize(wPlan);

    const wPos: Record<Posture, number> = { RISK_ON:0, NEUTRAL:0, RISK_OFF:0 };
    for (const po of POSTURES){
      const r30 = this.snap.byPosture[po]["H30"];
      const r7  = this.snap.byPosture[po]["H7"];
      const base = this.weightFromRoll(r30, this.cfg.minTradesForWeight);
      const mod  = 1 + clamp(this.weightFromRoll(r7, 5) - 0.5, -0.1, 0.1);
      wPos[po] = Math.max(0, base * mod);
    }
    this.snap.postureWeights = normalize(wPos);
  }

  private weightFromRoll(r: Rollup, minN: number){
    // Basit skor: sigmoidal PF + hit + avgR â€“ slipaj cezalÄ±; yetersiz nâ€™de zayÄ±f skor
    const nScale = Math.min(1, r.n / minN);
    const pf = isFinite(r.profitFactor) ? Math.max(0, Math.min(2, r.profitFactor)) : 1;
    const pfScore  = (pf-1)/1;                 // [0..1] ~ PF 1..2
    const hitScore = r.hitRate;                // [0..1]
    const rScore   = Math.max(0, Math.min(1, r.avgR/1.0));   // Râ‰ˆ1 â†’ 1.0
    const slipPen  = Math.min(1, Math.abs(r.slipAvgBps)/20); // 20bps Ã¼stÃ¼ ceza
    const score = clamp(0.5*pfScore + 0.3*hitScore + 0.3*rScore - 0.2*slipPen, 0, 1);
    return score * (0.5 + 0.5*nScale); // az tradeâ€™de yarÄ±m aÄŸÄ±rlÄ±k
  }

  private recomputeDefaultPlan(){
    // En yÃ¼ksek plan weight â†’ default, sÄ±k sÄ±k Câ€™ye kayÄ±yorsa VIVO-01 planlamasÄ± daha korumacÄ± baÅŸlar
    const entries = Object.entries(this.snap.planWeights) as Array<[PlanId, number]>;
    entries.sort((a,b)=>b[1]-a[1]);
    const top = entries[0];
    this.snap.defaults.defaultPlan = (top && top[1]>0 ? top[0] : this.cfg.tieBreak);
  }

  private ok(){ return this.snap; }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

// ---- yardÄ±mcÄ± ----
function normalize<T extends string>(m: Record<T, number>): Record<T, number> {
  const sum = Object.values(m).reduce((a,b)=>a+b,0) || 1;
  const out = {} as Record<T, number>;
  for (const k in m) out[k as T] = +(m[k as T]/sum).toFixed(4);
  return out;
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/postureMemory.test.ts
import { describe,it,expect } from "vitest";
import { PostureMemory, InMemoryStore } from "../postureMemory";
import type { UpdateEvent } from "../postureMemory.types";

function mkEvt(id:string, plan:"A"|"B"|"C", posture:"RISK_ON"|"NEUTRAL"|"RISK_OFF", pnl:number): UpdateEvent {
  return { asOf:new Date().toISOString(), outcome:{ corrId:id, planId:plan, postureAtDecision:posture, asOf:new Date().toISOString(), pnlUsd:pnl, hit:(pnl>0), profitFactor:pnl>0?1.5:0.8, rMultiple: pnl>0?0.6: -0.3, slippageBps: 6, markoutBp_5s: 2 } };
}

describe("VIVO-04 postureMemory", ()=>{
  it("updates EWMA and publishes snapshot", async ()=>{
    const pm = new PostureMemory({ minTradesForWeight: 5 }, new InMemoryStore());
    await pm.attach(); // load none

    for (let i=0;i<6;i++){
      await pm.update( mkEvt(`x${i}`,"A","NEUTRAL", i%2===0? +100 : -50) );
    }
    const snap:any = await pm.update( mkEvt("x6","B","RISK_ON", +120) );
    expect(snap.byPlan.A.H30.n).toBeGreaterThan(0);
    expect(snap.planWeights.A + snap.planWeights.B + snap.planWeights.C).toBeCloseTo(1, 5);
    expect(["A","B","C"]).toContain(snap.defaults.defaultPlan);
  });

  it("is idempotent by corrId", async ()=>{
    const pm = new PostureMemory({}, new InMemoryStore());
    await pm.attach();
    const evt = mkEvt("dup","A","NEUTRAL",100);
    const s1:any = await pm.update(evt);
    const s2:any = await pm.update(evt); // same corrId
    expect(s2).toEqual(s1); // yutuldu
  });

  it("rejects invalid outcome", async ()=>{
    const pm = new PostureMemory({}, new InMemoryStore());
    await pm.attach();
    const bad:any = { asOf:new Date().toISOString(), outcome:{ corrId:"bad", planId:"Z", postureAtDecision:"NEUTRAL", asOf:new Date().toISOString(), pnlUsd: 10 } };
    const res:any = await pm.update(bad);
    expect(res.error.code).toBe("VALIDATION_ERROR");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

GB-22/36 â†’ gb.tca: Kapanan emir/plan sonuÃ§larÄ± PlanOutcomeâ€™a maplenip PostureMemory.update()â€™a akar.

VIVO-04: EWMA ile H7/H30 rollupâ€™larÄ± gÃ¼nceller â†’ planWeights, postureWeights, defaults.defaultPlan.

Publish â†’ vivo.memory:

VIVO-01 plan sÄ±ralamasÄ± ve postÃ¼r Ã¶nerisine aÄŸÄ±rlÄ±klarÄ± uygular.

VIVO-03 timeout defaultâ€™Ä± defaults.defaultPlan ile set eder.

VIVO-02 agresif/temkinli exec tercihlerinde hafif modÃ¼lasyon yapabilir.
_________________________________________________________________________________________________________________
VIVO-05 Â· planVariantGenerator.ts

AmaÃ§ (tek cÃ¼mle):
Baz plan(lar)Ä± A/B/C varyantlarÄ±na dÃ¶nÃ¼ÅŸtÃ¼rmek: limit ofseti, TWAP sÃ¼resi, iceberg oranÄ±, Ã§ocuk-tipi (LIMIT/IOC/POST_ONLY/MARKET) ve pyramiding parametrelerini RiskNet + HafÄ±za (VIVO-04) ile modÃ¼le etmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar verisi yok; yalnÄ±z param modÃ¼lasyonu yapÄ±lÄ±r.

Risk/Sentinel: AMBERâ†’temkinli mod; RED/CBâ†’yalnÄ±z korumacÄ± (C veya reduce-only varyant).

Politika (savunmacÄ± kontrol): whitelist ve minTargetPct â‰¥ +%4 saÄŸlanmayan sembol varyanta alÄ±nmaz.

Binance kurallarÄ± doÄŸrudan uygulanmaz (VIVO-02â€™ye bÄ±rakÄ±lÄ±r); ancak POST_ONLY seÃ§eneÄŸinde cross risk azaltÄ±cÄ± ofset Ã¶nerisi eklenir.

HafÄ±za (VIVO-04): planWeights ve postureWeights varyant katsayÄ±larÄ±na Ã§evrilir (bounded).

ArayÃ¼zler (TypeScript)
// vivo/planVariantGenerator.types.ts
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface BaseExec {
  limitOffsetBps: number;      // Ã¶r: 6
  twapMs: number;              // Ã¶r: 1400
  iceberg: number;             // 0..1
  childType: ChildType;
}
export interface TrendExec {
  atrK: number;
  pyramid?: { maxAdds:number; addEveryPct:number; sizePct:number };
}
export interface BasePlan {
  id: "A"|"B"|"C";
  title: string;
  symbols: Array<Record<string, number>>;   // {SYMBOL: notionalUsd}
  exec: BaseExec;
  trend?: TrendExec;
  notes?: string[];
}

export interface MemoryWeights {
  postureWeights: Record<Posture, number>;    // 0..1 normalize
  planWeights:    Record<"A"|"B"|"C", number>;
  defaults: { defaultPlan: "A"|"B"|"C" };
}

export interface RiskNetState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
}

export interface Policy {
  whitelist: string[];
  minTargetPct: number;                        // â‰¥ 4
}

export interface AnalyticsRow {
  expectedMovePct: number;  // kapanmÄ±ÅŸ bar
  R_multiple: number;       // â‰¥1.2 Ã¶nerilir
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface VariantPlan extends BasePlan {
  variant: VariantId;
  exec: BaseExec;
  trend?: TrendExec;
  riskHints?: string[];        // VIVO-03 kartlarÄ±na not
}

export interface VariantInput {
  posture: Posture;
  risk: RiskNetState;
  memory: MemoryWeights;
  policy: Policy;
  analytics: AnalyticsMap;
  basePlans: BasePlan[];       // VIVO-01â€™den
}

export interface VariantOutput {
  asOf: string;
  variants: Record<"A"|"B"|"C", VariantPlan[]>;  // her plan iÃ§in 1â€“3 varyant
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.posture (VIVO-01 Ã§Ä±ktÄ±sÄ±) veya doÄŸrudan VariantInput.

Publish: vivo.variants (VariantOutput) ve audit.log (uygulanan katsayÄ±lar / risk notlarÄ±).

Varyant MantÄ±ÄŸÄ± (deterministik katsayÄ±lar)
Rejim / Kaynak	KatsayÄ± / Etki
Posture = RISK_ON	AGGR: offset âˆ’2 bps, TWAP âˆ’300ms, iceberg +0.00 â†’ daha hÄ±zlÄ±; BAL: baz; CONSV: offset +1 bps, TWAP +150ms, iceberg +0.03
Posture = NEUTRAL	AGGR: offset âˆ’1 bps, TWAP âˆ’150ms; BAL: baz; CONSV: offset +2 bps, TWAP +300ms, iceberg +0.04
Posture = RISK_OFF	YalnÄ±z CONSV: offset +3 bps, TWAP +400ms, iceberg +0.06; gerekiyorsa childType POST_ONLY Ã¶ner
Risk level = AMBER	Her varyanta +100â€“200ms TWAP ekle, iceberg +0.02 boundâ€™la
Sentinel â‰  NORMAL	Sadece CONSV Ã¼ret; not: â€œreduce-only Ã¶nerilirâ€
HafÄ±za planWeight	AGGR aktifliÄŸi: weightA>0.5 ise A iÃ§in AGGR aÃ§Ä±k; dÃ¼ÅŸÃ¼k aÄŸÄ±rlÄ±kta yalnÄ±z BAL/CONSV
Politika	whitelist dÄ±ÅŸÄ± / +%4 altÄ± semboller varyanttan atÄ±lÄ±r (plan yapÄ±sÄ± korunur)

Boundâ€™lar:

limitOffsetBps min 0, max +15;

twapMs min 400ms, max 4000ms;

iceberg min 0.05, max 0.5.

Kod Ä°skeleti
// vivo/planVariantGenerator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  VariantInput, VariantOutput, VariantPlan, BasePlan, VariantId, Policy, AnalyticsMap, StdError
} from "./planVariantGenerator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=0)=> Number(x.toFixed(n));

export class PlanVariantGenerator extends EventEmitter {
  ver="1.0.0"; src="VIVO-05";

  attach(){
    bus.on<VariantInput>("vivo.posture", (env:any)=>{
      // VIVO-01 output â†’ VariantInputâ€™a map edilmiÅŸ payload beklenir
      // EÄŸer doÄŸrudan VIVO-01 formatÄ± geliyorsa kÃ¼Ã§Ã¼k bir adaptÃ¶r yazÄ±p basePlans/analytics/policy ekle.
    });
  }

  run(x: VariantInput): VariantOutput | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const out: VariantOutput = { asOf:new Date().toISOString(), variants:{ A:[], B:[], C:[] } };
      for (const base of x.basePlans){
        const vs = this.buildForPlan(x, base);
        out.variants[base.id] = vs;
      }

      bus.emit<VariantOutput>("vivo.variants", out);
      return out;

    } catch (e:any){
      return this.err("VIVO05_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private buildForPlan(x: VariantInput, base: BasePlan): VariantPlan[] {
    const allowAggressive = x.memory.planWeights[base.id] > 0.5 && x.posture!=="RISK_OFF" && x.risk.sentinel==="NORMAL";
    const arr: VariantPlan[] = [];

    // RISK_OFF ya da sentinel â‰  NORMAL ise yalnÄ±z CONSV
    if (x.posture==="RISK_OFF" || x.risk.sentinel!=="NORMAL"){
      const p = this.mkVariant(base, "CONSV", x);
      p.riskHints = ["Risk-Off/Sentinel: reduce-only Ã¶nerilir", ...(p.riskHints||[])];
      arr.push(p);
      return arr;
    }

    // NEUTRAL / RISK_ON: AGGR (opsiyonel), BAL, CONSV
    if (allowAggressive) arr.push( this.mkVariant(base, "AGGR", x) );
    arr.push( this.mkVariant(base, "BAL", x) );
    arr.push( this.mkVariant(base, "CONSV", x) );

    return arr;
  }

  private mkVariant(base: BasePlan, variant: VariantId, x: VariantInput): VariantPlan {
    // Baz parametreler
    let { limitOffsetBps, twapMs, iceberg, childType } = base.exec;
    const hints:string[] = [];

    // Posture etkisi
    if (x.posture==="RISK_ON"){
      if (variant==="AGGR"){ limitOffsetBps-=2; twapMs-=300; }
      if (variant==="BAL") { /* baz */ }
      if (variant==="CONSV"){ limitOffsetBps+=1; twapMs+=150; iceberg+=0.03; }
    } else if (x.posture==="NEUTRAL"){
      if (variant==="AGGR"){ limitOffsetBps-=1; twapMs-=150; }
      if (variant==="BAL") { /* baz */ }
      if (variant==="CONSV"){ limitOffsetBps+=2; twapMs+=300; iceberg+=0.04; }
    } else { // RISK_OFF (buraya normalde dÃ¼ÅŸmez)
      variant = "CONSV";
      limitOffsetBps+=3; twapMs+=400; iceberg+=0.06; childType = "POST_ONLY";
    }

    // Risk level etkisi (AMBER â†’ temkinli)
    if (x.risk.level==="AMBER"){ twapMs+= (variant==="AGGR"?100:200); iceberg+=0.02; hints.push("AMBER: TWAPâ†‘ icebergâ†‘"); }

    // Boundâ€™lar
    limitOffsetBps = clamp(limitOffsetBps, 0, 15);
    twapMs         = clamp(twapMs, 400, 4000);
    iceberg        = clamp(iceberg, 0.05, 0.5);

    // Politika: whitelist + minTarget %+4 (analyticsâ€™ten filtrele)
    const filteredSyms = base.symbols.filter(o=>{
      const s = Object.keys(o)[0];
      if (!x.policy.whitelist.includes(s)) return false;
      const an = x.analytics[s];
      return an && an.expectedMovePct >= x.policy.minTargetPct && (an.R_multiple ?? 0) >= 1.2;
    });

    const p: VariantPlan = {
      ...base,
      symbols: filteredSyms,
      variant,
      exec: { limitOffsetBps: round(limitOffsetBps), twapMs: Math.round(twapMs), iceberg: round(iceberg, 2), childType },
      trend: base.trend,
      riskHints: hints
    };

    // RISK_OFF/Sentinel uyarÄ±sÄ± (gÃ¼venlik iÃ§in iki kez)
    if (x.posture==="RISK_OFF" || x.risk.sentinel!=="NORMAL"){
      p.riskHints = [...(p.riskHints||[]), "Reduce-only / yeni giriÅŸ yok"];
      if (p.exec.childType==="LIMIT") p.exec.childType = "POST_ONLY";
    }

    return p;
  }

  private validate(x: VariantInput): string | null {
    if (!x || !Array.isArray(x.basePlans) || x.basePlans.length===0) return "basePlans missing";
    if (!x.memory || !x.memory.planWeights) return "memory weights missing";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be â‰¥ 4";
    if (!x.analytics) return "analytics missing";
    return null;
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/planVariantGenerator.test.ts
import { describe,it,expect } from "vitest";
import { PlanVariantGenerator } from "../planVariantGenerator";
import type { VariantInput } from "../planVariantGenerator.types";

const base: VariantInput = {
  posture: "NEUTRAL",
  risk: { level:"AMBER", sentinel:"NORMAL" },
  memory: { postureWeights:{RISK_ON:0.3, NEUTRAL:0.5, RISK_OFF:0.2}, planWeights:{A:0.6, B:0.3, C:0.1}, defaults:{ defaultPlan:"A" } },
  policy: { whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct: 4 },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:3.5, R_multiple:1.1 } },
  basePlans: [
    { id:"A", title:"BTC+ETH", symbols:[{"BTCUSDT":10000},{"ETHUSDT":8000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } }
  ]
};

describe("VIVO-05 planVariantGenerator", ()=>{
  it("generates AGGR/BAL/CONSV for eligible plan", ()=>{
    const gen = new PlanVariantGenerator();
    const out:any = gen.run(base);
    expect(out.variants.A.length).toBeGreaterThanOrEqual(2);
    const names = out.variants.A.map((v:any)=>v.variant);
    expect(names).toContain("BAL");
    expect(names).toContain("CONSV");
  });

  it("filters non-compliant symbols by policy", ()=>{
    const gen = new PlanVariantGenerator();
    const out:any = gen.run(base);
    const aggr:any = out.variants.A.find((v:any)=>v.variant==="AGGR") || out.variants.A[0];
    const syms = aggr.symbols.map((o:any)=>Object.keys(o)[0]);
    expect(syms).not.toContain("OPUSDT"); // +%4 altÄ± / R<1.2
  });

  it("risk-off produces conservative only", ()=>{
    const gen = new PlanVariantGenerator();
    const inp = structuredClone(base);
    inp.posture = "RISK_OFF";
    const out:any = gen.run(inp);
    expect(out.variants.A.length).toBe(1);
    expect(out.variants.A[0].variant).toBe("CONSV");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-01 baz planlarÄ± ve sorularÄ± Ã¼retir â†’ VIVO-03 kart/diolog; operatÃ¶r seÃ§iminden Ã¶nce veya sonra VIVO-05 varyant setini verir (ikisi de mÃ¼mkÃ¼n).

VIVO-05: Plan baÅŸÄ±na AGGR/BAL/CONSV parametreleri Ã¼retir â†’ vivo.variants.

VIVO-03 kartlarÄ±: Varyant Ã¶zetlerini seÃ§enek olarak gÃ¶sterebilir (opsiyonel).

VIVO-02: SeÃ§ilen varyant planÄ±nÄ± child orderâ€™lara Ã§evirir (tick/lot/notional/post-only denetimleri).
_________________________________________________________________________________________________________________
VIVO-06 Â· planFeasibilityChecker.ts

AmaÃ§ (tek cÃ¼mle):
Plan A/B/C (+ varyant) iÃ§in tick/lot/(min_)notional/percent-price/post-only, exposure gates, risk/sentinel, +%4 hedef & whitelist kapÄ±larÄ±nÄ± hÄ±zlÄ±ca deÄŸerlendirip feasible? + score + reasons[] Ã¼retmek.

GerÃ§ek DÃ¼nya KurallarÄ±

KapanmamÄ±ÅŸ bar yok; expectedMove % kapanmÄ±ÅŸ barlardan (VIVO-01/VIVO-05â€™ten) gelir.

Risk/Sentinel: SLOWDOWN/HALT_PARTIAL/CIRCUIT_BREAKER â†’ yeni giriÅŸ yok (reduce-only Ã¶ner).

Binance kurallarÄ± simÃ¼lasyon (kuantize etmeden Ã¶nce): fiyatÄ± tickâ€™e, miktarÄ± stepâ€™e varsayÄ±msal yuvarla ve (MIN_)NOTIONALÄ± kontrol et. Post-only iÃ§in cross etmeme kuralÄ±nÄ± kontrol et.

Policy: whitelist dÄ±ÅŸÄ± veya minTargetPct < +%4 olan semboller fail gerekÃ§esiyle dÃ¼ÅŸer.

HÄ±z: Bu modÃ¼l tek geÃ§iÅŸte karar verir; gerÃ§ek emir Ã¼retimi VIVO-02â€™de.

ArayÃ¼zler (TypeScript)
// vivo/planFeasibilityChecker.types.ts
export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";

export interface ExecParams {
  limitOffsetBps: number;
  twapMs: number;
  iceberg: number;
  childType: ChildType;
}
export interface PlanSymbol {
  symbol: string;
  notionalUsd: number;
  side?: Side;
}
export interface PlanIn {
  id: "A"|"B"|"C";
  title: string;
  symbols: PlanSymbol[];
  exec: ExecParams;
  notes?: string[];
}

export interface Policy {
  whitelist: string[];
  minTargetPct: number; // â‰¥4
}

export interface AnalyticsRow {
  expectedMovePct: number; // â‰¥ minTargetPct olmalÄ±
  R_multiple: number;      // â‰¥ 1.2 Ã¶nerilir
}
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface BookTicker {
  symbol: string;
  bid: number; ask: number; mid: number;
}
export interface ExchangeRule {
  symbol: string;
  tickSize: number;
  stepSize: number;
  minNotional: number;
}

export interface ExposureGate {
  decision: "ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?: number;
  maxPositionQty?: number;
  currentPositionQty?: number;
}

export interface FeasibilityInput {
  plan: PlanIn;
  posture: Posture;
  sentinel: Sentinel;
  policy: Policy;
  analytics: AnalyticsMap;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  exposure: Record<string, ExposureGate>;
}

export interface SymbolCheck {
  symbol: string;
  side: Side;
  intendedNotionalUsd: number;
  feasible: boolean;
  reasons: string[];
  simulated?: { price:number; qty:number; notional:number; ruleHits:string[] };
}

export interface FeasibilityResult {
  planId: "A"|"B"|"C";
  feasible: boolean;
  score: number;           // 0..100
  reasons: string[];       // plan genel nedenleri
  symbols: SymbolCheck[];  // sembol bazlÄ± detay
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Skor & Kurallar (Ã¶zet)

BaÅŸlangÄ±Ã§ 100 puan; her ihlal ceza:

whitelist dÄ±ÅŸÄ± / +%4 altÄ± / R<1.2: âˆ’25

DENY/REDUCE_ONLY (yeni giriÅŸ): âˆ’35

(MIN_)NOTIONAL yetersiz: âˆ’20

post-only cross riski: âˆ’10

tick/step uyumsuz (kuantize sonrasÄ± qty 0): âˆ’20

sentinelâ‰ NORMAL (yeni giriÅŸ): plan bazÄ±nda âˆ’40 ve feasible=false

score<60 â†’ feasible=false. Sembol bazlÄ± feasible=false olsa bile plan birkaÃ§ sembolle geÃ§ebilir.

Kod Ä°skeleti
// vivo/planFeasibilityChecker.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  FeasibilityInput, FeasibilityResult, SymbolCheck, PlanIn, ExecParams, StdError, BookTicker, ExchangeRule
} from "./planFeasibilityChecker.types";

const roundTo = (x:number, step:number)=> Math.round(x/step)*step;
const floorTo = (x:number, step:number)=> Math.floor(x/step)*step;

export class PlanFeasibilityChecker extends EventEmitter {
  ver="1.0.0"; src="VIVO-06";

  run(x: FeasibilityInput): FeasibilityResult | { error: StdError } {
    try {
      const val = this.validate(x); if (val) return this.err("VALIDATION_ERROR", val);
      const reasons: string[] = [];
      let score = 100;

      // Sentinel: yeni giriÅŸlere izin yoksa planÄ± reddet (reduce-only bilgi amaÃ§lÄ±)
      const hardHalt = (x.sentinel!=="NORMAL");
      if (hardHalt) { reasons.push(`sentinel=${x.sentinel}: new opens not allowed (reduce-only)`); score -= 40; }

      const symChecks: SymbolCheck[] = [];
      for (const ps of x.plan.symbols) {
        symChecks.push( this.checkSymbol(x, ps.symbol.toUpperCase(), ps.notionalUsd, ps.side ?? "BUY", x.plan.exec) );
      }

      // Plan dÃ¼zeyli deÄŸerlendirme
      const failCount = symChecks.filter(s=>!s.feasible).length;
      if (failCount === symChecks.length) {
        reasons.push("all symbols infeasible");
        score -= 30;
      } else if (failCount>0) {
        reasons.push(`${failCount} symbols infeasible`);
        score -= 10;
      }

      if (hardHalt) {
        return { planId: x.plan.id, feasible:false, score: Math.max(0, score), reasons, symbols: symChecks };
      }

      const feasible = score >= 60 && symChecks.some(s=>s.feasible);
      return { planId: x.plan.id, feasible, score: Math.max(0, score), reasons, symbols: symChecks };

    } catch (e:any){
      return this.err("FEASIBILITY_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private checkSymbol(x: FeasibilityInput, sym:string, intendedNotional:number, side:"BUY"|"SELL", exec: ExecParams): SymbolCheck {
    const reasons: string[] = [];
    let feasible = true;
    const ruleHits: string[] = [];

    // Policy: whitelist / +%4
    if (!x.policy.whitelist.includes(sym)) { feasible=false; reasons.push("whitelist"); }
    const an = x.analytics[sym];
    if (!an || an.expectedMovePct < x.policy.minTargetPct) { feasible=false; reasons.push("minTarget"); }
    if (!an || (an.R_multiple ?? 0) < 1.2) { reasons.push("lowR"); } // uyarÄ±; planÄ± tek baÅŸÄ±na Ã¶ldÃ¼rmez

    // Exposure gates
    const gate = x.exposure[sym];
    if (!gate || gate.decision==="DENY") { feasible=false; reasons.push("exposure=DENY"); }
    if (gate?.decision==="REDUCE_ONLY") { feasible=false; reasons.push("exposure=REDUCE_ONLY"); }
    if (gate?.decision==="TRIM" && gate.allowedNotionalUsd!==undefined) {
      intendedNotional = Math.min(intendedNotional, gate.allowedNotionalUsd);
      ruleHits.push("trim");
      if (intendedNotional<=0) { feasible=false; reasons.push("trimâ†’zero"); }
    }

    const r = x.rules[sym];  const t = x.tickers[sym];
    if (!r || !t || !Number.isFinite(t.bid) || !Number.isFinite(t.ask)) {
      feasible=false; reasons.push("missing rules/ticker");
      return { symbol:sym, side, intendedNotionalUsd:intendedNotional, feasible, reasons };
    }

    // Fiyat simÃ¼lasyonu (limit/IOC/post-only ofsetleri gÃ¶z Ã¶nÃ¼nde; market iÃ§in ask/bid)
    const price = this.simPrice(side, exec, t, r);
    // LOT_SIZE kuantizasyon (simÃ¼lasyon)
    const qty0 = intendedNotional / price;
    const qty  = floorTo(qty0, r.stepSize);
    const notional = price * qty;

    if (qty<=0) { feasible=false; reasons.push("stepâ†’qty=0"); }
    if (notional < r.minNotional) { feasible=false; reasons.push("minNotional"); }

    // Post-only cross kontrol
    if (exec.childType==="POST_ONLY") {
      const crosses = (side==="BUY") ? (price >= t.bid) : (price <= t.ask);
      if (crosses) { feasible=false; reasons.push("post-only-cross"); }
    }

    return {
      symbol:sym, side, intendedNotionalUsd:intendedNotional,
      feasible, reasons,
      simulated:{ price, qty, notional, ruleHits }
    };
  }

  private simPrice(side:"BUY"|"SELL", exec: ExecParams, t: BookTicker, r: ExchangeRule){
    const ofs = (exec.limitOffsetBps||0)/10_000;
    let px = t.mid;
    if (exec.childType==="MARKET") px = (side==="BUY") ? t.ask : t.bid;
    else if (exec.childType==="IOC") px = (side==="BUY") ? t.ask*(1+ofs) : t.bid*(1-ofs);
    else if (exec.childType==="POST_ONLY") px = (side==="BUY") ? t.bid*(1-Math.max(ofs,0.0001)) : t.ask*(1+Math.max(ofs,0.0001));
    else /* LIMIT */ px = (side==="BUY") ? t.ask*(1+ofs) : t.bid*(1-ofs);

    // tick yuvarlama
    px = roundTo(px, r.tickSize);
    // post-only gÃ¼venliÄŸi (cross olmasÄ±n)
    if (exec.childType==="POST_ONLY"){
      if (side==="BUY" && px >= t.bid) px = roundTo(t.bid - r.tickSize, r.tickSize);
      if (side==="SELL" && px <= t.ask) px = roundTo(t.ask + r.tickSize, r.tickSize);
    }
    return px;
  }

  private validate(x: FeasibilityInput): string | null {
    if (!x.plan || !x.plan.symbols?.length) return "empty plan";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be â‰¥4";
    if (!x.rules || !x.tickers) return "missing rules/tickers";
    if (!x.analytics) return "missing analytics";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/planFeasibilityChecker.test.ts
import { describe,it,expect } from "vitest";
import { PlanFeasibilityChecker } from "../planFeasibilityChecker";
import type { FeasibilityInput } from "../planFeasibilityChecker.types";

const rules = {
  BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10 },
  ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10 }
};
const ticks = {
  BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005 },
  ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5 }
};
const base: FeasibilityInput = {
  plan: { id:"A", title:"BTC+ETH", symbols:[{symbol:"BTCUSDT", notionalUsd:10_000},{symbol:"ETHUSDT", notionalUsd:5_000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
  posture:"NEUTRAL", sentinel:"NORMAL",
  policy:{ whitelist:["BTCUSDT","ETHUSDT"], minTargetPct:4 },
  analytics:{ BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 } },
  rules, tickers: ticks,
  exposure:{ BTCUSDT:{ decision:"ALLOW", currentPositionQty:0 }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd:4000, currentPositionQty:0 } }
};

describe("VIVO-06 planFeasibilityChecker", ()=>{
  it("passes feasible plan", ()=>{
    const f = new PlanFeasibilityChecker();
    const res:any = f.run(base);
    expect(res.feasible).toBe(true);
    expect(res.score).toBeGreaterThan(60);
  });

  it("rejects with sentinel halt", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.sentinel = "HALT_PARTIAL";
    const res:any = f.run(inp);
    expect(res.feasible).toBe(false);
    expect(res.reasons.join(" ")).toMatch(/reduce-only/);
  });

  it("flags post-only cross", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.plan.exec.childType = "POST_ONLY";
    // BUY iÃ§in price â‰¥ bid olursa cross sayacaÄŸÄ±z; checker bunu yakalamalÄ±
    const res:any = f.run(inp);
    const btc = res.symbols.find((s:any)=>s.symbol==="BTCUSDT");
    expect(btc.reasons.join(",")).not.toContain("post-only-cross"); // Ã§Ã¼nkÃ¼ module fiyatÄ± bid-tick'e Ã§eker
  });

  it("fails non-whitelist", ()=>{
    const f = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.policy.whitelist = ["BTCUSDT"]; // ETH yok
    const res:any = f.run(inp);
    const eth = res.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.feasible).toBe(false);
    expect(eth.reasons).toContain("whitelist");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-03 operatÃ¶r seÃ§imi â†’ VIVO-06 ile hÄ±zlÄ± feasibility check.

VIVO-06 sonucu UIâ€™de kÄ±sa gerekÃ§e kartÄ± olarak gÃ¶sterilebilir: score, reasons[], sembol bazlÄ± notlar.

VIVO-02 yalnÄ±z feasible=true planÄ± Ã§ocuk emirlere Ã§evirir; feasible=false ise operatorDialog fallback/yeniden seÃ§im akÄ±ÅŸÄ± tetiklenir.

TÃ¼m gerekÃ§eler audit.logâ€™a dÃ¼ÅŸer â†’ Denetim AsistanÄ±/GB-36 tarafÄ±ndan raporlanÄ±r.
_________________________________________________________________________________________________________________
VIVO-06 Â· planFeasibilityChecker.ts

AmaÃ§ (tek cÃ¼mle):
Plan(lar)Ä±n icra edilebilirliÄŸini hÄ±zlÄ± ve deterministik ÅŸekilde skorlarken, baÅŸarÄ±sÄ±zlÄ±klara gerekÃ§e ve otomatik dÃ¼zeltme Ã¶nerileri Ã¼retmek (Ã¶rn. notional trim, POST_ONLY, TWAPâ†‘, icebergâ†‘).

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

Binance filtreleri: PRICE_FILTER (tick), LOT_SIZE (step), (MIN_)NOTIONAL, PERCENT_PRICE(_BY_SIDE), MAX_POSITION, MARKET_LOT_SIZE (varsa).

Risk/Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER â†’ yeni aÃ§Ä±lÄ±ÅŸlar uygunsuz (sadece reduce-only Ã¶ner).

Politika kapÄ±larÄ±: whitelist ve minTargetPct â‰¥ +%4 (savunmacÄ± tekrar doÄŸrula).

Bakiye kontrolÃ¼ (opsiyonel): Quote bakiyesi yetersizse quick-fix â†’ notionalâ†“ veya planC.

KapanmamÄ±ÅŸ bar yok: expectedMove/ATR kapanmÄ±ÅŸ barlardan gelmiÅŸ olmalÄ± (VIVO-01/GB).

HÄ±z: Sadece Ã¶n kontrol yapar; kesin kuantizasyon VIVO-02â€™dedir.

ArayÃ¼zler (TypeScript)
// vivo/planFeasibilityChecker.types.ts
export type Level = "GREEN"|"AMBER"|"RED";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Side = "BUY"|"SELL";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
export type VariantId = "AGGR"|"BAL"|"CONSV";

export interface BaseExec {
  limitOffsetBps:number; twapMs:number; iceberg:number; childType:ChildType;
}

export interface VariantPlan {
  id:"A"|"B"|"C";
  title:string;
  variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: BaseExec;
  notes?: string[];
}

export interface AnalyticsRow { expectedMovePct:number; R_multiple:number; }
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  percent?: { up:number; down:number; refMins?:number };
  maxPositionQty?: number;
  status?: "TRADING"|"HALT"|"BREAK";
  permissions?: string[]; // ["SPOT", ...]
}

export interface BookTicker {
  symbol:string; bid:number; ask:number; mid:number; asOf:string; refPrice?:number;
}

export interface ExposureGate {
  decision:"ALLOW"|"TRIM"|"REDUCE_ONLY"|"DENY";
  allowedNotionalUsd?:number;
  currentPositionQty?:number;
}

export interface Balances {
  // hÄ±zlÄ± kontrol iÃ§in (opsiyonel) toplam kullanÄ±labilir quote USD eÅŸleniÄŸi
  freeQuoteUsd?: number;
}

export interface Policy {
  whitelist:string[];
  minTargetPct:number; // â‰¥4
}

export interface RiskState {
  level:Level; sentinel:Sentinel; posture:Posture;
}

export interface FeasInput {
  plans: VariantPlan[];                  // VIVO-01 veya VIVO-05â€™ten
  analytics: AnalyticsMap;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  exposure: Record<string, ExposureGate>;
  balances?: Balances;
  policy: Policy;
  risk: RiskState;
}

export interface ItemFinding {
  type:
    | "WHITELIST" | "TARGET_PCT" | "SYMBOL_STATUS" | "PERMISSIONS"
    | "DENY" | "REDUCE_ONLY" | "TRIM"
    | "MIN_NOTIONAL" | "PERCENT_PRICE" | "MAX_POSITION" | "BALANCE"
    | "SENTINEL"
    | "OK";
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string; // Ã¶neri metni
}

export interface SymbolFeas {
  symbol:string;
  requestedNotionalUsd:number;
  estimatedPrice:number;
  estimatedQty:number;
  score:number; // 0..100
  findings: ItemFinding[];
  adjustedNotionalUsd?: number; // TRIM sonrasÄ±
}

export interface PlanFeas {
  planId:"A"|"B"|"C";
  variant?: VariantId;
  score:number; // 0..100 (sembol skorlarÄ±nÄ±n weighted avgâ€™i)
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf:string;
  overallScore:number;
  plans: PlanFeas[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.variants (VIVO-05) veya vivo.posture (VIVO-01 baz plan).

Publish: vivo.feasibility (FeasOutput), audit.log (Ã¶zet neden listesi + skorlar).

Skor & MantÄ±k (Ã¶zet)

BaÅŸlangÄ±Ã§ 100; her sorun âˆ’penalty.

ERROR: âˆ’40â€¦âˆ’100 (Ã¶rn. DENY, SENTINEL, SYMBOL_STATUSâ‰ TRADING).

WARN: âˆ’10â€¦âˆ’30 (Ã¶rn. TRIM, MIN_NOTIONAL yakÄ±n, PERCENT_PRICE bandÄ±na dayalÄ±).

INFO: âˆ’0â€¦âˆ’5 (Ã¶rn. permissions eksikliÄŸi uyarÄ±sÄ±).

Plan skoru: sembol skor aÄŸÄ±rlÄ±klÄ± ortalama (notional aÄŸÄ±rlÄ±ÄŸÄ±).

overallScore: plan skorlarÄ±nÄ±n ortalamasÄ±.

Kod Ä°skeleti
// vivo/planFeasibilityChecker.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  FeasInput, FeasOutput, PlanFeas, SymbolFeas, ItemFinding, VariantPlan,
  ExchangeRule, BookTicker, StdError
} from "./planFeasibilityChecker.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class PlanFeasibilityChecker extends EventEmitter {
  ver="1.0.0"; src="VIVO-06";

  attach(){
    bus.on<FeasInput>("vivo.variants", (env)=> this.safeRun(env));
  }

  safeRun(x: FeasInput): void {
    const res = this.run(x);
    if ("error" in (res as any)) {
      const e:any = res as any;
      logger.error(e, "VIVO-06 failed");
    } else {
      bus.emit<FeasOutput>("vivo.feasibility", res as FeasOutput);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src,
        payload:{ msg:"feas computed", overall:(res as FeasOutput).overallScore }});
    }
  }

  run(x: FeasInput): FeasOutput | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const plans: PlanFeas[] = x.plans.map(p=> this.checkPlan(x, p));
      const overall = Math.round( plans.reduce((a,b)=>a+b.score,0) / Math.max(1, plans.length) );

      const out: FeasOutput = { asOf: new Date().toISOString(), overallScore: overall, plans };
      return out;

    } catch (e:any){
      return this.err("FEAS_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private checkPlan(x: FeasInput, plan: VariantPlan): PlanFeas {
    const symFeas: SymbolFeas[] = [];
    for (const o of plan.symbols){
      const s = Object.keys(o)[0];
      const notional = Object.values(o)[0] as number;
      symFeas.push( this.checkSymbol(x, s, notional, plan) );
    }

    // Plan skor: notional aÄŸÄ±rlÄ±klÄ± ortalama
    const totalNotional = symFeas.reduce((a,b)=>a+b.requestedNotionalUsd, 0) || 1;
    let score = 0;
    for (const f of symFeas) score += f.score * (f.requestedNotionalUsd/totalNotional);
    score = Math.round(score);

    // Ã–zet bulgular
    const summary: ItemFinding[] = [];
    if (x.risk.sentinel!=="NORMAL") {
      summary.push({ type:"SENTINEL", severity:"ERROR", message:`Sentinel=${x.risk.sentinel}; yeni aÃ§Ä±lÄ±ÅŸlar Ã¶nerilmez`, quickFix:"PlanC / reduce-only" });
    }
    if (score<60) summary.push({ type:"BALANCE", severity:"WARN", message:"Plan skoru dÃ¼ÅŸÃ¼k; parametreleri korumacÄ± yap", quickFix:"TWAP+200ms, iceberg+0.02, POST_ONLY" });

    const recommend = score>=80 ? "OK" : score>=60 ? "ADJUST" : "REJECT";

    return { planId: plan.id, variant: plan.variant, score, symbols: symFeas, summaryFindings: summary, recommend };
  }

  private checkSymbol(x: FeasInput, symbol: string, notionalUsd: number, plan: VariantPlan): SymbolFeas {
    const findings: ItemFinding[] = [];
    let score = 100;

    // whitelist / target
    if (!x.policy.whitelist.includes(symbol)){
      findings.push({ type:"WHITELIST", severity:"ERROR", message:`${symbol} whitelist dÄ±ÅŸÄ±` });
      score -= 100;
    }
    const an = x.analytics[symbol];
    if (!an || an.expectedMovePct < x.policy.minTargetPct || (an.R_multiple ?? 0) < 1.2){
      findings.push({ type:"TARGET_PCT", severity:"ERROR", message:`${symbol} +%${x.policy.minTargetPct} hedefi/R threshold karÅŸÄ±lanmÄ±yor` });
      score -= 40;
    }

    // risk/sentinel
    if (x.risk.sentinel!=="NORMAL"){
      findings.push({ type:"SENTINEL", severity:"ERROR", message:`Sentinel=${x.risk.sentinel}`, quickFix:"Yeni aÃ§Ä±lÄ±ÅŸ yok; reduce-only" });
      score -= 40;
    }

    const rule: ExchangeRule | undefined = x.rules[symbol];
    const tk: BookTicker | undefined = x.tickers[symbol];
    if (!rule || !tk) {
      findings.push({ type:"SYMBOL_STATUS", severity:"ERROR", message:"rule/ticker eksik" });
      return this.buildSym(symbol, notionalUsd, tk?.mid ?? 0, 0, score, findings);
    }

    if (rule.status && rule.status!=="TRADING"){
      findings.push({ type:"SYMBOL_STATUS", severity:"ERROR", message:`status=${rule.status}` });
      score -= 100;
    }
    if (rule.permissions && !rule.permissions.includes("SPOT")){
      findings.push({ type:"PERMISSIONS", severity:"WARN", message:`permissions=${rule.permissions?.join(",")}` });
      score -= 5;
    }

    // exposure
    const gate = x.exposure[symbol];
    if (!gate || gate.decision==="DENY"){
      findings.push({ type:"DENY", severity:"ERROR", message:"EXPOSURE=DENY" });
      score -= 100;
    } else if (gate.decision==="REDUCE_ONLY"){
      findings.push({ type:"REDUCE_ONLY", severity:"ERROR", message:"EXPOSURE=REDUCE_ONLY", quickFix:"Yeni aÃ§Ä±lÄ±ÅŸ yerine kapama/trim" });
      score -= 50;
    } else if (gate.decision==="TRIM" && gate.allowedNotionalUsd!==undefined && notionalUsd>gate.allowedNotionalUsd){
      findings.push({ type:"TRIM", severity:"WARN", message:`notional>${gate.allowedNotionalUsd}`, quickFix:`${gate.allowedNotionalUsd} USDâ€™ye dÃ¼ÅŸÃ¼r` });
      score -= 15;
      notionalUsd = gate.allowedNotionalUsd; // deÄŸerlendirmeyi trimlenmiÅŸ notional ile sÃ¼rdÃ¼r
    }

    // fiyat/qty kaba tahmin (VIVO-02 kesinleÅŸtirir)
    const side: Side = "BUY";
    let px = this.targetPrice(side, plan.exec.childType, plan.exec.limitOffsetBps, tk, rule);
    const qty = Math.floor((notionalUsd / px) / rule.stepSize) * rule.stepSize;
    const notion = px * qty;

    // minNotional
    if (notion < rule.minNotional){
      findings.push({ type:"MIN_NOTIONAL", severity:"ERROR", message:`$${notion.toFixed(2)} < minNotional $${rule.minNotional}`, quickFix:`notionalâ†‘ veya sembol atla` });
      score -= 30;
    }

    // percent-price bandÄ± (uyarÄ±)
    if (rule.percent){
      const ref = tk.refPrice ?? tk.mid;
      const lo = ref * rule.percent.down;
      const hi = ref * rule.percent.up;
      if (px < lo || px > hi){
        findings.push({ type:"PERCENT_PRICE", severity:"WARN", message:"Fiyat percent-price bandÄ± dÄ±ÅŸÄ±nda", quickFix:"offset bps ayarla / POST_ONLY" });
        score -= 10;
      }
    }

    // max position (opsiyonel)
    if (rule.maxPositionQty!==undefined && (gate?.currentPositionQty ?? 0) + qty > rule.maxPositionQty){
      findings.push({ type:"MAX_POSITION", severity:"ERROR", message:"MAX_POSITION aÅŸÄ±mÄ±", quickFix:"qtyâ†“ / reduce-only" });
      score -= 40;
    }

    // bakiye (opsiyonel)
    if (x.balances?.freeQuoteUsd!==undefined && notionalUsd > x.balances.freeQuoteUsd){
      findings.push({ type:"BALANCE", severity:"WARN", message:"free quote yetersiz", quickFix:"notionalâ†“ / PlanC spot/nakit" });
      score -= 20;
    }

    // POST_ONLY Ã¶nerisi (Ã§apraz risk)
    if (plan.exec.childType==="POST_ONLY"){
      // gÃ¼venli tarafta kal; bilgi amaÃ§lÄ± not
      findings.push({ type:"OK", severity:"INFO", message:"POST_ONLY: cross risk dÃ¼ÅŸÃ¼k" });
    }

    score = clamp(score, 0, 100);
    return this.buildSym(symbol, notionalUsd, px, qty, score, findings);
  }

  private targetPrice(side:"BUY"|"SELL", type:ChildType, offsetBps:number, t:BookTicker, r:ExchangeRule){
    const ofs = (offsetBps||0)/10_000;
    let base = side==="BUY" ? t.ask*(1+ofs) : t.bid*(1-ofs);
    if (type==="POST_ONLY") base = side==="BUY" ? t.bid*(1-Math.max(ofs, 0.0001)) : t.ask*(1+Math.max(ofs, 0.0001));
    // tickâ€™e yuvarla
    const price = Math.round(base / r.tickSize) * r.tickSize;
    return price;
  }

  private buildSym(symbol:string, req:number, px:number, qty:number, score:number, findings:ItemFinding[]): SymbolFeas {
    return {
      symbol, requestedNotionalUsd:req,
      estimatedPrice: px, estimatedQty: qty,
      score, findings
    };
  }

  private validate(x: FeasInput): string | null {
    if (!x || !Array.isArray(x.plans) || x.plans.length===0) return "plans missing";
    if (!x.policy || (x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be â‰¥ 4";
    if (!x.rules || !x.tickers || !x.exposure) return "rules/tickers/exposure missing";
    if (!x.risk) return "risk missing";
    return null;
  }

  private err(code:string, message:string, details?:any){ 
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/planFeasibilityChecker.test.ts
import { describe,it,expect } from "vitest";
import { PlanFeasibilityChecker } from "../planFeasibilityChecker";
import type { FeasInput } from "../planFeasibilityChecker.types";

const rules = {
  BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, percent:{up:1.2,down:0.8}, status:"TRADING", permissions:["SPOT"] },
  ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10, status:"TRADING", permissions:["SPOT"] }
};
const tickers = {
  BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
  ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() }
};
const base: FeasInput = {
  plans:[
    { id:"A", title:"BTC+ETH", symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } },
    { id:"C", title:"Nakit+Spot", symbols:[], exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" } }
  ],
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 } },
  rules, tickers,
  exposure: { BTCUSDT:{ decision:"ALLOW", currentPositionQty:0 }, ETHUSDT:{ decision:"TRIM", allowedNotionalUsd:3000, currentPositionQty:0 } },
  balances:{ freeQuoteUsd: 9000 },
  policy:{ whitelist:["BTCUSDT","ETHUSDT"], minTargetPct:4 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" }
};

describe("VIVO-06 planFeasibilityChecker", ()=>{
  it("scores plans and gives quick-fixes", ()=>{
    const fc = new PlanFeasibilityChecker();
    const out:any = fc.run(base);
    expect(out.overallScore).toBeGreaterThan(0);
    const pA = out.plans.find((p:any)=>p.planId==="A");
    expect(pA.symbols.length).toBe(2);
    expect(pA.symbols.find((s:any)=>s.symbol==="ETHUSDT").findings.some((f:any)=>f.type==="TRIM")).toBe(true);
  });

  it("rejects non-whitelist or sentinel halt", ()=>{
    const fc = new PlanFeasibilityChecker();
    const inp = structuredClone(base);
    inp.policy.whitelist = ["BTCUSDT"]; // ETH dÄ±ÅŸÄ±
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = fc.run(inp);
    const pA = out.plans.find((p:any)=>p.planId==="A");
    expect(pA.summaryFindings.some((f:any)=>f.type==="SENTINEL")).toBe(true);
    const eth = pA.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.findings.some((f:any)=>f.type==="WHITELIST")).toBe(true);
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-05 â†’ vivo.variants: Varyant planlarÄ± yayÄ±nlar.

VIVO-06: Feasibility skorlar/ neden listeleri/ quick-fix Ã¼retir â†’ vivo.feasibility.

VIVO-03: Kartlarda score ve kritik uyarÄ±larÄ± gÃ¶sterir; operatÃ¶r ADJUST/REJECT kararÄ±na yardÄ±mcÄ± olur.

VIVO-02: TRIM ve POST_ONLY gibi quick-fix ipuÃ§larÄ±nÄ± doÄŸrudan uygular (Ã¶r. allowedNotionalâ€™a kesme).
_________________________________________________________________________________________________________________
VIVO-07 Â· explainabilityReporter.ts

AmaÃ§ (tek cÃ¼mle):
SeÃ§ilen plan/varyantÄ±n neden seÃ§ildiÄŸini; hangi risk, hafÄ±za, politika ve uygulanabilirlik kriterlerini geÃ§tiÄŸini, hangi alternatiflerin neden elendiÄŸini ve bir sonraki adÄ±mlarÄ± operatÃ¶re (Telegram/CLI) ve log sistemine aÃ§Ä±klamak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; tÃ¼m metrikler kapanmÄ±ÅŸ bar/iÅŸlem sonuÃ§larÄ±ndan gelir (VIVO-01/GB & VIVO-04/22/36).

Idempotency: AynÄ± corrId iÃ§in birden fazla kart Ã¼retme.

Redline/CB: Sentinel NORMAL deÄŸilse, kart â€œreduce-onlyâ€ tavsiyesiyle iÅŸaretlenir.

Politika/gÃ¼venlik: Whitelist, minTargetPct â‰¥ +%4 ihlalleri karta net yazÄ±lÄ±r.

TCA farklarÄ±: (varsa) modeled vs realized slipaj/mark-out kÄ±sa Ã¶zeti.

ArayÃ¼zler (TypeScript)
// vivo/explainabilityReporter.types.ts
import type { ISODate } from "../core/types";

// Ã–zet tipler (diÄŸer modÃ¼llerden sadeleÅŸtirilmiÅŸ)
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type PlanId = "A"|"B"|"C";

export interface MemorySnapshot {
  asOf: ISODate;
  postureWeights: Record<Posture, number>;
  planWeights: Record<PlanId, number>;
  defaults: { defaultPlan: PlanId };
}

export interface VariantPlan {
  id: PlanId;
  title: string;
  variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
  riskHints?: string[];
  notes?: string[];
}

export interface VariantOutput {
  asOf: ISODate;
  variants: Record<PlanId, VariantPlan[]>;
}

export interface ItemFinding {
  type: string;     // "WHITELIST"|"TARGET_PCT"|... (VIVO-06)
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}
export interface SymbolFeas {
  symbol: string;
  requestedNotionalUsd: number;
  estimatedPrice: number;
  estimatedQty: number;
  score: number;             // 0..100
  findings: ItemFinding[];
}
export interface PlanFeas {
  planId: PlanId;
  variant?: VariantId;
  score: number;             // plan feasibility score 0..100
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}
export interface FeasOutput {
  asOf: ISODate;
  overallScore: number;
  plans: PlanFeas[];
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;
  confirmations: Record<number,string>;  // 0: plan seÃ§imi, 1: +%4 onayÄ± vb.
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface ActionBundle {
  asOf: ISODate;
  planId: PlanId;
  children: Array<{
    symbol: string; side: "BUY"|"SELL"; type: string;
    price?: number; qty: number; reduceOnly?: boolean; postOnly?: boolean;
    meta?: { twapMs?: number; slice?: number; slices?: number; iceberg?: number; corrId?: string };
  }>;
  comments?: string[];
}

// Rapor biÃ§imi
export interface ExplainNode {
  label: string;
  value?: string|number;
  children?: ExplainNode[];
  severity?: "INFO"|"WARN"|"ERROR";
}

export interface ExplainCard {
  corrId: string;
  asOf: ISODate;
  header: {
    posture: Posture;
    sentinel: Sentinel;
    decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
    selected: { planId: PlanId; variant?: VariantId; title?: string };
  };
  weights: {
    posture: Record<Posture, number>;
    plans: Record<PlanId, number>;
    defaultPlan: PlanId;
  };
  feasibility: {
    selectedScore: number;
    altScores: Array<{ planId: PlanId; variant?: VariantId; score: number }>;
    topFindings: ItemFinding[];
  };
  policyCompliance: ExplainNode[];   // whitelist / +%4 / exposure vs.
  execSummary?: {
    childCount: number;
    reduceOnlyRatio: number;
    postOnlyCount: number;
    notionalUsd: number;
  };
  whyTree: ExplainNode[];            // â€œneden seÃ§ildi?â€ aÄŸacÄ±
  nextSteps: string[];               // quick-fix / operatÃ¶r aksiyonlarÄ±
}

export interface ReporterInput {
  corrId: string;
  posture: Posture;
  sentinel: Sentinel;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Kod Ä°skeleti
// vivo/explainabilityReporter.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  MemorySnapshot, VariantOutput, FeasOutput, OperatorResult, ActionBundle,
  ExplainCard, ExplainNode, ReporterInput, StdError, PlanId, VariantPlan, PlanFeas
} from "./explainabilityReporter.types";

export class ExplainabilityReporter extends EventEmitter {
  ver="1.0.0"; src="VIVO-07";
  private seen = new Set<string>();
  private memory: MemorySnapshot | null = null;
  private variants: VariantOutput | null = null;
  private feas: FeasOutput | null = null;
  private lastSelection: OperatorResult | null = null;
  private lastActions: ActionBundle | null = null;

  attach(){
    bus.on<MemorySnapshot>("vivo.memory",  (m)=>{ this.memory = m; });
    bus.on<VariantOutput>("vivo.variants", (v)=>{ this.variants = v; });
    bus.on<FeasOutput>("vivo.feasibility",(f)=>{ this.feas = f; });
    bus.on<OperatorResult>("vivo.operator.result",(r)=>{ this.lastSelection = r; });
    bus.on<ActionBundle>("ops.actions",(a)=>{ this.lastActions = a; });
    // Ä°steÄŸe baÄŸlÄ± tetikleyici: seÃ§im ya da feasibility geldiÄŸinde kart Ã¼ret
    bus.on<ReporterInput>("vivo.explain.request", (req)=> this.safeBuild(req));
  }

  safeBuild(req: ReporterInput){
    const res = this.build(req);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-07 build failed");
    } else {
      const card = res as ExplainCard;
      bus.emit<ExplainCard>("vivo.explain.card", card);
      bus.emit("audit.log", { asOf:card.asOf, ver:this.ver, src:this.src, payload:{ corrId:card.corrId, selected:card.header.selected, score:card.feasibility.selectedScore }});
    }
  }

  build(req: ReporterInput): ExplainCard | { error: StdError } {
    try {
      if (!req?.corrId) return this.err("VALIDATION_ERROR","corrId missing");
      if (this.seen.has(req.corrId)) return this.err("IDEMPOTENT","corrId already explained",{corrId:req.corrId});
      if (!this.memory || !this.variants || !this.feas || !this.lastSelection) {
        return this.err("STATE_MISSING","memory/variants/feas/selection missing");
      }

      const selectedPlanId = this.lastSelection.selectedPlanId;
      const selVar = this.pickSelectedVariant(selectedPlanId);
      const feasSel = this.pickFeas(selectedPlanId, selVar?.variant);

      const card: ExplainCard = {
        corrId: req.corrId,
        asOf: new Date().toISOString(),
        header: {
          posture: req.posture,
          sentinel: req.sentinel,
          decidedBy: this.lastSelection.decidedBy,
          selected: { planId: selectedPlanId, variant: selVar?.variant, title: selVar?.title }
        },
        weights: {
          posture: this.memory.postureWeights,
          plans: this.memory.planWeights,
          defaultPlan: this.memory.defaults.defaultPlan
        },
        feasibility: {
          selectedScore: feasSel?.score ?? 0,
          altScores: this.altScores(feasSel),
          topFindings: this.topFindings(feasSel)
        },
        policyCompliance: this.policyNodes(selVar, feasSel),
        execSummary: this.execSummary(this.lastActions, selectedPlanId),
        whyTree: this.buildWhyTree(selVar, feasSel),
        nextSteps: this.suggestNext(selVar, feasSel, req.sentinel)
      };

      this.seen.add(req.corrId);
      return card;

    } catch (e:any){
      return this.err("EXPLAIN_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- yardÄ±mcÄ±lar ---
  private pickSelectedVariant(planId: PlanId): VariantPlan | null {
    const arr = this.variants?.variants?.[planId] ?? [];
    // OperatÃ¶r kartÄ±nda varyant seÃ§imi ayrÄ±ysa burada default: en yÃ¼ksek feasibility skoru
    const bestFeas = this.feas?.plans
      ?.filter(p=>p.planId===planId)
      .sort((a,b)=>b.score-a.score)[0];
    if (bestFeas) {
      const vp = arr.find(v=>v.variant===bestFeas.variant) || arr[0] || null;
      return vp || null;
    }
    return arr[0] || null;
  }

  private pickFeas(planId: PlanId, variant?: string | undefined | null): PlanFeas | null {
    const arr = this.feas?.plans?.filter(p=>p.planId===planId) ?? [];
    if (!arr.length) return null;
    if (variant) return arr.find(p=>p.variant===variant) || arr[0];
    return arr[0];
  }

  private altScores(sel: PlanFeas | null){
    if (!this.feas?.plans) return [];
    return this.feas.plans
      .filter(p=> !sel || p!==sel)
      .map(p=>({ planId:p.planId, variant:p.variant, score:p.score }))
      .sort((a,b)=>b.score-a.score)
      .slice(0,4);
  }

  private topFindings(sel: PlanFeas | null){
    if (!sel) return [];
    const combine = [...(sel.summaryFindings||[])];
    for (const s of sel.symbols) {
      const crit = s.findings.filter(f=>f.severity!=="INFO");
      combine.push(...crit);
    }
    // Ã–nce ERROR, sonra WARN; ilk 6
    return combine.sort((a,b)=>{
      const rank = (x:ItemFinding)=> x.severity==="ERROR"?2 : x.severity==="WARN"?1 : 0;
      return rank(b)-rank(a);
    }).slice(0,6);
  }

  private policyNodes(vp: VariantPlan | null, sel: PlanFeas | null): ExplainNode[] {
    const out: ExplainNode[] = [];
    if (!vp || !sel) return out;

    const symSet = new Set(vp.symbols.map(o=>Object.keys(o)[0]));
    // Whitelist/+%4 filtreleri VIVO-05 & VIVO-06â€™da uygulanmÄ±ÅŸtÄ±; buradan Ã¶zetleyelim:
    const rejected = this.feas?.plans
      .filter(p=>p.planId===vp.id && p.variant===vp.variant)
      .flatMap(p=>p.symbols)
      .filter(s=> s.findings.some(f=>f.type==="WHITELIST" || f.type==="TARGET_PCT")) || [];

    if (rejected.length){
      out.push({
        label:"Politika Uyum Ã–zeti",
        children:[
          { label:"Whitelist-dÄ±ÅŸÄ± / +%4 altÄ± sebebiyle elenen semboller", value: rejected.map(x=>x.symbol).join(", ") || "-", severity:"WARN" },
          { label:"SeÃ§ilen plandaki aktif semboller", value:[...symSet].join(", ") || "-" }
        ]
      });
    } else {
      out.push({ label:"Politika Uyum", value:"TÃ¼mÃ¼ uygun", severity:"INFO" });
    }
    return out;
  }

  private execSummary(actions: ActionBundle | null, planId: PlanId){
    if (!actions || actions.planId!==planId) return undefined;
    const n = actions.children.length;
    const reduceOnly = actions.children.filter(c=>c.reduceOnly).length;
    const postOnly   = actions.children.filter(c=>c.postOnly).length;
    const notion = actions.children.reduce((a,c)=> a + (c.price??0)*c.qty, 0);
    return { childCount:n, reduceOnlyRatio: +(reduceOnly/Math.max(1,n)).toFixed(2), postOnlyCount: postOnly, notionalUsd: Math.round(notion) };
  }

  private buildWhyTree(vp: VariantPlan | null, sel: PlanFeas | null): ExplainNode[] {
    const nodes: ExplainNode[] = [];
    if (!vp || !sel) return nodes;

    nodes.push({
      label:"SeÃ§im Kriterleri",
      children:[
        { label:"Feasibility Skoru", value: sel.score },
        { label:"Ã–neri", value: sel.recommend || "â€”" },
        { label:"Varyant", value: vp.variant || "â€”" },
        { label:"Exec Parametreleri", children:[
          { label:"childType", value: vp.exec.childType },
          { label:"limitOffsetBps", value: vp.exec.limitOffsetBps },
          { label:"twapMs", value: vp.exec.twapMs },
          { label:"iceberg", value: vp.exec.iceberg }
        ]}
      ]
    });

    // En kritik nedenler (ERROR/WARN)
    const crit = this.topFindings(sel);
    if (crit.length){
      nodes.push({
        label:"Kritik Bulgular",
        children: crit.map(f=>({ label:f.type, value:f.message + (f.quickFix?` | Fix: ${f.quickFix}`:""), severity:f.severity }))
      });
    }

    // Risk/sentinel ipuÃ§larÄ±
    if (vp.riskHints?.length){
      nodes.push({
        label:"Risk Ä°puÃ§larÄ±",
        children: vp.riskHints.map(h=>({ label:"hint", value:h, severity:"WARN" }))
      });
    }
    return nodes;
  }

  private suggestNext(vp: VariantPlan | null, sel: PlanFeas | null, sentinel: string): string[] {
    const out: string[] = [];
    if (!vp || !sel) return out;

    if (sentinel!=="NORMAL") out.push("Sentinel aktif: Yeni aÃ§Ä±lÄ±ÅŸlarÄ± durdur, yalnÄ±z reduce-only uygula.");
    if (sel.recommend==="ADJUST") out.push("PlanÄ± ayarla: TWAP +200ms, iceberg +0.02, gerekiyorsa POST_ONLY.");
    if (sel.recommend==="REJECT") out.push("PlanÄ± reddet: Plan C (nakit/spot) veya daha dÃ¼ÅŸÃ¼k notional ile yeniden dener.");

    // Sembollerde uyarÄ±
    for (const s of sel.symbols){
      const w = s.findings.find(f=>f.type==="TRIM" || f.type==="MIN_NOTIONAL" || f.type==="PERCENT_PRICE");
      if (w) out.push(`${s.symbol}: ${w.message}${w.quickFix?` â†’ ${w.quickFix}`:""}`);
    }
    if (!out.length) out.push("Plan uygun: VIVO-02â€™ye aktar ve yÃ¼rÃ¼tmeyi izle.");
    return Array.from(new Set(out)).slice(0,6);
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/explainabilityReporter.test.ts
import { describe,it,expect } from "vitest";
import { ExplainabilityReporter } from "../explainabilityReporter";
import type { MemorySnapshot, VariantOutput, FeasOutput, OperatorResult, ActionBundle, ReporterInput } from "../explainabilityReporter.types";

function feed(er: ExplainabilityReporter){
  const memory: MemorySnapshot = {
    asOf:new Date().toISOString(),
    postureWeights:{ RISK_ON:0.4, NEUTRAL:0.45, RISK_OFF:0.15 },
    planWeights:{ A:0.55, B:0.3, C:0.15 },
    defaults:{ defaultPlan:"A" }
  };
  const variants: VariantOutput = {
    asOf:new Date().toISOString(),
    variants:{
      A:[ { id:"A", title:"BTC+ETH", variant:"BAL", symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} } ],
      B:[ ],
      C:[ { id:"C", title:"Nakit+Spot", variant:"CONSV", symbols:[], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.2, childType:"POST_ONLY"} } ]
    }
  };
  const feas: FeasOutput = {
    asOf:new Date().toISOString(),
    overallScore: 78,
    plans:[
      { planId:"A", variant:"BAL", score:82, symbols:[{ symbol:"BTCUSDT", requestedNotionalUsd:8000, estimatedPrice:65000, estimatedQty:0.12, score:85, findings:[] }], summaryFindings:[], recommend:"OK" },
      { planId:"C", variant:"CONSV", score:65, symbols:[], summaryFindings:[{type:"SENTINEL",severity:"WARN",message:"â€”"}], recommend:"ADJUST" }
    ]
  };
  const op: OperatorResult = { selectedPlanId:"A", confirmations:{0:"A",1:"Evet"}, decidedBy:"OPERATOR", decidedAt:new Date().toISOString(), corrId:"test-corr" };
  const act: ActionBundle = { asOf:new Date().toISOString(), planId:"A", children:[{ symbol:"BTCUSDT", side:"BUY", type:"LIMIT", price:65010, qty:0.12 }], comments:[] };

  // Bus yerine doÄŸrudan alanlara set edelim (test kolaylÄ±ÄŸÄ±)
  (er as any).memory = memory;
  (er as any).variants = variants;
  (er as any).feas = feas;
  (er as any).lastSelection = op;
  (er as any).lastActions = act;
}

describe("VIVO-07 explainabilityReporter", ()=>{
  it("builds explain card with scores and why-tree", ()=>{
    const er = new ExplainabilityReporter();
    feed(er);
    const req: ReporterInput = { corrId:"test-corr", posture:"NEUTRAL", sentinel:"NORMAL" };
    const out:any = er.build(req);
    expect(out.header.selected.planId).toBe("A");
    expect(out.feasibility.selectedScore).toBeGreaterThan(0);
    expect(out.whyTree.length).toBeGreaterThan(0);
    expect(out.execSummary?.childCount).toBe(1);
  });

  it("is idempotent by corrId", ()=>{
    const er = new ExplainabilityReporter();
    feed(er);
    const req = { corrId:"dup", posture:"NEUTRAL", sentinel:"NORMAL" } as ReporterInput;
    const c1:any = er.build(req);
    const c2:any = er.build(req);
    expect(c2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-01/05/06 akÄ±ÅŸÄ± Ã§alÄ±ÅŸÄ±r â†’ vivo.variants + vivo.feasibility.

VIVO-03 operatÃ¶r seÃ§imi â†’ vivo.operator.result.

VIVO-02 Ã§ocuk emirleri Ã¼retir â†’ ops.actions.

VIVO-07 vivo.explain.request geldiÄŸinde (veya otomatik tetik), kartÄ± Ã¼retir â†’ vivo.explain.card.

Telegram/CLIâ€™da kart Ã¶zetini gÃ¶ster; audit.logâ€™a kalÄ±cÄ± iz bÄ±rak.
_________________________________________________________________________________________________________________
VIVO-08 Â· execGuardrailBridge.ts

AmaÃ§ (tek cÃ¼mle):
VIVO-02â€™nin Ã¶nerdiÄŸi ops.actions.proposed paketini, feasibility/findings + sentinel + policy sinyallerine gÃ¶re guardrailâ€™lerden geÃ§irip gÃ¼venli ops.actions olarak yayÄ±nlamak; gerekli durumlarda tam engelleme veya reduce-only moduna zorlamak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

Sentinel â‰  NORMAL â†’ yeni aÃ§Ä±lÄ±ÅŸ yok.

SLOWDOWN: yeni giriÅŸleri POST_ONLY + TWAPâ†‘ + icebergâ†‘ ile yavaÅŸlat; gerekirse notional TRIM.

HALT_PARTIAL | CIRCUIT_BREAKER: yalnÄ±z reduce-only (aÃ§Ä±k poz. kapama/trim).

Feasibility ERRORâ€™larÄ±: DENY, REDUCE_ONLY, SYMBOL_STATUS!=TRADING, WHITELIST/TARGET_PCT fail â†’ o sembolde yeni giriÅŸ iptal.

Feasibility WARNâ€™larÄ±: TRIM, PERCENT_PRICE, MIN_NOTIONAL yakÄ±n, BALANCE â†’ quick-fix uygula (notionalâ†“, POST_ONLY, TWAP+Î”, iceberg+Î”).

KapanmamÄ±ÅŸ bar yok: TÃ¼m metrikler kapanmÄ±ÅŸ veriden gelmiÅŸtir (VIVO-05/06/GB).

Borsa kurallarÄ± (tick/lot/notional) nihai kuantizasyonu VIVO-02 yapar; bu kÃ¶prÃ¼ davranÄ±ÅŸsal/operasyonel ayarlar uygular.

ArayÃ¼zler (TypeScript)
// vivo/execGuardrailBridge.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Level = "GREEN"|"AMBER"|"RED";
export type PlanId = "A"|"B"|"C";

export interface RiskState {
  level: Level;
  sentinel: Sentinel;
}

export interface ItemFinding {
  type: string;                 // "TRIM" | "REDUCE_ONLY" | "DENY" | "PERCENT_PRICE" | ...
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}

export interface SymbolFeas {
  symbol: string;
  requestedNotionalUsd: number;
  estimatedPrice: number;
  estimatedQty: number;
  score: number;                 // 0..100
  findings: ItemFinding[];
  adjustedNotionalUsd?: number;  // VIVO-06 Ã¶nerisi
}

export interface PlanFeas {
  planId: PlanId;
  variant?: "AGGR"|"BAL"|"CONSV";
  score: number;
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf: string;
  overallScore: number;
  plans: PlanFeas[];
}

export interface ActionChild {
  symbol: string;
  side: "BUY"|"SELL";
  type: "LIMIT"|"MARKET"|"POST_ONLY"|"IOC";
  price?: number;
  qty: number;
  reduceOnly?: boolean;
  postOnly?: boolean;
  meta?: { twapMs?: number; iceberg?: number; slice?: number; slices?: number; corrId?: string };
}

export interface ActionBundle {
  asOf: string;
  planId: PlanId;
  corrId?: string;
  children: ActionChild[];
  comments?: string[];
}

export interface GuardrailConfig {
  twapBumpMs: number;          // SLOWDOWN/HIGH-RISK iÃ§in eklenecek min TWAP (Ã¶rn 200â€“400ms)
  icebergBump: number;         // 0.02â€“0.05 arasÄ± ek parÃ§a
  maxIceberg: number;          // 0.5
  notionalTrimRatio: number;   // TRIM uyarÄ±sÄ±nda % kesinti (Ã¶rn 0.85)
  enforcePostOnly: boolean;    // yavaÅŸlama modunda post-only zorlansÄ±n mÄ±?
}

export interface GuardrailReport {
  corrId?: string;
  planId: PlanId;
  before: ActionBundle;
  after: ActionBundle;
  changes: string[];           // insan-okur Ã¶zet
  blockedSymbols: string[];    // tamamen engellenen semboller
  mode: "NORMAL"|"SLOWDOWN"|"REDUCE_ONLY";
}

export interface ExecGuardrailInput {
  risk: RiskState;
  feas: FeasOutput;
  proposed: ActionBundle;      // VIVO-02 Ã¼retti
  cfg?: Partial<GuardrailConfig>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

ops.actions.proposed (VIVO-02â€™den)

vivo.feasibility (VIVO-06â€™dan â€“ en son skor/bulgular)

risk.state (GB-61/Net/Sentinel akÄ±ÅŸÄ±)

Publish:

ops.actions (guarded, yÃ¼rÃ¼tmeye hazÄ±r)

ops.guardrail.report (Ã¶nce/sonra fark raporu)

audit.log (Ã¶zet; idempotent/corrId izleri)

Guardrail PolitikalarÄ± (deterministik eÅŸleÅŸtirme)
KoÅŸul / Bulgu	Uygulama (auto-tweak)
Sentinel = CIRCUIT_BREAKER / HALT_PARTIAL	TÃ¼m yeni BUY/SELL aÃ§Ä±lÄ±ÅŸlarÄ± kaldÄ±r, kalanlar reduceOnly=true
Sentinel = SLOWDOWN	POST_ONLY=true, twapMs += twapBumpMs, iceberg += icebergBump (â‰¤ maxIceberg)
Finding = REDUCE_ONLY (ERROR)	Ä°lgili sembolde yalnÄ±z reduceOnly emirler bÄ±rak
Finding = DENY / WHITELIST / TARGET_PCT	Ä°lgili sembolde tÃ¼m yeni giriÅŸleri kaldÄ±r
Finding = TRIM (WARN)	Sembol notionalâ€™Ä± notionalTrimRatio ile kes (qtyâ†“)
Finding = PERCENT_PRICE (WARN)	POST_ONLY=true + twapMs += twapBumpMs/2
Finding = MIN_NOTIONAL (ERROR)	SembolÃ¼ kaldÄ±r veya aynÄ± plandaki baÅŸka sembollere paylaÅŸtÄ±rma yapma (iyimserlik Ã¶nlenir)

Not: Tick/lot/notional kesin yuvarlama VIVO-02â€™de; VIVO-08 yalnÄ±z davranÄ±ÅŸsal korumalarÄ± uygular.

Kod Ä°skeleti (TypeScript)
// vivo/execGuardrailBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  ExecGuardrailInput, GuardrailConfig, GuardrailReport, FeasOutput,
  PlanFeas, SymbolFeas, ActionBundle, ActionChild, StdError
} from "./execGuardrailBridge.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class ExecGuardrailBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-08";
  private feas: FeasOutput | null = null;
  private lastRisk: ExecGuardrailInput["risk"] | null = null;
  private seenCorr = new Set<string>();
  private cfg: GuardrailConfig = {
    twapBumpMs: 300,
    icebergBump: 0.03,
    maxIceberg: 0.5,
    notionalTrimRatio: 0.85,
    enforcePostOnly: true
  };

  attach(){
    bus.on<FeasOutput>("vivo.feasibility", (f)=> this.feas = f);
    bus.on<any>("risk.state", (r)=> this.lastRisk = r);
    bus.on<ActionBundle>("ops.actions.proposed", (ab)=> this.safeGuard({ risk:this.lastRisk!, feas:this.feas!, proposed:ab }));
  }

  /** DÄ±ÅŸarÄ±dan manuel tetikleme iÃ§in */
  safeGuard(x: ExecGuardrailInput){
    const res = this.run(x);
    if ("error" in (res as any)){
      logger.error(res, "VIVO-08 guard failed");
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:res }});
    } else {
      const rep = res as GuardrailReport;
      bus.emit<ActionBundle>("ops.actions", rep.after);
      bus.emit<GuardrailReport>("ops.guardrail.report", rep);
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ corrId:rep.corrId, mode:rep.mode, changes:rep.changes.slice(0,6) }});
    }
  }

  run(x: ExecGuardrailInput): GuardrailReport | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      const corr = x.proposed.corrId ?? `${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      if (this.seenCorr.has(corr)) return this.err("IDEMPOTENT","corrId already processed",{corrId:corr});

      const before = deepClone(x.proposed);
      const after: ActionBundle = deepClone(x.proposed);

      const planFeas = this.pickPlanFeas(x.feas, after.planId);
      const mode = this.applyGuards(after, planFeas, x);
      this.seenCorr.add(corr);

      return { corrId:corr, planId:after.planId, before, after, changes: diffSumm(before, after), blockedSymbols: blocked(after, before), mode };

    } catch (e:any){
      return this.err("GUARD_FAILED", e?.message || "unknown", { stack:e?.stack });
    }
  }

  private applyGuards(after: ActionBundle, pf: PlanFeas | null, x: ExecGuardrailInput): "NORMAL"|"SLOWDOWN"|"REDUCE_ONLY" {
    const risk = x.risk;
    let mode:"NORMAL"|"SLOWDOWN"|"REDUCE_ONLY" = "NORMAL";

    // 0) Sentinel sert kurallar
    if (risk.sentinel==="CIRCUIT_BREAKER" || risk.sentinel==="HALT_PARTIAL"){
      mode = "REDUCE_ONLY";
      // yeni aÃ§Ä±lÄ±ÅŸlarÄ± kaldÄ±r; kalanlarÄ± reduce-onlyâ€™a Ã§evir
      after.children = after.children.filter(c=> c.reduceOnly || c.side==="SELL"); // BUY aÃ§Ä±lÄ±ÅŸÄ± at
      for (const c of after.children){ c.reduceOnly = true; c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
      return mode;
    }
    if (risk.sentinel==="SLOWDOWN"){
      mode = "SLOWDOWN";
      for (const c of after.children){
        if (this.cfg.enforcePostOnly){ c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
        c.meta = c.meta || {};
        c.meta.twapMs = (c.meta.twapMs ?? 0) + this.cfg.twapBumpMs;
        c.meta.iceberg = clamp((c.meta.iceberg ?? 0.1) + this.cfg.icebergBump, 0.05, this.cfg.maxIceberg);
      }
    }

    // 1) Feasibility bulgularÄ±
    if (pf){
      // Sembol bazlÄ± quick-fix
      for (const sym of pf.symbols){
        const has = (t:string)=> sym.findings.some(f=>f.type===t);
        const hardDeny = has("DENY") || has("WHITELIST") || has("TARGET_PCT") || has("SYMBOL_STATUS") || has("REDUCE_ONLY");
        const warnTrim = has("TRIM");
        const warnBand = has("PERCENT_PRICE");
        const minNotionalErr = has("MIN_NOTIONAL");

        for (const c of after.children.filter(c=>c.symbol===sym.symbol)){
          if (hardDeny){
            // yeni giriÅŸleri kaldÄ±r; reduce-only varsa bÄ±rak
            if (!c.reduceOnly){ c.qty = 0; } // VIVO-02 kuantize ederken 0â€™larÄ± drop edecek
            c.postOnly = true;
          } else {
            // quick-fixâ€™ler
            if (warnTrim){
              c.qty = c.qty * this.cfg.notionalTrimRatio; // notional ~ qty * price
            }
            if (warnBand){
              c.postOnly = true;
              c.meta = c.meta || {};
              c.meta.twapMs = (c.meta.twapMs ?? 0) + Math.floor(this.cfg.twapBumpMs/2);
            }
            if (minNotionalErr){
              // minNotional fail: gÃ¼venli tarafta sembolÃ¼ kaldÄ±rÄ±yoruz (iyimserliÄŸi Ã¶nle)
              c.qty = 0;
            }
          }
        }
      }

      // Plan Ã¶nerisi "REJECT" ise varsayÄ±lan konservatif: yalnÄ±z reduce-only bÄ±rak
      if (pf.recommend==="REJECT"){
        mode = mode==="SLOWDOWN" ? "SLOWDOWN" : "REDUCE_ONLY";
        after.children = after.children.filter(c=> c.reduceOnly || c.side==="SELL");
        for (const c of after.children){ c.reduceOnly = true; c.postOnly = true; if (c.type==="LIMIT") c.type="POST_ONLY"; }
      }
    }

    // 2) Temizlik: qty<=0 olanlarÄ± at
    after.children = after.children.filter(c=> (c.qty ?? 0) > 0);

    return mode;
  }

  private pickPlanFeas(feas: FeasOutput, planId: PlanFeas["planId"]): PlanFeas | null {
    if (!feas?.plans?.length) return null;
    const arr = feas.plans.filter(p=>p.planId===planId);
    if (!arr.length) return null;
    // en yÃ¼ksek skorlu varyantÄ± seÃ§
    return arr.sort((a,b)=>b.score-a.score)[0];
  }

  private validate(x: ExecGuardrailInput): string | null {
    if (!x?.proposed || !Array.isArray(x.proposed.children)) return "proposed actions missing/invalid";
    if (!x?.risk) return "risk state missing";
    if (!x?.feas || !Array.isArray(x.feas.plans)) return "feas missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    return { error: e };
  }
}

// ------- yardÄ±mcÄ±lar
function deepClone<T>(o:T):T{ return JSON.parse(JSON.stringify(o)); }

function diffSumm(a:ActionBundle, b:ActionBundle): string[] {
  const lines: string[] = [];
  const key = (c:ActionChild)=>`${c.symbol}:${c.side}:${c.type}`;
  const idxA = new Map(a.children.map((c,i)=>[key(c), {i,c}]));
  const idxB = new Map(b.children.map((c,i)=>[key(c), {i,c}]));
  for (const [k,{c}] of idxA){
    if (!idxB.has(k)) lines.push(`DROP ${k}`);
  }
  for (const [k,{c}] of idxB){
    if (!idxA.has(k)) { lines.push(`ADD ${k} qty=${c.qty}`); continue; }
    const prev = idxA.get(k)!.c;
    if ((prev.qty??0)!==(c.qty??0)) lines.push(`QTY ${k}: ${prev.qty}â†’${c.qty}`);
    if (!!prev.postOnly!==!!c.postOnly) lines.push(`POST_ONLY ${k}: ${!!prev.postOnly}â†’${!!c.postOnly}`);
    if (!!prev.reduceOnly!==!!c.reduceOnly) lines.push(`REDUCE_ONLY ${k}: ${!!prev.reduceOnly}â†’${!!c.reduceOnly}`);
    const pT = prev.meta?.twapMs ?? 0, nT = c.meta?.twapMs ?? 0;
    if (pT!==nT) lines.push(`TWAP ${k}: ${pT}â†’${nT}`);
    const pI = prev.meta?.iceberg ?? 0, nI = c.meta?.iceberg ?? 0;
    if (pI!==nI) lines.push(`ICEBERG ${k}: ${pI}â†’${nI}`);
  }
  return lines.slice(0,20);
}

function blocked(after:ActionBundle, before:ActionBundle): string[] {
  const setB = new Set(before.children.map(c=>c.symbol+":"+c.side));
  const setA = new Set(after.children.map(c=>c.symbol+":"+c.side));
  return [...setB].filter(k=>!setA.has(k)).slice(0,20).map(s=>s.split(":")[0]);
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/execGuardrailBridge.test.ts
import { describe,it,expect } from "vitest";
import { ExecGuardrailBridge } from "../execGuardrailBridge";
import type { ExecGuardrailInput } from "../execGuardrailBridge.types";

const feas = {
  asOf: new Date().toISOString(),
  overallScore: 70,
  plans: [{
    planId:"A", variant:"BAL", score:72, recommend:"ADJUST",
    symbols:[
      { symbol:"ETHUSDT", requestedNotionalUsd:3000, estimatedPrice:3000, estimatedQty:1, score:68, findings:[{type:"TRIM",severity:"WARN",message:"notional>allowed"}] },
      { symbol:"OPUSDT",  requestedNotionalUsd:1500, estimatedPrice:4,    estimatedQty:375, score:40, findings:[{type:"WHITELIST",severity:"ERROR",message:"whitelist dÄ±ÅŸÄ±"}] }
    ],
    summaryFindings:[]
  }]
};

const proposed = {
  asOf: new Date().toISOString(),
  planId:"A",
  corrId:"corr-1",
  children:[
    { symbol:"BTCUSDT", side:"BUY", type:"LIMIT", qty:0.12, meta:{ twapMs:1200, iceberg:0.12 } },
    { symbol:"ETHUSDT", side:"BUY", type:"LIMIT", qty:1.00,  meta:{ twapMs:1200, iceberg:0.10 } },
    { symbol:"OPUSDT",  side:"BUY", type:"LIMIT", qty:400,   meta:{ twapMs:1200, iceberg:0.10 } }
  ],
  comments:[]
};

describe("VIVO-08 execGuardrailBridge", ()=>{
  it("applies TRIM, drops whitelist-failed, bumps TWAP/iceberg on slowdown", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run({
      risk:{ level:"AMBER", sentinel:"SLOWDOWN" },
      feas: feas as any,
      proposed: proposed as any
    } as ExecGuardrailInput);

    expect(out.mode).toBe("SLOWDOWN");
    // OPUSDT whitelist hatalÄ± â†’ dÃ¼ÅŸmeli
    const symsAfter = out.after.children.map((c:any)=>c.symbol);
    expect(symsAfter).not.toContain("OPUSDT");
    // ETHUSDT TRIM â†’ qty dÃ¼ÅŸmeli
    const ethBefore = proposed.children.find(c=>c.symbol==="ETHUSDT")!.qty;
    const ethAfter  = out.after.children.find((c:any)=>c.symbol==="ETHUSDT")!.qty;
    expect(ethAfter).toBeLessThan(ethBefore);
    // TWAP bump + POST_ONLY
    const anyChild = out.after.children[0];
    expect(anyChild.meta.twapMs).toBeGreaterThanOrEqual(1200+200);
    expect(anyChild.postOnly).toBe(true);
  });

  it("forces reduce-only on circuit breaker", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run({
      risk:{ level:"RED", sentinel:"CIRCUIT_BREAKER" },
      feas: feas as any,
      proposed: proposed as any
    } as ExecGuardrailInput);

    expect(out.mode).toBe("REDUCE_ONLY");
    expect(out.after.children.every((c:any)=>c.reduceOnly===true)).toBe(true);
    // BUY aÃ§Ä±lÄ±ÅŸlarÄ±nÄ±n Ã§oÄŸu dÃ¼ÅŸer (qty 0 veya drop)
    expect(out.after.children.length).toBeGreaterThan(0);
  });

  it("idempotent by corrId", ()=>{
    const br = new ExecGuardrailBridge();
    const inp: ExecGuardrailInput = { risk:{ level:"AMBER", sentinel:"NORMAL" }, feas: feas as any, proposed: proposed as any };
    const r1:any = br.run(inp);
    const r2:any = br.run(inp);
    expect(r2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-02 Ã§ocuk emirleri Ã¼retir â†’ ops.actions.proposed.

VIVO-06 feasibility & findings hazÄ±rdÄ±r â†’ VIVO-08 â€œproposedâ€ + â€œfeasibilityâ€ + â€œrisk.stateâ€ verilerini alÄ±r.

VIVO-08 guardrail uygular â†’ ops.actions (yÃ¼rÃ¼tmeye hazÄ±r) + ops.guardrail.report (Ã¶nce/sonra fark).

GB-66/67 yÃ¼rÃ¼tÃ¼r; sonuÃ§lar GB-22/36 TCAâ€™ya akar.
_________________________________________________________________________________________________________________
VIVO-09 Â· upliftABEngine.ts

AmaÃ§ (tek cÃ¼mle):
Plan/varyant seÃ§imini kontrollÃ¼ deney kurgusuna baÄŸlayÄ±p (A/B/C), canlÄ± sonuÃ§lardan uplift istatistiÄŸi Ã¼reterek VIVOâ€™nun plan aÄŸÄ±rlÄ±klarÄ±nÄ± veriyle optimize etmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

Sinyal kapanmamÄ±ÅŸ bar kullanmaz; sadece atama & sonuÃ§ toplama yapar.

Risk/Sentinel RED/HALT/CB â†’ deney askÄ±ya alÄ±nÄ±r (yalnÄ±z â€œC/korumacÄ±â€ kola izin).

Politika kapÄ±larÄ± (whitelist, minTarget â‰¥ +%4) VIVO-05/06â€™da zaten uygulanÄ±r; burada sadece deney kurgusu yÃ¼rÃ¼r.

Muhasebe: Net PnL (komisyon, slipaj, funding dahil) ve mark-out/realized verileri GB-22/36â€™dan dinlenir.

Idempotency: AynÄ± corrId iÃ§in ikinci kez atama veya sonuÃ§ yazÄ±lmaz.

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/upliftABEngine.types.ts
import type { ISODate } from "../core/types";

export type PlanId = "A"|"B"|"C";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";

export interface VariantPlan {
  id: PlanId;
  title: string;
  variant?: VariantId;
  symbols: Array<Record<string,number>>;
  exec: { limitOffsetBps:number; twapMs:number; iceberg:number; childType:"LIMIT"|"IOC"|"POST_ONLY"|"MARKET" };
}

export interface VariantOutput {
  asOf: ISODate;
  variants: Record<PlanId, VariantPlan[]>;
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;                 // OperatÃ¶r seÃ§imi (karttaki Plan)
  confirmations: Record<number,string>;   // 0: plan A/B/C, devamÄ± evet/hayÄ±r vb.
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: ISODate;
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface AssignConfig {
  mode: "FIXED_SPLIT"|"EPS_GREEDY";     // sabit yÃ¼zdeler veya epsilon-greedy
  fixedSplit?: Record<VariantId, number>; // Ã¶r: {AGGR:0.3,BAL:0.5,CONSV:0.2}
  epsilon?: number;                       // 0.05..0.2 Ã¶nerilir
  minPerArm?: number;                     // anlamlÄ±lÄ±k iÃ§in min Ã¶rnek
  corrPrefix?: string;                    // deney corr id Ã¶n eki
}

export interface AssignDecision {
  corrId: string;                // deney korelasyon idâ€™si
  planId: PlanId;                // A/B/C planÄ±
  variant: VariantId;            // seÃ§ilen varyant kolu
  decidedAt: ISODate;
  decidedBy: "ENGINE"|"OPERATOR_DEFAULT";
  exposureSeq: number;           // kolun maruz kaldÄ±ÄŸÄ± Ã¶rnek sayÄ±sÄ±
}

export interface OutcomeIn {
  corrId: string;                // atama corrId
  planId: PlanId;
  variant?: VariantId;
  postureAtDecision: Posture;
  asOf: ISODate;
  pnlUsd: number;                // net realized PnL
  hit?: boolean;
  profitFactor?: number;
  rMultiple?: number;
  slippageBps?: number;
  markoutBp_5s?: number;
}

export interface ArmStat {
  n: number;
  sumPnl: number;
  hit: number;
  pfEWMA: number;
  meanPnl: number;
}

export interface LiftResult {
  baseline: VariantId;                 // karÅŸÄ±laÅŸtÄ±rma kolu (genelde BAL)
  compare: VariantId;                  // kÄ±yaslanan kol
  upliftPnl: number;                   // mean pnl farkÄ± (USD)
  upliftHit: number;                   // hit rate farkÄ± (pp)
  pValue?: number;                     // opsiyonel hÄ±zlÄ± z-test
  significant?: boolean;               // p<0.05 ?
}

export interface Snapshot {
  asOf: ISODate;
  arms: Record<VariantId, ArmStat>;
  lifts: LiftResult[];
}

export interface UpliftStore {
  load(): Promise<Snapshot | null>;
  save(s: Snapshot): Promise<void>;
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe:

vivo.variants (VIVO-05): eldeki planÄ±n varyant seti

vivo.operator.result (VIVO-03): seÃ§ilen Plan A/B/C

gb.tca (GB-22/36): kapanan iÅŸlem sonuÃ§larÄ± â†’ OutcomeIn

risk.state (GB-61/ops): sentinel/posture gÃ¼ncellemeleri

Publish:

vivo.uplift.assign (AssignDecision) â€“ VIVO-02â€™ye atÄ±f iÃ§in

vivo.uplift (OutcomeIn) â€“ sonuÃ§, VIVO-04 postureMemory kullanÄ±r

vivo.uplift.snapshot (Snapshot) â€“ Denetim AsistanÄ±/raporlar iÃ§in

audit.log â€“ atama & sonuÃ§ Ã¶zeti

Validasyon & Kurallar

Sentinel â‰  NORMAL â†’ yalnÄ±z CONSV kolu atanÄ±r, decidedBy="OPERATOR_DEFAULT" iÅŸaretlenebilir.

OperatÃ¶r bir Plan seÃ§tikten sonra VIVO-09, bu planÄ±n iÃ§indeki varyant kolunu atar (Ã¶rn. A/B/C planÄ±nda BAL/AGGR/CONSV).

EPS_GREEDY: %Îµ rastgele, %1-Îµ en yÃ¼ksek meanPnL kolu.

FIXED_SPLIT: normalize split; exposure sayÄ±sÄ± eÅŸik altÄ±ndaysa under-exposed kola Ã¶ncelik.

Idempotency: aynÄ± corrId ikinci kez atama/sonuÃ§ kabul etmeyiz.

Kod Ä°skeleti (TypeScript / Node)
// vivo/upliftABEngine.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AssignConfig, AssignDecision, VariantOutput, OperatorResult, RiskState,
  OutcomeIn, Snapshot, UpliftStore, VariantId, PlanId, StdError
} from "./upliftABEngine.types";

const VARS: VariantId[] = ["AGGR","BAL","CONSV"];

class InMemoryStore implements UpliftStore {
  private snap: Snapshot | null = null;
  async load(){ return this.snap; }
  async save(s: Snapshot){ this.snap = s; }
}

export class UpliftABEngine extends EventEmitter {
  ver="1.0.0"; src="VIVO-09";
  private cfg: Required<AssignConfig>;
  private store: UpliftStore;
  private snap: Snapshot = { asOf:new Date().toISOString(), arms:{
      AGGR:{n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0},
      BAL: {n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0},
      CONSV:{n:0,sumPnl:0,hit:0,pfEWMA:1,meanPnl:0}
    }, lifts:[] };
  private lastVariants: VariantOutput | null = null;
  private lastOperator: OperatorResult | null = null;
  private lastRisk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  private seenCorr = new Set<string>();

  constructor(cfg?: Partial<AssignConfig>, store?: UpliftStore){
    super();
    this.cfg = {
      mode: "EPS_GREEDY",
      epsilon: 0.1,
      fixedSplit: { AGGR:0.33, BAL:0.34, CONSV:0.33 },
      minPerArm: 30,
      corrPrefix: "upl"
      , ...cfg
    } as Required<AssignConfig>;
    this.store = store ?? new InMemoryStore();
  }

  async attach(){
    const saved = await this.store.load(); if (saved) this.snap = saved;
    bus.on<VariantOutput>("vivo.variants", v=>{ this.lastVariants = v; });
    bus.on<OperatorResult>("vivo.operator.result", o=>{ this.lastOperator = o; });
    bus.on<RiskState>("risk.state", r=>{ this.lastRisk = r; });
    bus.on<OutcomeIn>("gb.tca", o=> this.ingestOutcome(o).catch(e=>logger.error(e,"VIVO-09 outcome")));
    bus.on("vivo.uplift.request", ()=> this.safeAssign());
  }

  // --- ATAMA ---
  safeAssign(){
    const res = this.assign();
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-09 assign failed");
    } else {
      const a = res as AssignDecision;
      bus.emit<AssignDecision>("vivo.uplift.assign", a);
      bus.emit("audit.log", { asOf:a.decidedAt, ver:this.ver, src:this.src, payload:{ msg:"assign", corrId:a.corrId, plan:a.planId, var:a.variant }});
    }
  }

  assign(): AssignDecision | { error: StdError } {
    try {
      if (!this.lastOperator) return this.err("STATE_MISSING","operator selection missing");
      if (!this.lastVariants) return this.err("STATE_MISSING","variants missing");
      const planId = this.lastOperator.selectedPlanId;
      const candidates = this.lastVariants.variants[planId] || [];
      if (!candidates.length) return this.err("NO_ARMS",`no variants for plan ${planId}`);

      // Sentinel / Risk kuralÄ±
      if (this.lastRisk.sentinel!=="NORMAL"){
        const consv = candidates.find(v=>v.variant==="CONSV") || candidates[0];
        return this.makeDecision(planId, consv.variant ?? "CONSV", "OPERATOR_DEFAULT");
      }

      // Deney: AGGR/BAL/CONSV iÃ§inden seÃ§
      const avail = candidates.map(v=>v.variant || "BAL") as VariantId[];
      const chosen = this.cfg.mode==="EPS_GREEDY"
        ? this.pickEpsGreedy(avail)
        : this.pickFixedSplit(avail);

      return this.makeDecision(planId, chosen, "ENGINE");

    } catch (e:any){
      return this.err("ASSIGN_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private makeDecision(planId: PlanId, variant: VariantId, by:"ENGINE"|"OPERATOR_DEFAULT"): AssignDecision {
    const corrId = `${this.cfg.corrPrefix}-${Date.now()}-${Math.random().toString(36).slice(2,7)}`;
    const exposureSeq = this.snap.arms[variant].n + 1;
    const dec: AssignDecision = { corrId, planId, variant, decidedAt:new Date().toISOString(), decidedBy:by, exposureSeq };
    return dec;
  }

  private pickEpsGreedy(avail: VariantId[]): VariantId {
    // Îµ rastgele, 1-Îµ en iyi meanPnl
    if (Math.random() < this.cfg.epsilon){
      return avail[Math.floor(Math.random()*avail.length)];
    }
    // En iyi kol: mevcut snapshotâ€™taki meanPnl en yÃ¼ksek olan (sadece availâ€™den)
    let best: VariantId = avail[0]; let bestVal = -1e9;
    for (const v of avail){
      const m = this.snap.arms[v].meanPnl;
      if (m > bestVal){ bestVal = m; best = v; }
    }
    return best;
  }

  private pickFixedSplit(avail: VariantId[]): VariantId {
    // Under-exposed Ã¶ncelik: minPerArm altÄ±ndaki avail kollarÄ± tercih et
    const under = avail.filter(v=> this.snap.arms[v].n < this.cfg.minPerArm);
    const pool = under.length ? under : avail;
    // AÄŸÄ±rlÄ±klar normalize
    const w = pool.map(v=> Math.max(0, this.cfg.fixedSplit[v] ?? 0.001));
    const sum = w.reduce((a,b)=>a+b,0) || 1;
    const r = Math.random() * sum;
    let acc = 0;
    for (let i=0;i<pool.length;i++){ acc += w[i]; if (r <= acc) return pool[i]; }
    return pool[pool.length-1];
  }

  // --- SONUÃ‡ Ä°Ã‡ERME ---
  async ingestOutcome(x: OutcomeIn): Promise<Snapshot | { error: StdError }> {
    try {
      if (!x?.corrId) return this.err("VALIDATION_ERROR","corrId missing");
      if (this.seenCorr.has(x.corrId)) return this.ok(); // idempotent
      if (!VARS.includes((x.variant as VariantId) || "BAL")) return this.err("VALIDATION_ERROR","variant invalid");

      const v = (x.variant as VariantId) || "BAL";
      const arm = this.snap.arms[v];
      arm.n += 1;
      arm.sumPnl += x.pnlUsd;
      arm.hit += x.hit ? 1 : 0;
      // PF EWMA kaba gÃ¼ncelleme
      const alpha = 0.1;
      const pfObs = x.profitFactor ?? 1;
      arm.pfEWMA = alpha*pfObs + (1-alpha)*arm.pfEWMA;
      arm.meanPnl = arm.sumPnl / Math.max(1, arm.n);

      this.snap.lifts = this.computeLifts();
      this.snap.asOf = new Date().toISOString();
      await this.store.save(this.snap);

      // PostureMemory iÃ§in publish (VIVO-04 bu olayÄ± dinliyor)
      bus.emit<OutcomeIn>("vivo.uplift", x);
      bus.emit<Snapshot>("vivo.uplift.snapshot", this.snap);
      bus.emit("audit.log", { asOf:this.snap.asOf, ver:this.ver, src:this.src,
        payload:{ msg:"uplift outcome", variant:v, meanPnl:arm.meanPnl, n:arm.n } });

      this.seenCorr.add(x.corrId);
      return this.snap;

    } catch (e:any){
      return this.err("INGEST_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private computeLifts(){
    const base: VariantId = "BAL";
    const out = [] as any[];
    for (const v of VARS){
      if (v===base) continue;
      const a = this.snap.arms[base], b = this.snap.arms[v];
      const upliftPnl = (b.meanPnl - a.meanPnl);
      const upliftHit = (b.n? b.hit/b.n : 0) - (a.n? a.hit/a.n : 0);
      const pValue = this.quickZTest(a.hit, a.n, b.hit, b.n);
      out.push({ baseline:base, compare:v, upliftPnl, upliftHit, pValue, significant: (pValue!==null && pValue<0.05) });
    }
    return out;
  }

  // Basit iki-oran z-testi (hit rate iÃ§in). n kÃ¼Ã§Ã¼kse pValue=null.
  private quickZTest(h1:number, n1:number, h2:number, n2:number): number | null {
    if (n1<20 || n2<20) return null;
    const p1 = h1/Math.max(1,n1), p2 = h2/Math.max(1,n2);
    const p  = (h1+h2)/Math.max(1,(n1+n2));
    const se = Math.sqrt(p*(1-p)*(1/n1 + 1/n2));
    if (!isFinite(se) || se===0) return null;
    const z = (p2 - p1)/se;
    // yaklaÅŸÄ±k p-deÄŸeri (iki kuyruk)
    const cdf = (x:number)=> 0.5*(1+erf(x/Math.SQRT2));
    const pval = 2*(1 - cdf(Math.abs(z)));
    return pval;
  }

  private ok(){ return this.snap; }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

// hÄ±zlÄ± erf yaklaÅŸÄ±mÄ±
function erf(x:number){
  // Abramowitz & Stegun formÃ¼lÃ¼
  const s = Math.sign(x);
  x = Math.abs(x);
  const a1=0.254829592,a2=-0.284496736,a3=1.421413741,a4=-1.453152027,a5=1.061405429,p=0.3275911;
  const t=1/(1+p*x);
  const y=1-((((a5*t+a4)*t+a3)*t+a2)*t+a1)*t*Math.exp(-x*x);
  return s*y;
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/upliftABEngine.test.ts
import { describe,it,expect } from "vitest";
import { UpliftABEngine } from "../upliftABEngine";
import type { VariantOutput, OperatorResult, RiskState, OutcomeIn } from "../upliftABEngine.types";

function feed(engine: any){
  const variants: VariantOutput = {
    asOf:new Date().toISOString(),
    variants:{
      A:[
        { id:"A", title:"Plan A", variant:"AGGR",  symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1200, iceberg:0.12, childType:"LIMIT"} },
        { id:"A", title:"Plan A", variant:"BAL",   symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT"} },
        { id:"A", title:"Plan A", variant:"CONSV", symbols:[{"BTCUSDT":6000}], exec:{limitOffsetBps:6, twapMs:1700, iceberg:0.16, childType:"POST_ONLY"} }
      ],
      B:[], C:[]
    }
  };
  const op: OperatorResult = { selectedPlanId:"A", confirmations:{0:"A"}, decidedBy:"OPERATOR", decidedAt:new Date().toISOString(), corrId:"op-1" };
  const risk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  engine.lastVariants = variants;
  engine.lastOperator = op;
  engine.lastRisk = risk;
}

describe("VIVO-09 upliftABEngine", ()=>{
  it("assigns a variant via epsilon-greedy", ()=>{
    const eng:any = new UpliftABEngine({ mode:"EPS_GREEDY", epsilon:0.2 });
    feed(eng);
    const a = eng.assign() as any;
    expect(["AGGR","BAL","CONSV"]).toContain(a.variant);
    expect(a.planId).toBe("A");
  });

  it("ingests outcomes and computes lifts", async ()=>{
    const eng:any = new UpliftABEngine({ mode:"FIXED_SPLIT", fixedSplit:{AGGR:0.4,BAL:0.4,CONSV:0.2}, minPerArm: 2 });
    feed(eng);
    // iki AGGR, iki BAL sonucu gÃ¶nder
    const mk = (id:string, varId:"AGGR"|"BAL", pnl:number): OutcomeIn => ({
      corrId:id, planId:"A", variant:varId, postureAtDecision:"NEUTRAL", asOf:new Date().toISOString(), pnlUsd:pnl, hit:(pnl>0), profitFactor:pnl>0?1.4:0.8
    });
    await eng.ingestOutcome( mk("c1","AGGR", 100) );
    await eng.ingestOutcome( mk("c2","AGGR", -20) );
    await eng.ingestOutcome( mk("c3","BAL", 60) );
    await eng.ingestOutcome( mk("c4","BAL", 10) );
    const snap = eng.snap as any;
    expect(snap.arms.AGGR.n).toBe(2);
    expect(snap.lifts.length).toBeGreaterThan(0);
  });

  it("falls back to CONSV on sentinel halt", ()=>{
    const eng:any = new UpliftABEngine();
    feed(eng);
    eng.lastRisk.sentinel = "HALT_PARTIAL";
    const a = eng.assign() as any;
    expect(a.variant).toBe("CONSV");
    expect(a.decidedBy).toBe("OPERATOR_DEFAULT");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-05 â†’ varyant seti (vivo.variants).

VIVO-03 â†’ operatÃ¶r Plan A/B/C seÃ§imi (vivo.operator.result).

VIVO-09 â†’ seÃ§ilen planÄ±n iÃ§inden varyant atamasÄ± yapar (vivo.uplift.assign) â†’ VIVO-02 bu kola gÃ¶re Ã§ocuk emirleri Ã¼retir.

GB-22/36 â†’ iÅŸlem kapandÄ±kÃ§a sonuÃ§ (gb.tca) yayÄ±nlar.

VIVO-09 â†’ sonucu ingest eder â†’ vivo.uplift olarak VIVO-04 postureMemoryâ€™ye yollar; vivo.uplift.snapshot ile de Denetim AsistanÄ±â€™na/resimlere ÅŸeffaflÄ±k saÄŸlar.

VIVO-04 â†’ aÄŸÄ±rlÄ±klarÄ± gÃ¼nceller; VIVO-01/03/05 varsayÄ±lanlarÄ± ve sÄ±ralamayÄ± bu hafÄ±zaya gÃ¶re modÃ¼le eder.
_________________________________________________________________________________________________________________
VIVO-10 Â· execGuardrailBridge.ts
AmaÃ§

SeÃ§ilen plan/varyantÄ±, borsa kurallarÄ± + risk/sentinel + politika kapÄ±larÄ± Ä±ÅŸÄ±ÄŸÄ±nda icraya gÃ¼venli hÃ¢le getirip VIVO-02â€™ye â€œpatchâ€ olarak iletmek. Hedef: canlÄ±-BT farkÄ±nÄ± ve slipajÄ± dÃ¼ÅŸÃ¼rmek; â€œyanlÄ±ÅŸ emirâ€ riskini sÄ±fÄ±ra yaklaÅŸtÄ±rmak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar kullanÄ±lmaz. YalnÄ±zca feasibility bulgularÄ± ve risk durumu iÅŸlenir.

Sentinel â‰  NORMAL: Yeni aÃ§Ä±lÄ±ÅŸ yasak; yalnÄ±z reduceOnly kapamaya izin.

Politika: whitelist dÄ±ÅŸÄ± veya minTargetPct < +%4 semboller plandan Ã§Ä±karÄ±lÄ±r (fail-closed).

Feasibility tÃ¼rÃ¼ne gÃ¶re aksiyon (deterministik):

TRIM â†’ notionalâ€™Ä± allowedNotionalUsdâ€™a indir.

REDUCE_ONLY/DENY/MAX_POSITION/SENTINEL â†’ yeni giriÅŸ yok; pozlar reduce-only.

PERCENT_PRICE â†’ limitOffsetBps gÃ¼venli banda kaydÄ±r, POST_ONLY Ã¶ner/uygula.

MIN_NOTIONAL â†’ artÄ±r(a)mayacaksak sembolÃ¼ ele (veya operatorDialog gerekirse flagle).

BALANCE yetersiz â†’ notional â†“ veya Plan-C fallback etiketi.

Koruyucu param tweakleri (AMBER/RISK_OFF): TWAP +200..400ms, iceberg +0.02..0.06, mÃ¼mkÃ¼nse POST_ONLY.

ArayÃ¼zler (TypeScript)
// vivo/execGuardrailBridge.types.ts
export type Level = "GREEN"|"AMBER"|"RED";
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type PlanId = "A"|"B"|"C";
export type VariantId = "AGGR"|"BAL"|"CONSV";
export type ChildType = "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface ExecParams {
  limitOffsetBps:number; twapMs:number; iceberg:number; childType:ChildType;
}

export interface VariantPlan {
  id: PlanId; title: string; variant?: VariantId;
  symbols: Array<Record<string, number>>; // {SYMBOL: notionalUsd}
  exec: ExecParams;
}

export interface ItemFinding {
  type:
    | "WHITELIST" | "TARGET_PCT" | "SYMBOL_STATUS" | "PERMISSIONS"
    | "DENY" | "REDUCE_ONLY" | "TRIM"
    | "MIN_NOTIONAL" | "PERCENT_PRICE" | "MAX_POSITION" | "BALANCE"
    | "SENTINEL" | "OK";
  severity: "INFO"|"WARN"|"ERROR";
  message: string;
  quickFix?: string;
}

export interface SymbolFeas {
  symbol:string;
  requestedNotionalUsd:number;
  estimatedPrice:number;
  estimatedQty:number;
  score:number;
  findings: ItemFinding[];
  adjustedNotionalUsd?: number;
}

export interface PlanFeas {
  planId: PlanId; variant?: VariantId; score:number;
  symbols: SymbolFeas[];
  summaryFindings: ItemFinding[];
  recommend?: "OK"|"ADJUST"|"REJECT";
}

export interface FeasOutput {
  asOf:string; overallScore:number; plans: PlanFeas[];
}

export interface RiskState {
  level: Level; sentinel: Sentinel; posture: Posture;
}

export interface OperatorResult {
  corrId?: string;
  selectedPlanId: PlanId;
  confirmations: Record<number,string>;
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decidedAt: string; // ISO
}

export interface AssignDecision {
  corrId: string; planId: PlanId; variant: VariantId;
  decidedAt: string; decidedBy: "ENGINE"|"OPERATOR_DEFAULT";
  exposureSeq: number;
}

export interface GuardInput {
  corrId: string;                          // VIVO-09 atamasÄ±ndan
  selected: VariantPlan;                   // VIVO-05/07 ile aynÄ± format
  feas: PlanFeas;                          // VIVO-06â€™dan seÃ§ili planÄ±n feasibilityâ€™si
  risk: RiskState;                         // GB-61/ops
}

export interface GuardedSymbolPatch {
  symbol: string;
  action: "KEEP"|"DROP"|"REDUCE_ONLY";
  reason?: string[];
  notionalUsd?: number;                    // TRIM sonrasÄ±
}

export interface GuardPatch {
  corrId: string;
  planId: PlanId; variant?: VariantId;
  exec: ExecParams;                         // tweaked
  symbols: GuardedSymbolPatch[];            // ele/trim/keep
  reduceOnlyAll?: boolean;                  // sentinel/fail kapÄ±sÄ±
  notes?: string[];                         // VIVO-03â€™e kart notu
}

export interface ActionIntent {
  asOf: string;
  planId: PlanId;
  reduceOnlyAll?: boolean;
  exec: ExecParams;
  children: Array<{
    symbol:string; side:"BUY"|"SELL"; type:ChildType;
    qty?: number; price?: number; notionalUsd?: number;
    reduceOnly?: boolean; postOnly?: boolean;
    meta?: { twapMs?: number; iceberg?: number; corrId?: string };
  }>;
  comments?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus

Subscribe:

vivo.explain.card veya vivo.uplift.assign (corrId/plan/variant kaydÄ±)

vivo.feasibility (VIVO-06)

risk.state (GB-61)

Publish:

ops.exec.patch (GuardPatch) â†’ VIVO-02 bu patchâ€™i uygulayÄ±p Ã§ocuk emirleri Ã¼retir

vivo.guardrail.report (Ã¶zet)

audit.log

Guard KurallarÄ± (deterministik tablo)
Bulgu / Durum	Patch
SENTINELâ‰ NORMAL	reduceOnlyAll=true, exec.childType="POST_ONLY", TWAP+=300ms, iceberg+=0.04
DENY / REDUCE_ONLY / MAX_POSITION	Ä°lgili sembol: action="REDUCE_ONLY" (yeni giriÅŸ yok)
TRIM (+ allowedNotionalUsd)	Sembol notionalUsd = allowedNotionalUsd, action="KEEP"
PERCENT_PRICE	limitOffsetBps gÃ¼venli banda it; childType="POST_ONLY" Ã¶ner/uygula; TWAP+200ms
MIN_NOTIONAL	ArtÄ±r(a)mayacaksak action="DROP"
BALANCE	Sembol notional â†“ (pro-rata) veya Plan-C bayraÄŸÄ± (not dÃ¼ÅŸ)
WHITELIST/TARGET_PCT	action="DROP" (fail-closed)
AMBER seviyesi	TWAP+200ms, iceberg+0.02 (boundâ€™lu)
RISK_OFF posture	childType="POST_ONLY", limitOffsetBps+=2, TWAP+300ms, iceberg+0.04

Boundâ€™lar: 0 â‰¤ limitOffsetBps â‰¤ 15, 400 â‰¤ TWAP(ms) â‰¤ 4000, 0.05 â‰¤ iceberg â‰¤ 0.5.

Kod Ä°skeleti
// vivo/execGuardrailBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  GuardInput, GuardPatch, GuardedSymbolPatch, ExecParams, StdError
} from "./execGuardrailBridge.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=0)=> Number(x.toFixed(n));

export class ExecGuardrailBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-10";

  attach(){
    // Tipik tetikleyici: explain card veya uplift assign geldiÄŸinde, seÃ§ili plan iÃ§in feasibilityâ€™yi alÄ±p guard Ã§alÄ±ÅŸtÄ±r
    bus.on<GuardInput>("vivo.guard.request", (gi)=> this.safeRun(gi));
  }

  safeRun(gi: GuardInput){
    const res = this.run(gi);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-10 guard failed");
    } else {
      const patch = res as GuardPatch;
      bus.emit<GuardPatch>("ops.exec.patch", patch);
      bus.emit("vivo.guardrail.report", { asOf:new Date().toISOString(), ver:this.ver, src:this.src,
        payload:{ plan:patch.planId, variant:patch.variant, reduceOnlyAll:patch.reduceOnlyAll, notes:patch.notes }});
      bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ msg:"guard patch", plan:patch.planId }});
    }
  }

  run(gi: GuardInput): GuardPatch | { error: StdError } {
    try {
      const v = this.validate(gi); if (v) return this.err("VALIDATION_ERROR", v);

      // BaÅŸlangÄ±Ã§ exec paramlarÄ±
      let exec: ExecParams = { ...gi.selected.exec };
      const notes: string[] = [];
      const symbols: GuardedSymbolPatch[] = [];

      // Global sentinel/posture etkisi
      if (gi.risk.sentinel!=="NORMAL"){
        exec.childType = "POST_ONLY";
        exec.twapMs += 300; exec.iceberg += 0.04;
        exec = this.bound(exec);
      } else if (gi.risk.level==="AMBER" || gi.risk.posture==="RISK_OFF"){
        exec.twapMs += (gi.risk.posture==="RISK_OFF"?300:200);
        exec.iceberg += (gi.risk.posture==="RISK_OFF"?0.04:0.02);
        if (gi.risk.posture==="RISK_OFF"){
          exec.childType = "POST_ONLY";
          exec.limitOffsetBps += 2;
        }
        exec = this.bound(exec);
      }

      // Semboller bazÄ±nda feasibility bulgularÄ±
      for (const s of gi.feas.symbols){
        const patch = this.guardOneSymbol(s, exec);
        symbols.push(patch);
        if (patch.reason?.length) notes.push(`${s.symbol}: ${patch.reason.join("; ")}`);
      }

      // Global reduce-only bayraÄŸÄ±
      const reduceOnlyAll =
        gi.risk.sentinel!=="NORMAL" ||
        gi.feas.summaryFindings.some(f=> f.type==="SENTINEL" || f.type==="REDUCE_ONLY" || f.type==="DENY");

      // NotlarÄ± ve execâ€™i toparla
      exec = this.bound(exec);
      const out: GuardPatch = {
        corrId: gi.corrId,
        planId: gi.selected.id,
        variant: gi.selected.variant,
        exec,
        symbols,
        reduceOnlyAll,
        notes: Array.from(new Set(notes)).slice(0, 12)
      };
      return out;

    } catch (e:any){
      return this.err("GUARD_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private guardOneSymbol(s: any, exec: ExecParams): GuardedSymbolPatch {
    const reasons:string[] = [];
    let action: "KEEP"|"DROP"|"REDUCE_ONLY" = "KEEP";
    let notional = s.requestedNotionalUsd;

    const has = (t:string)=> s.findings.some((f:any)=>f.type===t);

    if (has("WHITELIST") || has("TARGET_PCT") || has("SYMBOL_STATUS")){
      action = "DROP"; reasons.push("policy/symbol status uygunsuz");
    }

    if (has("DENY")){
      action = "REDUCE_ONLY"; reasons.push("exposure=DENY");
    } else if (has("REDUCE_ONLY") || has("MAX_POSITION")){
      action = "REDUCE_ONLY"; reasons.push("reduce-only veya max position");
    }

    // TRIM
    const trimF = s.findings.find((f:any)=>f.type==="TRIM");
    if (trimF && s.adjustedNotionalUsd){
      notional = s.adjustedNotionalUsd;
      reasons.push(`TRIMâ†’ ${notional} USD`);
    }

    // MIN_NOTIONAL (yukarÄ± Ã§Ä±karma yetkisi yoksa ele)
    if (has("MIN_NOTIONAL")){
      action = "DROP";
      reasons.push("minNotional altÄ±nda");
    }

    // PERCENT_PRICE â†’ POST_ONLY + offset ayarÄ±
    if (has("PERCENT_PRICE")){
      exec.childType = "POST_ONLY";
      exec.limitOffsetBps = Math.max(exec.limitOffsetBps, 2);
      exec.twapMs += 200;
      exec.iceberg += 0.02;
      reasons.push("percent-price bandÄ±: POST_ONLY + offset/TWAP/iceberg");
    }

    // BALANCE uyarÄ±sÄ± â†’ pro-rata azalt (yukarÄ±da TRIM yoksa)
    if (has("BALANCE") && !trimF){
      notional = Math.max(0, Math.floor(notional * 0.9)); // kaba %10 kÄ±s
      reasons.push("balance yetersiz: notionalâ†“");
    }

    return { symbol: s.symbol, action, notionalUsd: notional, reason: reasons };
  }

  private bound(e: ExecParams): ExecParams {
    e.limitOffsetBps = clamp(e.limitOffsetBps, 0, 15);
    e.twapMs         = Math.round(clamp(e.twapMs, 400, 4000));
    e.iceberg        = round(clamp(e.iceberg, 0.05, 0.5), 2);
    return e;
  }

  private validate(gi: GuardInput): string | null {
    if (!gi?.corrId) return "corrId missing";
    if (!gi.selected || !gi.selected.exec) return "selected plan missing";
    if (!gi.feas || !Array.isArray(gi.feas.symbols)) return "feasibility missing";
    if (!gi.risk) return "risk missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/execGuardrailBridge.test.ts
import { describe,it,expect } from "vitest";
import { ExecGuardrailBridge } from "../execGuardrailBridge";
import type { GuardInput } from "../execGuardrailBridge.types";

function baseGI(): GuardInput {
  return {
    corrId:"corr-1",
    selected:{
      id:"A", title:"Plan A", variant:"BAL",
      symbols:[{"BTCUSDT":8000},{"ETHUSDT":4000}],
      exec:{ limitOffsetBps:6, twapMs:1400, iceberg:0.12, childType:"LIMIT" }
    },
    feas:{
      planId:"A", variant:"BAL", score:78,
      symbols:[
        { symbol:"BTCUSDT", requestedNotionalUsd:8000, estimatedPrice:65000, estimatedQty:0.12, score:82,
          findings:[ {type:"TRIM",severity:"WARN",message:"notional>allowed"} ], adjustedNotionalUsd:6000
        },
        { symbol:"ETHUSDT", requestedNotionalUsd:4000, estimatedPrice:3000, estimatedQty:1.33, score:40,
          findings:[ {type:"PERCENT_PRICE",severity:"WARN",message:"band dÄ±ÅŸÄ±"} ]
        }
      ],
      summaryFindings:[],
      recommend:"ADJUST"
    } as any,
    risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" }
  };
}

describe("VIVO-10 execGuardrailBridge", ()=>{
  it("applies TRIM and percent-price patches", ()=>{
    const br = new ExecGuardrailBridge();
    const out:any = br.run(baseGI());
    const btc = out.symbols.find((s:any)=>s.symbol==="BTCUSDT");
    const eth = out.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(btc.notionalUsd).toBe(6000);
    expect(eth.reason.join(" ")).toMatch(/percent-price/);
    expect(out.exec.childType).toBe("POST_ONLY"); // percent-price tetiklemiÅŸ olmalÄ± (AMBER + finding)
  });

  it("enforces reduce-only on sentinel halt", ()=>{
    const br = new ExecGuardrailBridge();
    const gi = baseGI();
    gi.risk.sentinel = "HALT_PARTIAL";
    const out:any = br.run(gi);
    expect(out.reduceOnlyAll).toBe(true);
    expect(out.exec.childType).toBe("POST_ONLY");
  });

  it("drops MIN_NOTIONAL symbols", ()=>{
    const br = new ExecGuardrailBridge();
    const gi = baseGI();
    (gi.feas.symbols[1] as any).findings.push({type:"MIN_NOTIONAL",severity:"ERROR",message:"too small"});
    const out:any = br.run(gi);
    const eth = out.symbols.find((s:any)=>s.symbol==="ETHUSDT");
    expect(eth.action).toBe("DROP");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-05/06 â†’ varyant + feasibility hazÄ±r.

VIVO-09 â†’ plan/variant atandÄ± (corrId).

VIVO-10 (vivo.guard.request) â†’ guard kurallarÄ±nÄ± uygular, ops.exec.patch yayÄ±nlar.

VIVO-02 â†’ patchâ€™i alÄ±r; tick/lot/notional & percent-price kurallarÄ±yla kesin emirleri Ã¼retir.

GB-22/36 â†’ TCA sonuÃ§larÄ± â†’ VIVO-09 uplift, VIVO-07 aÃ§Ä±klama.
_________________________________________________________________________________________________________________
VIVO-11 Â· spotCashAllocator.ts

AmaÃ§ (tek cÃ¼mle):
Toplam Ã¶zsermaye (equity), bakiye ve piyasa koÅŸullarÄ±na gÃ¶re hedef spot payÄ±nÄ± korumak (%30 kuralÄ±), whitelist & +%4 politika eÅŸiÄŸine uyan sembollerle rebalans alÄ±ÅŸ/satÄ±ÅŸ planÄ± Ã¼retmek; sentinel/risk durumunda reduce-only moduna geÃ§erek gÃ¼venli daraltma yapabilmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; analytics (expectedMovePct, R) kapanmÄ±ÅŸ veriden gelmeli (VIVO-01/GB).

Politika: minTargetPct â‰¥ +%4 ve whitelist dÄ±ÅŸÄ± sembol rebalansa alÄ±nmaz.

Spot payÄ± kuralÄ±: equity â‰¥ equityThresholdUsd ise hedef spotPayÄ± = %30 (Policyâ€™den). AltÄ±nda ise 0â€“%30 arasÄ± esnek (opsiyonel DCA kÃ¼Ã§Ã¼k dilimler).

Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER â†’ yeni alÄ±m yok; yalnÄ±z reduce-only (fazla spotu azalt).

Borsa kurallarÄ±: MIN_NOTIONAL, LOT_SIZE, PRICE_FILTER, PERCENT_PRICE(_BY_SIDE) Ã¶n-kontrolÃ¼ yapÄ±lÄ±r (kesin kuantizasyon VIVO-02).

Slipaj/komisyon muhasebesi: hedef notional Â±%0.2 emniyet payÄ±; komisyon + potansiyel slipaj kadar aÅŸaÄŸÄ± hedefle.

Idempotency: AynÄ± corrId ile ikinci plan yayÄ±nlanmaz.

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/spotCashAllocator.types.ts
export type ISODate = string;
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Level = "GREEN"|"AMBER"|"RED";

export interface Policy {
  whitelist: string[];
  minTargetPct: number;           // â‰¥ 4 (yÃ¼zde)
  spot: { targetPct: number; equityThresholdUsd: number }; // Ã¶r: 0.30 ve 100_000
}

export interface AccountSnapshot {
  asOf: ISODate;
  equityUsd: number;              // toplam (spot+usdt+PNL)
  balances: Array<{ asset:string; free:number; locked:number }>;
}

export interface PriceMap {
  [symbol: string]: number;       // SYMBOL mid/last (USD cinsinden)
}

export interface AnalyticsRow { expectedMovePct:number; R_multiple:number; }
export type AnalyticsMap = Record<string, AnalyticsRow>;

export interface ExchangeRule {
  symbol:string; tickSize:number; stepSize:number; minNotional:number;
  percent?: { up:number; down:number; refMins?:number };
}

export interface RiskState { level:Level; sentinel:Sentinel; }

export interface RebalanceLeg {
  symbol: string;
  side: "BUY"|"SELL";
  notionalUsd: number;            // hedef notional (iÅŸlem bÃ¼yÃ¼klÃ¼ÄŸÃ¼)
  estPrice: number;
  estQty: number;                 // stepSizeâ€™a yaklaÅŸÄ±k yuvarlanmÄ±ÅŸ (kesin VIVO-02'de)
  reason: string;                 // "reach_target", "reduce_only", "trim_overflow"
}

export interface RebalancePlan {
  corrId: string;
  asOf: ISODate;
  targetSpotUsd: number;
  currentSpotUsd: number;
  diffUsd: number;                // + ise alÄ±m, âˆ’ ise satÄ±m ihtiyacÄ±
  legs: RebalanceLeg[];
  execHints: { twapMs:number; iceberg:number; childType:"LIMIT"|"POST_ONLY";
               postOnlyForBuy?: boolean; slices?: number; };
  mode: "NORMAL"|"REDUCE_ONLY";   // sentinelâ€™e gÃ¶re
}

export interface AllocInput {
  policy: Policy;
  account: AccountSnapshot;
  prices: PriceMap;               // {"BTCUSDT":65000,...}
  analytics: AnalyticsMap;        // +%4 ve R eÅŸiÄŸi iÃ§in
  rules: Record<string, ExchangeRule>;
  risk: RiskState;
  // evren ve yÃ¶nlendirme
  candidates?: string[];          // opsiyonel, yoksa policy.whitelist
  dominanceTilt?: Record<string, number>; // {"BTCUSDT":1.2,"ETHUSDT":1.1,...} aÄŸÄ±rlÄ±k Ã§arpanlarÄ±
}

export interface AllocOutput extends RebalancePlan {}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus

Subscribe:

acct.snapshot (bakiye+equity)

risk.state

analytics.map (expectedMovePct, R)

prices.mid (bookTickerâ†’mid)

exchange.rules (tick/step/minNotional)

policy.update

Publish:

vivo.spot.rebalance (RebalancePlan)

ops.actions.suggest (VIVO-02â€™nin child order Ã¼retmesi iÃ§in Ã¶neri paket)

audit.log (hedef vs mevcut vs neden)

VaryantlandÄ±rma MantÄ±ÄŸÄ± (Ã¶zet)

targetSpotUsd = equity â‰¥ threshold ? equity * targetPct : equity * (targetPct * 0.5)

currentSpotUsd = âˆ‘(non-USDT spot pozisyon USD)

diffUsd = targetSpotUsd âˆ’ currentSpotUsd

diffUsd > 0 & sentinel NORMAL â†’ BUY ayaklarÄ± (eÅŸit/tilt aÄŸÄ±rlÄ±klarÄ±yla)

diffUsd > 0 & sentinel â‰  NORMAL â†’ bekle (BUY yok; plan REDUCE_ONLY)

diffUsd < 0 â†’ SELL ayaklarÄ± (reduce-only)

SeÃ§im filtresi: sadece whitelist âˆ© candidates ve expectedMovePct â‰¥ minTargetPct ve R â‰¥ 1.2.

AÄŸÄ±rlÄ±k daÄŸÄ±tÄ±mÄ±: eÅŸit veya dominanceTilt ile Ã§arpanlanmÄ±ÅŸ normalize paylar.

KÃ¼Ã§Ã¼k parÃ§alar: MIN_NOTIONAL altÄ±na dÃ¼ÅŸen leg â†’ birleÅŸtir veya ele.

Exec hints: AMBER â†’ twapMs +200, iceberg +0.02; BUY iÃ§in postOnlyForBuy=true (cross riskâ€™i azalt).

Kod Ä°skeleti
// vivo/spotCashAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocInput, AllocOutput, RebalanceLeg, RebalancePlan,
  ExchangeRule, StdError
} from "./spotCashAllocator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const sum = (a:number[], z=0)=> a.reduce((x,y)=>x+y, z);

export class SpotCashAllocator extends EventEmitter {
  ver="1.0.0"; src="VIVO-11";
  private seen = new Set<string>();

  attach(){
    bus.on<AllocInput>("vivo.spot.request", (inp)=> this.safeRun(inp));
  }

  safeRun(inp: AllocInput){
    const out = this.run(inp);
    if ("error" in (out as any)) {
      logger.error(out, "VIVO-11 failed");
    } else {
      const plan = out as AllocOutput;
      bus.emit<AllocOutput>("vivo.spot.rebalance", plan);
      bus.emit("ops.actions.suggest", this.toOpsActions(plan));
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ target:plan.targetSpotUsd, current:plan.currentSpotUsd, diff:plan.diffUsd, legs:plan.legs.length }});
    }
  }

  run(inp: AllocInput): AllocOutput | { error: StdError } {
    try{
      const v = this.validate(inp); if (v) return this.err("VALIDATION_ERROR", v);

      const now = new Date().toISOString();
      const corrId = `spot-${Date.now()}`;
      if (this.seen.has(corrId)) return this.err("IDEMPOTENT","duplicate corrId");
      this.seen.add(corrId);

      const wl = new Set((inp.candidates && inp.candidates.length? inp.candidates: inp.policy.whitelist));
      const prices = inp.prices;

      // 1) Hedef spot
      const threshold = inp.policy.spot.equityThresholdUsd;
      const basePct   = inp.policy.spot.targetPct;
      const targetPct = inp.account.equityUsd >= threshold ? basePct : basePct*0.5;
      const targetSpotUsd = Math.round(inp.account.equityUsd * targetPct);

      // 2) Mevcut spot USD
      const isStable = (a:string)=> a==="USDT" || a==="BUSD" || a==="FDUSD" || a==="USDC";
      const spotAssets = inp.account.balances.filter(b=> !isStable(b.asset));
      let currentSpotUsd = 0;
      for (const b of spotAssets){
        const sym = `${b.asset}USDT`;
        const px = prices[sym] ?? 0;
        currentSpotUsd += px * (b.free + b.locked);
      }
      currentSpotUsd = Math.round(currentSpotUsd);

      const diffUsd = Math.round(targetSpotUsd - currentSpotUsd);
      const mode = (inp.risk.sentinel==="NORMAL") ? "NORMAL" : "REDUCE_ONLY";

      // 3) Uygun semboller (politika + analytics)
      const pool = Array.from(wl).filter(s=>{
        const an = inp.analytics[s];
        return !!an && an.expectedMovePct >= inp.policy.minTargetPct && (an.R_multiple??0) >= 1.2;
      });

      // 4) AÄŸÄ±rlÄ±klar
      const weights = this.normalizeWeights(pool, inp.dominanceTilt);

      // 5) Leg Ã¼retimi
      const legs: RebalanceLeg[] = [];
      if (diffUsd > 0 && mode==="NORMAL"){
        // BUY paylaÅŸtÄ±r
        for (const s of pool){
          const alloc = Math.max(0, Math.round(diffUsd * (weights[s]||0)));
          if (alloc<=0) continue;
          const leg = this.mkLeg("BUY", s, alloc, prices[s], inp.rules[s], "reach_target");
          if (leg) legs.push(leg);
        }
      } else if (diffUsd < 0) {
        // SELL: en bÃ¼yÃ¼k USD deÄŸerli varlÄ±klardan baÅŸlayarak azalt
        const valued = spotAssets
          .map(b=>({ symbol:`${b.asset}USDT`, usd:(prices[`${b.asset}USDT`]||0)*(b.free+b.locked), qty:(b.free+b.locked) }))
          .filter(x=> wl.has(x.symbol));
        valued.sort((a,b)=>b.usd-a.usd);

        let remain = Math.abs(diffUsd);
        for (const v of valued){
          if (remain<=0) break;
          const cut = Math.min(v.usd, remain);
          const leg = this.mkLeg("SELL", v.symbol, Math.round(cut), prices[v.symbol], inp.rules[v.symbol], "reduce_only");
          if (leg){ legs.push(leg); remain -= cut; }
        }
      }
      // MIN_NOTIONAL altÄ±ndaki parÃ§alarÄ± ele
      const filtered = legs.filter(l=> l.notionalUsd >= (inp.rules[l.symbol]?.minNotional ?? 10));

      // 6) Exec ipuÃ§larÄ± (AMBER â†’ korumacÄ±)
      const hints = {
        twapMs: (inp.risk.level==="AMBER") ? 1600 : 1200,
        iceberg: (inp.risk.level==="AMBER") ? 0.16 : 0.12,
        childType: "LIMIT" as const,
        postOnlyForBuy: true,
        slices: Math.min(10, Math.max(2, Math.floor(filtered.length/2)+2))
      };

      const plan: RebalancePlan = {
        corrId, asOf: now,
        targetSpotUsd, currentSpotUsd, diffUsd,
        legs: filtered,
        execHints: hints,
        mode
      };
      return plan;

    } catch(e:any){
      return this.err("ALLOC_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private mkLeg(side:"BUY"|"SELL", symbol:string, notional:number, price:number|undefined, rule:ExchangeRule|undefined, reason:string): RebalanceLeg | null {
    if (!price || !rule) return null;
    const qty = Math.floor((notional / price) / rule.stepSize) * rule.stepSize;
    if (qty <= 0) return null;
    return { symbol, side, notionalUsd:notional, estPrice:price, estQty:qty, reason };
  }

  private normalizeWeights(pool:string[], tilt?:Record<string,number>){
    if (!pool.length) return {} as Record<string,number>;
    const raw = pool.map(s=> Math.max(0, tilt?.[s] ?? 1));
    const tot = sum(raw, 0) || 1;
    const out: Record<string,number> = {};
    pool.forEach((s,i)=> out[s] = raw[i]/tot);
    return out;
  }

  private validate(x: AllocInput): string | null {
    if (!x?.policy || !x?.account || !x?.prices || !x?.analytics || !x?.rules || !x?.risk) return "missing fields";
    if ((x.policy.minTargetPct??0) < 4) return "policy.minTargetPct must be â‰¥ 4";
    if (!Array.isArray(x.account.balances)) return "account.balances invalid";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e }});
    return { error: e };
  }

  private toOpsActions(plan: RebalancePlan){
    // VIVO-02â€™nin Ã§ocuk emir Ã¼retmesi iÃ§in minimal Ã¶neri formatÄ±
    const children = plan.legs.map(l=>({
      symbol:l.symbol,
      side:l.side,
      type: plan.execHints.childType,
      qty:l.estQty,
      reduceOnly: (plan.mode==="REDUCE_ONLY" || l.side==="SELL") ? true : false,
      postOnly: (l.side==="BUY" && plan.execHints.postOnlyForBuy) ? true : false,
      meta:{ twapMs:plan.execHints.twapMs, iceberg:plan.execHints.iceberg, slices:plan.execHints.slices }
    }));
    return { asOf:plan.asOf, planId:"C", children, comments:[`spot target ${plan.targetSpotUsd} / diff ${plan.diffUsd}`] };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/spotCashAllocator.test.ts
import { describe,it,expect } from "vitest";
import { SpotCashAllocator } from "../spotCashAllocator";
import type { AllocInput } from "../spotCashAllocator.types";

const base: AllocInput = {
  policy: { whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct:4,
            spot:{ targetPct:0.30, equityThresholdUsd:100_000 } },
  account: { asOf:new Date().toISOString(), equityUsd:120_000,
             balances:[ {asset:"USDT", free:70_000, locked:0}, {asset:"BTC", free:0.2, locked:0}, {asset:"ETH", free:1.0, locked:0} ] },
  prices: { BTCUSDT:65000, ETHUSDT:3000, OPUSDT:6.0, USDTUSDT:1 },
  analytics: { BTCUSDT:{ expectedMovePct:5, R_multiple:1.3 }, ETHUSDT:{ expectedMovePct:6, R_multiple:1.25 }, OPUSDT:{ expectedMovePct:7, R_multiple:1.4 } },
  rules: { BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.0001, minNotional:10 },
           ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001,  minNotional:10 },
           OPUSDT:{  symbol:"OPUSDT",  tickSize:0.001,stepSize:0.1,    minNotional:10 } },
  risk: { level:"GREEN", sentinel:"NORMAL" },
  dominanceTilt: { BTCUSDT:1.2, ETHUSDT:1.0, OPUSDT:0.8 }
};

describe("VIVO-11 spotCashAllocator", ()=>{
  it("builds BUY legs to reach 30% spot when equity â‰¥ threshold", ()=>{
    const alloc = new SpotCashAllocator();
    const out:any = alloc.run(base);
    expect(out.targetSpotUsd).toBe(36000); // 120k * 0.30
    expect(out.diffUsd).toBeGreaterThan(0);
    expect(out.legs.some((l:any)=>l.side==="BUY")).toBe(true);
  });

  it("switches to reduce-only under sentinel", ()=>{
    const alloc = new SpotCashAllocator();
    const inp = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = alloc.run(inp);
    // diff>0 olsa bile BUY Ã¼retmemeli
    expect(out.mode).toBe("REDUCE_ONLY");
    expect(out.legs.every((l:any)=>l.side==="SELL")).toBe(true);
  });

  it("filters symbols by +%4 and whitelist", ()=>{
    const alloc = new SpotCashAllocator();
    const inp = structuredClone(base);
    // ETHâ€™i uygunsuz yap
    inp.analytics.ETHUSDT.expectedMovePct = 3.0;
    const out:any = alloc.run(inp);
    // ETH leg sayÄ±sÄ± azalmalÄ± veya sÄ±fÄ±r olmalÄ±
    expect(out.legs.filter((l:any)=>l.symbol==="ETHUSDT").length).toBe(0);
  });
});

Entegrasyon AkÄ±ÅŸÄ±

acct.snapshot, prices.mid, analytics.map, exchange.rules, risk.state, policy.update olaylarÄ± gÃ¼ncelken; vivo.spot.request tetiklenir.

VIVO-11 rebalans planÄ±nÄ± Ã¼retir â†’ vivo.spot.rebalance ve VIVO-02 iÃ§in ops.actions.suggest.

VIVO-02 Ã§ocuk emirleri (TWAP/iceberg/post-only) kesinleÅŸtirir; planFeasibilityChecker (VIVO-06) son kontrol.

GB-22/36 TCA sonuÃ§larÄ± â†’ VIVO-09 uplift & VIVO-04 hafÄ±za aÄŸÄ±rlÄ±klarÄ± gÃ¼nceller.
_________________________________________________________________________________________________________________
tamam reis â€” birleÅŸik (V2+V3) standardÄ±yla VIVO-12 Â· sessionPacingPlanner.tsâ€™Ä± Ã§Ä±karÄ±yorum. Bu modÃ¼l; likidite/vol rejimi, risk/sentinel ve canlÄ± TCA verisine gÃ¶re seans bazlÄ± iÅŸlem yoÄŸunluÄŸu ve risk pacing planÄ± Ã¼retir. VIVO-02â€™ye â€œkaÃ§ yeni pozisyon / dakika baÅŸÄ±na kaÃ§ child / risk bÃ¼tÃ§esi / slipaj toleransÄ±â€ gibi kotalarÄ± gÃ¶nderir; VIVO-03â€™te kart olarak gÃ¶sterilir.

VIVO-12 Â· sessionPacingPlanner.ts

AmaÃ§ (tek cÃ¼mle):
Asiaâ€“EUâ€“US seanslarÄ±nda ve dÃ¼ÅŸÃ¼k likidite saatlerinde iÅŸlem frekansÄ± ve risk bÃ¼tÃ§esini dinamik kotalarla dÃ¼zenleyip, slipaj-ÅŸok anlarÄ±nda yavaÅŸlat/stop verebilen deterministik bir pacing katmanÄ± Ã¼retmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok. YalnÄ±z kapanmÄ±ÅŸ barlardan gelen vol/ATR; canlÄ± yÃ¼rÃ¼tme metrikleri (spread, depth, WS lag) anlÄ±k.

Risk/Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER â†’ yeni pozisyon kota=0, yalnÄ±z reduce-only.

Likidite filtresi: avg spreadâ†‘, L2 depthâ†“, WS lagâ†‘ ise kota lineer dÃ¼ÅŸer.

TCA geri besleme: realized slipaj/mark-out kÃ¶tÃ¼leÅŸirse toleransâ†“ ve kotaâ†“.

Rate limit uyumu: child-per-minute, REQUEST_WEIGHT ve ORDERS limitleri aÅŸÄ±lmayacak.

Overfit korumasÄ±: sabit eÅŸik yok; Ã¼st/alt bant + EWMA ile tepki ver.

ArayÃ¼zler (TypeScript)
// vivo/sessionPacingPlanner.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface SessionWindow {
  id: "ASIA"|"EU"|"US"|"LOW_LIQ";
  startUtc: string;   // "00:00"
  endUtc:   string;   // "08:00"
  weight: number;     // 0..1 temel likidite katsayÄ±sÄ± (Ã¶rn: EU=1, ASIA=0.8, LOW_LIQ=0.4)
}

export interface PacingPolicy {
  baseMaxNewPositions: number;  // seans baÅŸÄ±
  baseChildPerMin: number;      // dakikada child emir Ã¼st sÄ±nÄ±rÄ±
  baseRiskBudgetUsd: number;    // seans baÅŸÄ± risk bÃ¼tÃ§esi
  slipBpSoft: number;           // yumuÅŸak slipaj tavanÄ± (bps)
  slipBpHard: number;           // sert tavan; aÅŸÄ±lÄ±rsa slowdown/stop
  markoutBp5sSoft: number;      // 5s mark-out yumuÅŸak eÅŸik
  ewmaAlpha: number;            // 0.05..0.3
}

export interface LiquidityMetrics {
  asOf: string;
  wsLagMs: number;                 // WS consumer gecikmesi
  avgSpreadBp: number;             // whitelist ortalama
  l2DepthUsd: number;              // top-of-bookÂ±N price toplam
  msgRatePerSec: number;           // diff stream hÄ±zÄ±
}

export interface TcaSnapshot {
  asOf: string;
  slipBpEWMA: number;              // realized bps (EWMA)
  markoutBp5sEWMA: number;         // 5s mark-out (EWMA)
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface RateLimitBudget {
  // borsa limitlerini aÅŸmamak iÃ§in muhafazakÃ¢r pay
  requestWeightPerMin: number;   // Ã¶r: 4800 (6000 limitin %80â€™i)
  ordersPer10s: number;          // Ã¶r: 80 (limit 100â€™Ã¼n %80â€™i)
}

export interface PacingInput {
  nowIso: string;
  sessionWindows: SessionWindow[];
  policy: PacingPolicy;
  risk: RiskState;
  liq: LiquidityMetrics;
  tca: TcaSnapshot;
  rate: RateLimitBudget;
}

export interface PacingPlan {
  asOf: string;
  sessionId: SessionWindow["id"];
  factors: { session:number; liq:number; risk:number; tca:number };
  maxNewPositions: number;
  maxChildPerMin: number;
  riskBudgetUsd: number;
  slipSoftBp: number;
  slipHardBp: number;
  reduceOnly: boolean;
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: risk.state, gb.liquidity.metrics, gb.tca.summary, rate.limit.budget, clock.tick1m.

Publish: vivo.pacing.plan (PacingPlan), audit.log.

Pacing mantÄ±ÄŸÄ± (Ã¶zet)

Toplam katsayÄ± = session Ã— liq Ã— risk Ã— tca, her biri 0..1.

session: aktif pencerenin weight.

liq: spreadâ†‘ (kÃ¶tÃ¼), depthâ†“, wsLagâ†‘ â†’ 1â€™den aÅŸaÄŸÄ± skala (Ã¶rn. 0.4â€“1 arasÄ±).

risk: GREEN=1, AMBER=0.7, RED=0.4, sentinelâ‰ NORMAL â†’ 0.0 ve reduceOnly=true.

tca: slipEWMA ve markoutEWMA soft bandÄ± aÅŸarsa 0.6; hard band aÅŸarsa slowdown/stop (0.2/0.0).

Kota = policy taban Ã— toplam katsayÄ±; rate limit koruma:

maxChildPerMin â‰¤ requestWeightPerMin ve ordersPer10sâ€™den tÃ¼retilen muhafazakÃ¢r Ã¼st sÄ±nÄ±r.

Kod Ä°skeleti
// vivo/sessionPacingPlanner.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  PacingInput, PacingPlan, SessionWindow, StdError
} from "./sessionPacingPlanner.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const toMin = (iso:string)=> new Date(iso).toISOString().slice(11,16); // "HH:MM" UTC

export class SessionPacingPlanner extends EventEmitter {
  ver="1.0.0"; src="VIVO-12";
  private last:PacingInput | null = null;

  attach(){
    bus.on<PacingInput>("vivo.pacing.input", (x)=> this.safeRun(x));
    // periyodik tetik (1 dakikada bir yeniden Ã¼ret)
    bus.on("clock.tick1m", ()=> { if (this.last) this.safeRun(this.last); });
  }

  safeRun(x:PacingInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-12 failed");
    } else {
      const plan = res as PacingPlan;
      bus.emit<PacingPlan>("vivo.pacing.plan", plan);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ session:plan.sessionId, maxNew:plan.maxNewPositions, childPerMin:plan.maxChildPerMin, reduceOnly:plan.reduceOnly }});
      this.last = x;
    }
  }

  run(x:PacingInput): PacingPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);

      const session = this.pickSession(x.nowIso, x.sessionWindows);
      const fSession = session.weight;

      // likidite faktÃ¶rÃ¼ (0.4..1): spreadâ†‘, depthâ†“, wsLagâ†‘ â†’ dÃ¼ÅŸÃ¼r
      const fLiq = this.liqFactor(x);

      // risk/sentinel faktÃ¶rÃ¼
      const { factor: fRisk, reduceOnly } = this.riskFactor(x);

      // TCA faktÃ¶rÃ¼ (slip/markout)
      const fTca = this.tcaFactor(x);

      const factor = clamp(fSession * fLiq * fRisk * fTca, 0, 1);

      // taban kotalar
      const baseNew = x.policy.baseMaxNewPositions;
      const baseChild = x.policy.baseChildPerMin;
      const baseRisk = x.policy.baseRiskBudgetUsd;

      // rate limit koruma: child-per-min Ã¼st sÄ±nÄ±rÄ±
      const rlChildCap = Math.floor(Math.min(
        x.rate.requestWeightPerMin * 0.9, // muhafazakÃ¢r
        x.rate.ordersPer10s * 6 * 0.9     // 10s pencereden dakikaya
      ));

      const plan:PacingPlan = {
        asOf: new Date().toISOString(),
        sessionId: session.id,
        factors:{ session:fSession, liq:fLiq, risk:fRisk, tca:fTca },
        maxNewPositions: Math.max( reduceOnly ? 0 : Math.floor(baseNew * factor), 0 ),
        maxChildPerMin: Math.max( reduceOnly ? 5 : Math.floor(baseChild * factor), 0 ), // reduceOnlyâ€™da kÃ¼Ã§Ã¼k bir teknik limit bÄ±rak
        riskBudgetUsd: Math.max( reduceOnly ? Math.floor(baseRisk*0.25) : Math.floor(baseRisk * factor), 0 ),
        slipSoftBp: Math.round(x.policy.slipBpSoft * (1/fTca)), // kÃ¶tÃ¼ TCAâ€™da daha sÄ±kÄ±
        slipHardBp: x.policy.slipBpHard,
        reduceOnly,
        notes:[]
      };

      // rate limit Ã¼st sÄ±nÄ±rÄ±na uygula
      plan.maxChildPerMin = Math.min(plan.maxChildPerMin, rlChildCap);

      // notlar
      if (reduceOnly) plan.notes?.push("sentinel aktif: yeni pozisyon yok; reduce-only");
      if (fLiq<0.7)   plan.notes?.push("likidite zayÄ±f: kota dÃ¼ÅŸÃ¼rÃ¼ldÃ¼");
      if (fTca<0.7)   plan.notes?.push("TCA kÃ¶tÃ¼: slipaj/mark-out nedeniyle yavaÅŸlatÄ±ldÄ±");

      return plan;

    } catch (e:any){
      return this.err("PACING_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private pickSession(nowIso:string, windows:SessionWindow[]): SessionWindow {
    const hhmm = toMin(nowIso); // UTC HH:MM
    const asMin = (s:string)=> Number(s.slice(0,2))*60 + Number(s.slice(3,5));
    const nowM = asMin(hhmm);

    // kapsayan pencere(ler)i bul; Ã§akÄ±ÅŸma varsa weight en yÃ¼ksek olanÄ± seÃ§
    const cand = windows.filter(w=>{
      const a=asMin(w.startUtc), b=asMin(w.endUtc);
      return a<=b ? (nowM>=a && nowM<b) : (nowM>=a || nowM<b); // gece devri
    });
    if (cand.length===0) return { id:"LOW_LIQ", startUtc:"00:00", endUtc:"23:59", weight:0.5 };
    return cand.sort((p,q)=> q.weight - p.weight)[0];
  }

  private liqFactor(x:PacingInput){
    // normalize: spread 2â€“20bp â†’ 1..0.5, depth 50kâ€“1M â†’ 0.5..1, wsLag 0â€“400ms â†’ 1..0.6
    const s = clamp(1 - (x.liq.avgSpreadBp-2)/(20-2)*0.5, 0.5, 1);
    const d = clamp((x.liq.l2DepthUsd-50_000)/(1_000_000-50_000), 0, 1)*0.5 + 0.5;
    const l = clamp(1 - (x.liq.wsLagMs/400)*0.4, 0.6, 1);
    return clamp(s * d * l, 0.4, 1);
  }

  private riskFactor(x:PacingInput){
    let f = 1, reduceOnly = false;
    if (x.risk.sentinel!=="NORMAL"){ f = 0; reduceOnly = true; }
    else if (x.risk.level==="RED"){ f = 0.4; }
    else if (x.risk.level==="AMBER"){ f = 0.7; }
    return { factor:f, reduceOnly };
  }

  private tcaFactor(x:PacingInput){
    let f = 1;
    if (x.tca.slipBpEWMA > x.policy.slipBpHard || x.tca.markoutBp5sEWMA > x.policy.markoutBp5sSoft*2){
      f = 0.2; // neredeyse stop
    } else if (x.tca.slipBpEWMA > x.policy.slipBpSoft || x.tca.markoutBp5sEWMA > x.policy.markoutBp5sSoft){
      f = 0.6; // slowdown
    }
    return f;
    }

  private validate(x:PacingInput): string | null {
    if (!x?.policy || !x?.risk || !x?.liq || !x?.tca || !x?.rate) return "missing fields";
    if ((x.policy.ewmaAlpha??0) <= 0 || x.policy.ewmaAlpha > 0.5) return "ewmaAlpha invalid";
    if (!Array.isArray(x.sessionWindows) || x.sessionWindows.length===0) return "session windows missing";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Ã–rnek Konfig (24/7 kriptoda seans pencereleri)
// config/session.windows.ts
export const SESSION_WINDOWS = [
  { id:"ASIA", startUtc:"00:00", endUtc:"08:00", weight:0.8 },
  { id:"EU",   startUtc:"07:00", endUtc:"15:30", weight:1.0 },
  { id:"US",   startUtc:"13:00", endUtc:"21:00", weight:0.95 },
  { id:"LOW_LIQ", startUtc:"21:00", endUtc:"00:00", weight:0.6 } // gece geÃ§ saatler
];

Test Ä°skeleti (Vitest)
// vivo/__tests__/sessionPacingPlanner.test.ts
import { describe,it,expect } from "vitest";
import { SessionPacingPlanner } from "../sessionPacingPlanner";

const base = {
  nowIso: new Date(Date.UTC(2025,0,1,12,0,0)).toISOString(), // 12:00 UTC
  sessionWindows: [
    { id:"EU", startUtc:"07:00", endUtc:"15:30", weight:1.0 },
    { id:"US", startUtc:"13:00", endUtc:"21:00", weight:0.95 },
    { id:"ASIA", startUtc:"00:00", endUtc:"08:00", weight:0.8 }
  ],
  policy:{ baseMaxNewPositions:12, baseChildPerMin:90, baseRiskBudgetUsd:100_000,
    slipBpSoft:8, slipBpHard:20, markoutBp5sSoft:6, ewmaAlpha:0.15 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" },
  liq:{ asOf:new Date().toISOString(), wsLagMs:120, avgSpreadBp:5, l2DepthUsd:300_000, msgRatePerSec:800 },
  tca:{ asOf:new Date().toISOString(), slipBpEWMA:6, markoutBp5sEWMA:4 },
  rate:{ requestWeightPerMin:4800, ordersPer10s:80 }
};

describe("VIVO-12 sessionPacingPlanner", ()=>{
  it("produces scaled quotas under AMBER risk", ()=>{
    const m = new SessionPacingPlanner();
    const out:any = m.run(base as any);
    expect(out.sessionId).toBe("EU");
    expect(out.maxNewPositions).toBeGreaterThan(0);
    expect(out.maxChildPerMin).toBeGreaterThan(0);
  });

  it("forces reduce-only when sentinel active", ()=>{
    const m = new SessionPacingPlanner();
    const inp:any = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = m.run(inp);
    expect(out.reduceOnly).toBe(true);
    expect(out.maxNewPositions).toBe(0);
  });

  it("slowdowns when TCA is bad", ()=>{
    const m = new SessionPacingPlanner();
    const inp:any = structuredClone(base);
    inp.tca.slipBpEWMA = 12; // soft Ã¼stÃ¼
    const out:any = m.run(inp);
    expect(out.factors.tca).toBeLessThan(1);
  });
});

Entegrasyon AkÄ±ÅŸÄ±

Aggregator per dakika vivo.pacing.input (risk.state, liq.metrics, tca.summary, rate.budget ile).

VIVO-12 vivo.pacing.plan yayÄ±nlar â†’ VIVO-02 emir Ã¼retirken kotalara uyar (child/dakika, yeni pozisyon sayÄ±sÄ±, risk bÃ¼tÃ§esi, slip toleransÄ±).

VIVO-03 kartta â€œSeans: EU | maxNew=â€¦ | child/min=â€¦ | reduceOnly=â€¦â€ Ã¶zetini gÃ¶sterir.

GB-22/36 sonuÃ§landÄ±kÃ§a TCA EWMA gÃ¼ncellenir; bir sonraki dakikada pacing otomatik adaptasyon saÄŸlar.
_________________________________________________________________________________________________________________
VIVO-13 Â· riskBudgetAllocator.ts

AmaÃ§ (tek cÃ¼mle):
Seans bazÄ±nda tanÄ±mlÄ± risk bÃ¼tÃ§esini, canlÄ± edge (PF/hit/R), volatilite ve korrelasyona gÃ¶re adil, emniyetli ve yÃ¼rÃ¼tÃ¼lebilir ÅŸekilde strateji/cluster/simgelere daÄŸÄ±tmak.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; yalnÄ±z kapanmÄ±ÅŸ bar/son TCA (GB-22/36), pace (VIVO-12), portfÃ¶y ve borsa kurallarÄ± kullanÄ±lÄ±r.

Sentinel: SLOWDOWN/HALT/CIRCUIT_BREAKER â†’ yeni risk 0; yalnÄ±z reduce-only tahsis (mevcut pozisyon kÃ¼Ã§Ã¼ltme Ã¶nerisi).

Binance filtreleri: PRICE_FILTER, PERCENT_PRICE(_BY_SIDE), LOT_SIZE, MIN/NOTIONAL, MAX_POSITION.

Kelly-light: Â¼-Kelly tavanÄ±; seri kayÄ±pta (LIVIA) risk damping (Ã¶rn. Ã—0.5).

Politika: whitelist ve minTargetPct â‰¥ +%4 eÅŸiÄŸi; altÄ± kalan simgeler tahsisten Ã§Ä±karÄ±lÄ±r.

EÅŸzamanlÄ±lÄ±k/Idempotency: Tek corrId iÃ§inde bir tahsis planÄ±; aynÄ± corr tekrarlanmaz.

ArayÃ¼zler (TypeScript)
// vivo/riskBudgetAllocator.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface PacingPlan {
  asOf: string;
  sessionId: "ASIA"|"EU"|"US"|"LOW_LIQ";
  maxNewPositions: number;
  riskBudgetUsd: number;         // seanslÄ±k risk bÃ¼tÃ§esi (VIVO-12)
  reduceOnly: boolean;
}

export interface PolicyAlloc {
  whitelist: string[];
  minTargetPct: number;          // â‰¥ +4
  maxPerSymbolRiskPct: number;   // equity baÅŸÄ±na risk tavanÄ± (Ã¶rn. 0.8%)
  maxPerClusterRiskPct: number;  // equity baÅŸÄ±na cluster tavanÄ± (Ã¶rn. 2.5%)
  kellyLightFactor: number;      // 0.25 (Â¼ Kelly)
}

export interface PortfolioSnapshot {
  asOf: string;
  equityUsd: number;
  spotUsd: number;
  perpsNetUsd: number;
  exposureUsdBySymbol: Record<string, number>;   // mevcut maruz kalÄ±m (mutlak)
}

export interface TcaLite {
  slipBpEWMA: number;
  markoutBp5sEWMA: number;
}

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
  lossStreak?: number;           // Ã¼st Ã¼ste SL sayÄ±sÄ± (LIVIA bildirir)
}

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  status?: "TRADING"|"HALT"|"BREAK";
}

export interface BookTicker { symbol:string; bid:number; ask:number; mid:number; asOf:string; }

/** Edge/Vol giriÅŸleri (Grafik Beyni + Denetim AsistanÄ±) */
export interface SymbolStat {
  symbol: string;
  cluster: string;               // Ã¶r: "breakout", "meanreversion", "trend"
  pf: number;                    // profit factor (â‰¤ 3 ile clamp)
  hit: number;                   // 0..1
  avgR: number;                  // ortalama R (kÃ¢r/zarar oranÄ±, negatifte clamp)
  volAtrPct: number;             // ATR/Price (%)
  stopFrac: number;              // planlanan SL uzaklÄ±ÄŸÄ± (fiyatÄ±n %â€™si, Ã¶r: 0.008)
}
export interface CorrelationMatrix {
  // sembol bazlÄ± korelasyon (âˆ’1..1), simetrik, diyagonal 1
  symbols: string[];
  rho: number[][];
}

export interface AllocatorInput {
  corrId: string;
  pacing: PacingPlan;
  policy: PolicyAlloc;
  portfolio: PortfolioSnapshot;
  tca: TcaLite;
  risk: RiskState;
  stats: SymbolStat[];                  // yalnÄ±z whitelist iÃ§i ve uygun sinyaller
  corr: CorrelationMatrix;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
}

export interface RiskLeg {
  symbol: string;
  cluster: string;
  targetRiskUsd: number;               // $ risk (SLâ€™e kadar kayÄ±p)
  estNotionalUsd: number;              // tahmini notional (risk/stopFrac)
  kellyCapUsd: number;                 // Kelly-light tavanÄ±
  reasons: string[];
}

export interface ClusterSum {
  cluster: string;
  riskUsd: number;
}

export interface RiskAllocPlan {
  asOf: string;
  sessionId: PacingPlan["sessionId"];
  corrId: string;
  reduceOnly: boolean;
  totalRiskUsd: number;                // fiilen daÄŸÄ±tÄ±lan risk
  legs: RiskLeg[];
  byCluster: ClusterSum[];
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe: vivo.pacing.plan, portfolio.snapshot, policy.alloc, gb.tca.summary, risk.state, gb.stats.edgevol, gb.corr.matrix, ex.rules, ex.tickers.

Publish: vivo.risk.alloc.plan (RiskAllocPlan), vivo.risk.alloc.delta (mevcut maruziyet â†’ hedef farkÄ±), audit.log.

Tahsis HeuristiÄŸi (Ã¶zet)

Uygunluk filtresi: status=TRADING, whitelist, minTargetPct â‰¥ +%4 (statlar bu barajÄ± geÃ§miÅŸ olmalÄ±).

Edge skoru:

ğ‘’
ğ‘‘
ğ‘”
ğ‘’
ğ‘–
=
ğ‘
ğ‘™
ğ‘
ğ‘š
ğ‘
(
ğ‘ƒ
ğ¹
ğ‘–
,
1
,
3
)
Ã—
ğ‘
ğ‘™
ğ‘
ğ‘š
ğ‘
(
â„
ğ‘–
ğ‘¡
ğ‘–
,
0.35
,
0.75
)
Ã—
ğ‘
ğ‘™
ğ‘
ğ‘š
ğ‘
(
ğ‘
ğ‘£
ğ‘”
ğ‘…
ğ‘–
,
0.2
,
2
)
edge
i
	â€‹

=clamp(PF
i
	â€‹

,1,3)Ã—clamp(hit
i
	â€‹

,0.35,0.75)Ã—clamp(avgR
i
	â€‹

,0.2,2)

Vol penalizasyonu: volPenalty_i = 1 / sqrt(1 + (volAtrPct_i / v0)^2) (v0 â‰ˆ 2.5).

Korrelasyon indirgeme: her sembol iÃ§in

ğ‘
ğ‘œ
ğ‘Ÿ
ğ‘Ÿ
ğ‘ƒ
ğ‘’
ğ‘›
ğ‘
ğ‘™
ğ‘¡
ğ‘¦
ğ‘–
=
1
1
+
âˆ‘
ğ‘—
â‰ 
ğ‘–
ğ‘¤
ğ‘—
ğ‘
ğ‘Ÿ
ğ‘’
â‹…
max
â¡
(
ğœŒ
ğ‘–
ğ‘—
,
0
)
corrPenalty
i
	â€‹

=
1+âˆ‘
j
î€ 
=i
	â€‹

w
j
pre
	â€‹

â‹…max(Ï
ij
	â€‹

,0)
	â€‹

1
	â€‹


(iteratif; Ã¶nce w^{pre} = edgeÃ—volPen ile baÅŸla).

Damping: lossStreak â‰¥ 3 ise tÃ¼m skorlar Ã—0.5 (LIVIA).

Ham aÄŸÄ±rlÄ±k: w_i = edge_i Ã— volPenalty_i Ã— corrPenalty_i, normalize et.

Risk bÃ¼tÃ§esi: risk_i = w_i Ã— pacing.riskBudgetUsd.

Kelly-light tavanÄ±: kellyCap_i = equity Ã— kellyLight Ã— (edge_i / volScale) (basitleÅŸmiÅŸ tavan); risk_i = min(risk_i, kellyCap_i).

Cluster & sembol tavanlarÄ±: â‰¤ maxPerClusterRiskPctÃ—equity ve â‰¤ maxPerSymbolRiskPctÃ—equity.

Notional dÃ¶nÃ¼ÅŸÃ¼mÃ¼: notional_i = risk_i / stopFrac_i. Binance filter/step ile yuvarla; minNotional altÄ±nÄ± dÃ¼ÅŸ.

Kod Ä°skeleti
// vivo/riskBudgetAllocator.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  AllocatorInput, RiskAllocPlan, RiskLeg, StdError, SymbolStat
} from "./riskBudgetAllocator.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=2)=> Number(x.toFixed(n));

export class RiskBudgetAllocator extends EventEmitter {
  ver="1.0.0"; src="VIVO-13";
  private seen = new Set<string>();

  attach(){
    bus.on<AllocatorInput>("vivo.risk.alloc.input", (x)=> this.safeRun(x));
  }

  safeRun(x: AllocatorInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-13 failed");
    } else {
      const plan = res as RiskAllocPlan;
      bus.emit<RiskAllocPlan>("vivo.risk.alloc.plan", plan);
      // delta: hedef notional vs mevcut maruziyet â†’ VIVO-02 iÃ§in rehber
      const delta = this.toDelta(plan, x.portfolio.exposureUsdBySymbol);
      bus.emit("vivo.risk.alloc.delta", delta);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ session:plan.sessionId, totalRisk:plan.totalRiskUsd, legs:plan.legs.length, reduceOnly:plan.reduceOnly }});
    }
  }

  run(x: AllocatorInput): RiskAllocPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      if (this.seen.has(x.corrId)) return this.err("IDEMPOTENT","corrId already allocated",{corrId:x.corrId});
      const asOf = new Date().toISOString();

      // Sentinel â†’ yeni risk yok, reduce-only plan
      if (x.pacing.reduceOnly || x.risk.sentinel!=="NORMAL"){
        const plan: RiskAllocPlan = { asOf, sessionId:x.pacing.sessionId, corrId:x.corrId,
          reduceOnly:true, totalRiskUsd:0, legs:[], byCluster:[], notes:["sentinel/reduce-only"] };
        this.seen.add(x.corrId);
        return plan;
      }

      // 1) uygun semboller
      const ok = this.eligible(x);

      // 2) skorlar
      const preW = ok.map(s=> ({ s, w: this.edgeScore(s) * this.volPenalty(s) }));
      // 3) corr penalty (tek iterasyon pragmatik)
      const withCorr = this.applyCorrPenalty(preW, x);

      // 4) damping (LIVIA)
      const damp = (x.risk.lossStreak ?? 0) >= 3 ? 0.5 : 1;
      for (const r of withCorr) r.w *= damp;

      // normalize
      const sumW = withCorr.reduce((a,b)=>a+b.w,0) || 1;
      const budget = Math.max(0, x.pacing.riskBudgetUsd);
      // 5) risk_i ve tavanlar
      const legs = [] as RiskLeg[];
      const clusterAgg: Record<string, number> = {};
      for (const r of withCorr){
        let riskUsd = budget * (r.w / sumW);
        const kCap = this.kellyCapUsd(r.s, x);
        riskUsd = Math.min(riskUsd, kCap);

        // cluster/ symbol tavanlarÄ±
        const symCap = x.portfolio.equityUsd * x.policy.maxPerSymbolRiskPct;
        const clCap = x.portfolio.equityUsd * x.policy.maxPerClusterRiskPct;
        riskUsd = Math.min(riskUsd, symCap);

        // notional dÃ¶nÃ¼ÅŸÃ¼m
        const px = x.tickers[r.s.symbol]?.mid;
        const rule = x.rules[r.s.symbol];
        if (!px || !rule || rule.status!=="TRADING") continue;

        const estNotional = riskUsd / Math.max(1e-6, r.s.stopFrac) ;
        const fitted = this.fitNotional(estNotional, px, rule);
        if (fitted < rule.minNotional) continue;

        // cluster kÄ±sÄ±tÄ± (post-check)
        const sumCl = (clusterAgg[r.s.cluster] || 0) + riskUsd;
        if (sumCl > clCap) continue;
        clusterAgg[r.s.cluster] = sumCl;

        legs.push({
          symbol:r.s.symbol, cluster:r.s.cluster,
          targetRiskUsd: round(riskUsd), estNotionalUsd: round(fitted),
          kellyCapUsd: round(kCap),
          reasons: this.reasons(r.s)
        });
      }

      const plan: RiskAllocPlan = {
        asOf, sessionId:x.pacing.sessionId, corrId:x.corrId,
        reduceOnly:false,
        totalRiskUsd: round(legs.reduce((a,b)=>a+b.targetRiskUsd,0)),
        legs,
        byCluster: Object.entries(clusterAgg).map(([cluster,riskUsd])=>({ cluster, riskUsd: round(riskUsd) })),
        notes:[]
      };
      this.seen.add(x.corrId);
      return plan;

    } catch (e:any){
      return this.err("ALLOC_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  // --- yardÄ±mcÄ±lar ---

  private eligible(x: AllocatorInput){
    const w = new Set(x.policy.whitelist);
    return x.stats.filter(s=>{
      const ok = w.has(s.symbol) && (x.rules[s.symbol]?.status==="TRADING")
        && (s.stopFrac>0) && isFinite(s.stopFrac);
      return ok;
    });
  }

  private edgeScore(s: SymbolStat){
    const pf = clamp(s.pf, 1, 3);
    const hit = clamp(s.hit, 0.35, 0.75);
    const r = clamp(s.avgR, 0.2, 2);
    return pf * hit * r;
  }

  private volPenalty(s: SymbolStat){
    const v0 = 2.5; // ATR% Ã¶lÃ§eÄŸi
    return 1 / Math.sqrt(1 + Math.pow(s.volAtrPct / v0, 2));
  }

  private applyCorrPenalty(pre: Array<{s:SymbolStat; w:number}>, x: AllocatorInput){
    const idx = new Map(x.corr.symbols.map((k,i)=>[k,i] as const));
    return pre.map(row=>{
      const i = idx.get(row.s.symbol); if (i===undefined) return row;
      let acc = 0;
      for (const other of pre){
        if (other.s.symbol===row.s.symbol) continue;
        const j = idx.get(other.s.symbol); if (j===undefined) continue;
        const rho = x.corr.rho[i][j];
        acc += Math.max(0, rho) * other.w; // yalnÄ±z pozitif korelasyonu cezalandÄ±r
      }
      const corrPenalty = 1 / Math.sqrt(1 + acc);
      return { s:row.s, w: row.w * corrPenalty };
    });
  }

  private kellyCapUsd(s: SymbolStat, x: AllocatorInput){
    // basitleÅŸtirilmiÅŸ Kelly ~ edge / variance; burada edgeScore â‰ˆ getiri beklentisi proxyâ€™si
    const edge = this.edgeScore(s);
    const varScale = Math.max(0.5, s.volAtrPct); // proxy
    const kelly = edge / (varScale*4); // kaba Ã¶lÃ§ek
    const kLight = x.policy.kellyLightFactor; // 0.25
    return Math.max(0, x.portfolio.equityUsd * kelly * kLight);
  }

  private fitNotional(targetUsd:number, px:number, rule:{ stepSize:number } & { minNotional:number }){
    // yalnÄ±z notional ve adÄ±m uyarlamasÄ± (fiyat/qty ayrÄ±ÅŸmasÄ± VIVO-02â€™de yapÄ±lÄ±r)
    // stepSize â†’ qty adÄ±mÄ±; burada yalnÄ±z dolar notionalâ€™Ä± aÅŸaÄŸÄ± yuvarlÄ±yoruz
    const notion = Math.floor(targetUsd / (rule.minNotional)) * rule.minNotional;
    return Math.max(rule.minNotional, Math.min(targetUsd, notion));
  }

  private reasons(s: SymbolStat){
    const arr = [];
    arr.push(`PF=${s.pf.toFixed(2)}`, `hit=${(s.hit*100).toFixed(0)}%`, `avgR=${s.avgR.toFixed(2)}`);
    arr.push(`ATR%=${s.volAtrPct.toFixed(2)}`, `SL=${(s.stopFrac*100).toFixed(2)}%`);
    return arr;
  }

  private toDelta(plan: RiskAllocPlan, current: Record<string,number>){
    // basit delta: hedef notional - mevcut notional (proxy olarak risk/stopFrac yok; VIVO-02 netleÅŸtirir)
    return {
      asOf: plan.asOf,
      corrId: plan.corrId,
      symbols: plan.legs.map(l=>{
        const cur = current[l.symbol] || 0;
        return { symbol:l.symbol, targetNotionalUsd:l.estNotionalUsd, currentUsd:cur, deltaUsd: round(l.estNotionalUsd - cur) };
      })
    };
  }

  private validate(x: AllocatorInput): string | null {
    if (!x?.corrId) return "corrId missing";
    if (!x?.pacing || !x?.portfolio || !x?.policy || !x?.stats || !x?.corr) return "missing fields";
    if ((x.policy.minTargetPct ?? 0) < 4) return "policy.minTargetPct must be â‰¥ 4";
    if (x.portfolio.equityUsd <= 0) return "equity invalid";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/riskBudgetAllocator.test.ts
import { describe,it,expect } from "vitest";
import { RiskBudgetAllocator } from "../riskBudgetAllocator";
import type { AllocatorInput } from "../riskBudgetAllocator.types";

const base: AllocatorInput = {
  corrId:"alloc-1",
  pacing:{ asOf:new Date().toISOString(), sessionId:"EU", maxNewPositions:6, riskBudgetUsd: 25_000, reduceOnly:false },
  policy:{ whitelist:["BTCUSDT","ETHUSDT","OPUSDT"], minTargetPct:4, maxPerSymbolRiskPct:0.008, maxPerClusterRiskPct:0.025, kellyLightFactor:0.25 },
  portfolio:{ asOf:new Date().toISOString(), equityUsd: 200_000, spotUsd: 60_000, perpsNetUsd: 10_000, exposureUsdBySymbol:{ BTCUSDT: 8_000 } },
  tca:{ slipBpEWMA:7, markoutBp5sEWMA:5 },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL", lossStreak:1 },
  stats:[
    { symbol:"BTCUSDT", cluster:"trend", pf:1.6, hit:0.52, avgR:0.45, volAtrPct:2.3, stopFrac:0.01 },
    { symbol:"ETHUSDT", cluster:"breakout", pf:1.4, hit:0.5, avgR:0.5, volAtrPct:2.8, stopFrac:0.012 },
    { symbol:"OPUSDT",  cluster:"meanrev", pf:1.2, hit:0.48, avgR:0.35, volAtrPct:3.5, stopFrac:0.009 }
  ],
  corr:{
    symbols:["BTCUSDT","ETHUSDT","OPUSDT"],
    rho:[
      [1, 0.65, 0.35],
      [0.65, 1, 0.30],
      [0.35, 0.30, 1]
    ]
  },
  rules:{
    BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, status:"TRADING" },
    ETHUSDT:{ symbol:"ETHUSDT", tickSize:0.01, stepSize:0.001, minNotional:10, status:"TRADING" },
    OPUSDT:{ symbol:"OPUSDT", tickSize:0.001, stepSize:1, minNotional:10, status:"TRADING" }
  },
  tickers:{
    BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() },
    ETHUSDT:{ symbol:"ETHUSDT", bid:3000,  ask:3001,  mid:3000.5, asOf:new Date().toISOString() },
    OPUSDT:{ symbol:"OPUSDT", bid:2.5,     ask:2.51,  mid:2.505,  asOf:new Date().toISOString() }
  }
};

describe("VIVO-13 riskBudgetAllocator", ()=>{
  it("allocates positive totalRisk within caps", ()=>{
    const m = new RiskBudgetAllocator();
    const out:any = m.run(base);
    expect(out.totalRiskUsd).toBeGreaterThan(0);
    // symbol tavanÄ±: â‰¤ equity*0.8% = 1600$
    for (const l of out.legs) expect(l.targetRiskUsd).toBeLessThanOrEqual(1600+1e-6);
  });

  it("goes reduce-only under sentinel", ()=>{
    const m = new RiskBudgetAllocator();
    const inp:any = structuredClone(base);
    inp.pacing.reduceOnly = true;
    const out:any = m.run(inp);
    expect(out.reduceOnly).toBe(true);
    expect(out.totalRiskUsd).toBe(0);
  });

  it("is idempotent on corrId", ()=>{
    const m:any = new RiskBudgetAllocator();
    const r1:any = m.run(structuredClone(base));
    const r2:any = m.run(structuredClone(base));
    expect(r2.error.code).toBe("IDEMPOTENT");
  });
});

Entegrasyon AkÄ±ÅŸÄ±

VIVO-12 vivo.pacing.plan â†’ seanslÄ±k riskBudgetUsd.

Grafik Beyni/Denetim gb.stats.edgevol (PF/hit/avgR/ATR%) + gb.corr.matrix.

Aggregator portfolio.snapshot, ex.rules, ex.tickers, risk.state, policy.alloc.

VIVO-13 â†’ vivo.risk.alloc.plan (legs + byCluster) ve vivo.risk.alloc.delta.

VIVO-02 deltaâ€™ya gÃ¶re Ã§ocuk emir planlar (LOT_SIZE, PERCENT_PRICE, TWAP/iceberg, POST_ONLY vs.).

GB-22/36 sonuÃ§landÄ±kÃ§a TCA gÃ¼ncellenir; bir sonraki seans VIVO-13 edge/vol/corr aÄŸÄ±rlÄ±klarÄ±nÄ± otomatik adapt eder.
_________________________________________________________________________________________________________________
VIVO-14 Â· driftGuard.ts
AmaÃ§ (tek cÃ¼mle)

Tahsis edilen hedef notional/risk ile canlÄ± gerÃ§ekleÅŸen maruziyet arasÄ±ndaki sapmayÄ± (drift) dakikalÄ±k dÃ¶ngÃ¼de Ã¶lÃ§mek ve otomatik dÃ¼zeltme eylem planÄ± Ã¼retmek.

GerÃ§ek dÃ¼nya kurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; yalnÄ±z fills, account/position snapshot, bookTicker, rate-limit metrikleri kullanÄ±lÄ±r.

Sentinel â‰  NORMAL â‡’ yeni risk ekleme yok; yalnÄ±z reduce-only trim ve iptal/tÄ±rpan Ã¶nerilir.

Binance filtreleri: PRICE_FILTER, PERCENT_PRICE(_BY_SIDE), LOT_SIZE, MIN/NOTIONAL, MAX_POSITION kontrolÃ¼ yapÄ±lÄ±r.

Drift toleransÄ±: varsayÄ±lan Â±5% (plan bacak hedef notionalâ€™Ä± Ã¼zerinden) + mutlak min $ (Ã¶rn. â‰¥ 25 USDT).

Idempotency: aynÄ± plan corrId + legId iÃ§in tekrar eylem Ã¼retilmez (state tutulur).

Failover: POST_ONLY 3 kez reddedildiyse â‡’ LIMIT (offsetâ†‘) â†’ sÃ¼rede dolmazsa IOC/MARKET (risk kuralÄ± izin verirse).

Pacing/Rate-limit: VIVO-12 kotalarÄ± ve rate budget aÅŸÄ±lmaz; child/min Ã¼st sÄ±nÄ±rÄ± uygulanÄ±r.

ArayÃ¼zler (TypeScript)
// vivo/driftGuard.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";
export type Side     = "BUY"|"SELL";
export type ChildType= "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";

export interface PacingPlan {
  asOf: string;
  sessionId: "ASIA"|"EU"|"US"|"LOW_LIQ";
  maxChildPerMin: number;
  reduceOnly: boolean;
}

export interface RiskAllocPlanLeg {
  symbol: string;
  cluster: string;
  targetRiskUsd: number;
  estNotionalUsd: number;     // hedef notional (VIVO-13)
  reasons: string[];
}

export interface RiskAllocPlan {
  asOf: string;
  sessionId: PacingPlan["sessionId"];
  corrId: string;
  reduceOnly: boolean;
  legs: RiskAllocPlanLeg[];
}

export interface PortfolioExposure {
  asOf: string;
  bySymbolUsd: Record<string, number>; // gerÃ§ekleÅŸen notional proxy (abs)
}

export interface ExecReport {
  // child emirler iÃ§in Ã¶zet rapor (VIVO-02 â†’ router)
  orderId: string;
  symbol: string;
  side: Side;
  childType: ChildType;
  status: "NEW"|"PARTIALLY_FILLED"|"FILLED"|"CANCELED"|"REJECTED"|"EXPIRED";
  reason?: "POST_ONLY_REJECT"|"PERCENT_PRICE"|"INSUFFICIENT_BAL"|"MAX_POSITION"|"UNKNOWN";
  filledNotionalUsd?: number;
  ts: string;
  corrId?: string;
  legId?: string;
}

export interface ExchangeRule {
  symbol:string;
  tickSize:number;
  stepSize:number;
  minNotional:number;
  status?: "TRADING"|"HALT"|"BREAK";
  percent?: { up:number; down:number; refMins?:number };
  maxPositionQty?: number;
}

export interface BookTicker { symbol:string; bid:number; ask:number; mid:number; asOf:string; }

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export interface DriftPolicy {
  driftTolerancePct: number;   // 0.05 = Â±5%
  minActionUsd: number;        // 25
  maxTopUpRetries: number;     // 3
  widenOffsetBps: number;      // +4..8 bps
  iocFailoverMs: number;       // 1200..3000
}

export interface GuardInput {
  plan: RiskAllocPlan;                         // hedefler
  exposure: PortfolioExposure;                 // gerÃ§ekleÅŸen
  pacing: PacingPlan;                          // child/min ve reduceOnly
  risk: RiskState;
  rules: Record<string, ExchangeRule>;
  tickers: Record<string, BookTicker>;
  policy: DriftPolicy;
}

export type ActionKind = "TOP_UP"|"TRIM"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY"|"NOOP";

export interface DriftAction {
  corrId: string;
  legId: string;               // symbol+index
  symbol: string;
  side: Side;                  // hedef yÃ¶n (topUp=plan.side varsayÄ±mÄ±)
  kind: ActionKind;
  deltaNotionalUsd: number;    // tamamlanacak/azaltÄ±lacak dolar
  execHint: {
    childType: ChildType;
    limitOffsetBps: number;
    twapMs: number;
    iceberg: number;
    reduceOnly?: boolean;
    postOnly?: boolean;
  };
  reasons: string[];           // â€œunderfill 12%â€, â€œpost_only_reject x3â€, â€œpercent_price bandâ€
}

export interface DriftPlan {
  asOf: string;
  corrId: string;
  actions: DriftAction[];
  notes?: string[];
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event bus

Subscribe:

vivo.risk.alloc.plan (VIVO-13)

portfolio.exposure (aggregator)

router.exec.report (VIVO-02 yÃ¼rÃ¼tme raporlarÄ±)

vivo.pacing.plan (VIVO-12)

risk.state, ex.rules, ex.tickers

Publish:

vivo.driftguard.plan (DriftPlan)

vivo.driftguard.action (DriftAction) â€” VIVO-02â€™nin Ã§ocuk emir Ã¼retimi iÃ§in

audit.log

MantÄ±k (Ã¶zet)

Plan bacaklarÄ± iÃ§in mevcut maruziyeti oku â†’ delta = targetNotionalUsd - realizedUsd.

|delta| < max(minActionUsd, targetÃ—driftTolerancePct) â‡’ NOOP.

delta>0 â‡’ TOP_UP; delta<0 â‡’ TRIM.

Hata baÄŸlamÄ± (exec reports):

POST_ONLY_REJECT Ã—3 â‡’ CANCEL_REPLACE (LIMIT + offsetâ†‘)

PERCENT_PRICE â‡’ CANCEL_REPLACE (limit price yeniden bant iÃ§ine)

EXPIRED/IOC 2Ã— â‡’ SWITCH_CHILD (LIMITâ†’IOC veya â†’MARKET, risk izin verirse)

WS lagâ†‘ (pacingâ€™dan tÃ¼rev/liq metrikleriyle) â‡’ WAIT_RETRY (kÄ±sa gecikme)

Sentinel â‰  NORMAL â‡’ yalnÄ±z TRIM / CANCEL_REPLACE reduce-only; TOP_UP yok.

Rate limit/pacing â‡’ max actions per minute sÄ±nÄ±rÄ±.

Kod iskeleti
// vivo/driftGuard.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  GuardInput, DriftPlan, DriftAction, StdError, ExecReport, RiskAllocPlanLeg
} from "./driftGuard.types";

const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));
const round = (x:number, n=2)=> Number(x.toFixed(n));

interface LegState {
  retries: number;
  postOnlyRejects: number;
  lastChildType?: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
}

export class DriftGuard extends EventEmitter {
  ver="1.0.0"; src="VIVO-14";
  private legState = new Map<string, LegState>(); // key: corrId|legId

  attach(){
    bus.on<GuardInput>("vivo.drift.input", (x)=> this.safeRun(x));
    bus.on<ExecReport>("router.exec.report", (r)=> this.trackExec(r));
  }

  private key(corrId:string, legId:string){ return `${corrId}|${legId}`; }

  private trackExec(r: ExecReport){
    if (!r?.corrId || !r?.legId) return;
    const k = this.key(r.corrId, r.legId);
    const st = this.legState.get(k) ?? { retries:0, postOnlyRejects:0 };
    st.lastChildType = r.childType;
    if (r.reason==="POST_ONLY_REJECT") st.postOnlyRejects += 1;
    this.legState.set(k, st);
  }

  safeRun(x: GuardInput){
    const res = this.run(x);
    if ("error" in (res as any)) {
      logger.error(res, "VIVO-14 failed");
    } else {
      const plan = res as DriftPlan;
      bus.emit<DriftPlan>("vivo.driftguard.plan", plan);
      for (const a of plan.actions) bus.emit<DriftAction>("vivo.driftguard.action", a);
      bus.emit("audit.log", { asOf:plan.asOf, ver:this.ver, src:this.src,
        payload:{ corrId:plan.corrId, actions:plan.actions.length }});
    }
  }

  run(x: GuardInput): DriftPlan | { error: StdError } {
    try {
      const v = this.validate(x); if (v) return this.err("VALIDATION_ERROR", v);
      const { plan, exposure, pacing, risk, rules, tickers, policy } = x;

      const actions: DriftAction[] = [];
      for (let i=0;i<plan.legs.length;i++){
        const leg = plan.legs[i];
        const legId = `${leg.symbol}#${i}`;
        const realized = Math.abs(exposure.bySymbolUsd[leg.symbol] || 0);
        const target  = Math.abs(leg.estNotionalUsd);
        const delta   = target - realized; // >0 underfill, <0 overfill

        const tol = Math.max(policy.minActionUsd, target * policy.driftTolerancePct);
        if (Math.abs(delta) < tol) continue;

        const rs = rules[leg.symbol]; const tk = tickers[leg.symbol];
        if (!rs || !tk || rs.status!=="TRADING") continue;

        // Sentinel: sadece trim/cancel
        if (risk.sentinel!=="NORMAL" && delta>0) continue;

        const baseHint = this.execHint(pacing, risk);
        const k = this.key(plan.corrId, legId);
        const st = this.legState.get(k) ?? { retries:0, postOnlyRejects:0 };

        // baÄŸlamsal dÃ¼zeltme tÃ¼rÃ¼
        const ctx = this.pickContext(st, rs);
        const kind = this.pickActionKind(delta, ctx, risk);

        const final = this.fitNotional(Math.abs(delta), tk, rs);
        if (final < rs.minNotional) continue;

        const side = delta>0 ? "BUY" : "SELL";
        const reduceOnly = (risk.sentinel!=="NORMAL") || (kind==="TRIM");

        const act: DriftAction = {
          corrId: plan.corrId, legId, symbol: leg.symbol, side,
          kind, deltaNotionalUsd: round(final),
          execHint: { ...baseHint, reduceOnly, postOnly: baseHint.postOnly },
          reasons: this.reasons(delta, tol, ctx, st)
        };

        // failover ayarlarÄ±
        if (ctx==="POST_ONLY_STUCK"){
          act.execHint.childType = "LIMIT";
          act.execHint.limitOffsetBps += x.policy.widenOffsetBps;
          act.reasons.push("switch POST_ONLYâ†’LIMIT + widen");
        } else if (ctx==="PERCENT_BAND"){
          act.kind = "CANCEL_REPLACE";
          act.reasons.push("percent-price band reprice");
        } else if (ctx==="IOC_MARKET"){
          act.execHint.childType = "IOC";
          act.reasons.push("IOC failover");
        }

        // pacing/rate limit: reduceOnlyâ€™da child/min kÃ¼Ã§Ã¼k kalsÄ±n
        // (sert enforcement VIVO-02â€™de)
        actions.push(act);

        // retry sayacÄ±
        st.retries += 1;
        this.legState.set(k, st);
        if (st.retries > policy.maxTopUpRetries && act.kind==="TOP_UP"){
          act.kind = "WAIT_RETRY";
          act.reasons.push("retry cap reached");
        }
      }

      return { asOf:new Date().toISOString(), corrId:plan.corrId, actions };

    } catch (e:any){
      return this.err("DRIFT_EVAL_FAILED", e?.message||"unknown", { stack:e?.stack });
    }
  }

  private pickContext(st: LegState, rs: any): "OK"|"POST_ONLY_STUCK"|"PERCENT_BAND"|"IOC_MARKET" {
    if (st.postOnlyRejects >= 3) return "POST_ONLY_STUCK";
    // Daha geliÅŸmiÅŸ band kontrolÃ¼: rs.percent ve son fiyatlara gÃ¶re yapÄ±labilir
    return "OK";
  }

  private pickActionKind(delta:number, ctx: string, risk: GuardInput["risk"]): "TOP_UP"|"TRIM"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY" {
    if (delta>0) {
      if (risk.sentinel!=="NORMAL") return "WAIT_RETRY";
      if (ctx==="POST_ONLY_STUCK" || ctx==="PERCENT_BAND") return "CANCEL_REPLACE";
      return "TOP_UP";
    } else {
      return "TRIM";
    }
  }

  private execHint(pacing: GuardInput["pacing"], risk: GuardInput["risk"]){
    // pacingâ€™e gÃ¶re Ã§ocuk/dk muhafazakÃ¢r; risk AMBER/REDâ€™de biraz daha yumuÅŸat
    const postOnly = (risk.posture!=="RISK_ON");
    let limitOffsetBps = 6, twapMs = 1200, iceberg = 0.12;
    if (risk.level==="AMBER"){ twapMs += 300; iceberg += 0.02; }
    if (risk.level==="RED"){ twapMs += 600; iceberg += 0.05; }
    return {
      childType: postOnly ? "POST_ONLY" : "LIMIT",
      limitOffsetBps: clamp(limitOffsetBps,0,15),
      twapMs: clamp(twapMs,800,3000),
      iceberg: clamp(iceberg,0.05,0.3),
      postOnly
    };
  }

  private fitNotional(targetUsd:number, t:GuardInput["tickers"][string], r:GuardInput["rules"][string]){
    // Dolar bazlÄ± minNotionalâ€™a ve qty adÄ±mÄ±na gÃ¶re aÅŸaÄŸÄ± yuvarla (detay qty/price VIVO-02â€™de)
    const px = t.mid;
    const qtyRaw = targetUsd / px;
    const qty = Math.floor(qtyRaw / r.stepSize) * r.stepSize;
    const notion = qty * px;
    return notion;
  }

  private reasons(delta:number, tol:number, ctx:string, st:LegState){
    const arr = [];
    arr.push(delta>0 ? `underfill ${(Math.abs(delta)/1).toFixed(2)}$` : `overfill ${(Math.abs(delta)/1).toFixed(2)}$`);
    arr.push(`tolerance ${tol.toFixed(2)}$`);
    if (ctx!=="OK") arr.push(`ctx=${ctx}`);
    if (st.postOnlyRejects) arr.push(`postOnlyRejects=${st.postOnlyRejects}`);
    return arr;
  }

  private validate(x: GuardInput): string | null {
    if (!x?.plan || !x?.exposure || !x?.pacing || !x?.risk || !x?.rules || !x?.tickers || !x?.policy)
      return "missing fields";
    if (!x.plan.corrId) return "plan.corrId missing";
    if (x.policy.driftTolerancePct<=0 || x.policy.driftTolerancePct>0.2) return "driftTolerancePct out of range";
    return null;
  }

  private err(code:string, message:string, details?:any){
    const e = { code, message, details, retriable:false };
    logger.error({ code, details }, message);
    bus.emit("audit.log", { asOf:new Date().toISOString(), ver:this.ver, src:this.src, payload:{ error:e } });
    return { error: e };
  }
}

Test iskeleti (Vitest)
// vivo/__tests__/driftGuard.test.ts
import { describe,it,expect } from "vitest";
import { DriftGuard } from "../driftGuard";
import type { GuardInput } from "../driftGuard.types";

const base: GuardInput = {
  plan:{
    asOf:new Date().toISOString(), sessionId:"EU", corrId:"c-1", reduceOnly:false,
    legs:[ { symbol:"BTCUSDT", cluster:"trend", targetRiskUsd:800, estNotionalUsd: 80_000, reasons:[] } ]
  },
  exposure:{ asOf:new Date().toISOString(), bySymbolUsd:{ BTCUSDT: 70_000 } }, // 10k underfill
  pacing:{ asOf:new Date().toISOString(), sessionId:"EU", maxChildPerMin:80, reduceOnly:false },
  risk:{ level:"AMBER", sentinel:"NORMAL", posture:"NEUTRAL" },
  rules:{ BTCUSDT:{ symbol:"BTCUSDT", tickSize:0.1, stepSize:0.001, minNotional:10, status:"TRADING" } },
  tickers:{ BTCUSDT:{ symbol:"BTCUSDT", bid:65000, ask:65010, mid:65005, asOf:new Date().toISOString() } },
  policy:{ driftTolerancePct:0.05, minActionUsd:25, maxTopUpRetries:3, widenOffsetBps:6, iocFailoverMs:1500 }
};

describe("VIVO-14 driftGuard", ()=>{
  it("creates TOP_UP when underfilled beyond tolerance", ()=>{
    const m = new DriftGuard();
    const out:any = m.run(base);
    expect(out.actions[0].kind).toBe("TOP_UP");
    expect(out.actions[0].symbol).toBe("BTCUSDT");
  });

  it("creates TRIM when overfilled", ()=>{
    const m = new DriftGuard();
    const inp:any = structuredClone(base);
    inp.exposure.bySymbolUsd.BTCUSDT = 95_000; // 15k overfill
    const out:any = m.run(inp);
    expect(out.actions[0].kind).toBe("TRIM");
  });

  it("blocks top-up under sentinel", ()=>{
    const m = new DriftGuard();
    const inp:any = structuredClone(base);
    inp.risk.sentinel = "HALT_PARTIAL";
    const out:any = m.run(inp);
    expect(out.actions.length).toBe(0); // only trim allowed; here delta>0 so no action
  });
});

Entegrasyon akÄ±ÅŸÄ±

VIVO-13 tahsis â†’ vivo.risk.alloc.plan

Aggregator â†’ portfolio.exposure (perps+spot net/abs proxy)

VIVO-02 yÃ¼rÃ¼tme raporlarÄ± â†’ router.exec.report

VIVO-14 drift analizi â†’ vivo.driftguard.plan & vivo.driftguard.action

VIVO-02 bu eylemleri Ã§ocuk emir planÄ±na Ã§evirir (LOT_SIZE, percent-price band, TWAP/POST_ONLY/IOC/MKT)

GB-22/36 TCA/mark-out â†’ VIVO-12 pacing ve diÄŸer katmanlar adaptasyon saÄŸlar
_________________________________________________________________________________________________________________
VIVO-15 Â· operatorPlaybookBridge.ts

AmaÃ§ (tek cÃ¼mle):
UÃ§tan uca sistemin Ã¶nerdiÄŸi tÃ¼m operasyonel aksiyonlarÄ± tek yerde kartlaÅŸtÄ±rÄ±p operatÃ¶rden emin onay almak; onay/ret/partial/timeout kararlarÄ±nÄ± gÃ¼venli ve izlenebilir ÅŸekilde VIVO-02â€™ye iletmek.

GerÃ§ek DÃ¼nya KurallarÄ± (latency-safe)

KapanmamÄ±ÅŸ bar yok; yalnÄ±z eylem/plan Ã¶zetleri, anlÄ±k risk/sentinel ve yÃ¼rÃ¼tme metrikleri kullanÄ±lÄ±r.

Sentinel â‰  NORMAL â†’ operatÃ¶r onayÄ± dahi olsa yeni risk (top-up) bloklanÄ±r; yalnÄ±z reduce-only / trim / iptal Ã¶nerileri kartlaÅŸÄ±r.

Timeout (Ã¶rn. 12 sn): KorumacÄ± Default uygulanÄ±r â†’ yeni risk iÃ§eriyorsa REJECT, reduce-only ise ACCEPT.

Idempotency: her kart cardId ile tekilleÅŸtirilir; aynÄ± cardId+decisionSeq ikinci kez iÅŸlenmez.

Rate-limit/pacing saygÄ±sÄ±: onaylanan aksiyonlar vivo.pacing.plan kotalarÄ±na uymak zorunda (kontrol VIVO-02â€™de tekrar yapÄ±lÄ±r).

Tam izlenebilirlik: tÃ¼m kararlar audit.logâ€™a gider; kart iÃ§eriÄŸi ve seÃ§ilen butonlar kayda alÄ±nÄ±r.

ArayÃ¼zler (TypeScript / JSDoc)
// vivo/operatorPlaybookBridge.types.ts
export type Sentinel = "NORMAL"|"SLOWDOWN"|"HALT_PARTIAL"|"CIRCUIT_BREAKER";
export type Posture  = "RISK_ON"|"NEUTRAL"|"RISK_OFF";

export interface RiskState {
  level: "GREEN"|"AMBER"|"RED";
  sentinel: Sentinel;
  posture: Posture;
}

export type Origin =
  | "UPLIFT"        // VIVO-09 uplift assign sonrasÄ± yÃ¼rÃ¼tme varyantÄ±
  | "SPOT_REBAL"    // VIVO-11 cashSpotAllocator legs
  | "PACING"        // VIVO-12 pacing throttles (bilgilendirme)
  | "RISK_ALLOC"    // VIVO-13 riskBudgetAllocator legs
  | "DRIFT_FIX";    // VIVO-14 driftGuard actions

export type ActionKind = "OPEN"|"INCREASE"|"REDUCE"|"TRIM"|"TOP_UP"|"CANCEL_REPLACE"|"SWITCH_CHILD"|"WAIT_RETRY";

export interface ActionProposal {
  origin: Origin;
  corrId: string;            // sÃ¼recin korelasyon idâ€™si
  legId: string;             // alt-bacak id'si (symbol#index)
  symbol: string;
  side: "BUY"|"SELL";
  kind: ActionKind;
  notionalUsd: number;       // etkilenecek notional
  execHint?: {
    childType: "LIMIT"|"IOC"|"POST_ONLY"|"MARKET";
    limitOffsetBps?: number;
    twapMs?: number;
    iceberg?: number;
    reduceOnly?: boolean;
    postOnly?: boolean;
  };
  reasons?: string[];
}

export type CardSeverity = "INFO"|"WARN"|"CRITICAL";

export interface PlaybookCard {
  cardId: string;                // deterministic: `${origin}|${corrId}|${legId}`
  origin: Origin;
  title: string;                 // kart baÅŸlÄ±ÄŸÄ±
  severity: CardSeverity;
  proposals: ActionProposal[];   // 1..N Ã¶neri
  meta: {
    risk: RiskState;
    expiresAt: string;           // timeout iÃ§in ISO
    createdAt: string;
    sessionId?: "ASIA"|"EU"|"US"|"LOW_LIQ";
    paceHint?: { maxChildPerMin:number };
  };
}

export interface OperatorDecision {
  cardId: string;
  decidedAt: string;
  decidedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
  decisionSeq: number;           // aynÄ± cardIdâ€™ye birden fazla partial varsa artar
  choice: "ACCEPT_ALL"|"REJECT_ALL"|"PARTIAL";
  acceptLegs?: Array<{ legId:string }>;  // PARTIAL iÃ§in
  notes?: string;
}

export interface BridgePolicy {
  timeoutMs: number;              // 8000..20000
  reduceOnlyOnSentinel: boolean;  // true
  maxProposalsPerCard: number;    // 20
  groupBySymbol: boolean;         // kartta grupla
}

export interface ApplyCommand {
  cardId: string;
  seq: number;
  corrId: string;
  legId: string;
  symbol: string;
  side: "BUY"|"SELL";
  kind: ActionKind;
  notionalUsd: number;
  execHint?: ActionProposal["execHint"];
  acceptedBy: "OPERATOR"|"TIMEOUT_DEFAULT";
}

export interface StdError { code:string; message:string; details?:Record<string,unknown>; retriable?:boolean; }

Event Bus (pub-sub)

Subscribe

vivo.uplift.assign / vivo.rebalance.suggest / vivo.risk.alloc.plan / vivo.driftguard.action

vivo.pacing.plan, risk.state

vivo.operator.input (VIVO-03: operatÃ¶rÃ¼n buton seÃ§imleri)

Publish

vivo.operator.card (PlaybookCard) â€“ VIVO-03â€™te gÃ¶rsel kart

vivo.operator.decision (OperatorDecision) â€“ normalize edilmiÅŸ karar

vivo.apply.command (ApplyCommand) â€“ VIVO-02â€™nin doÄŸrudan uygulayacaÄŸÄ± komut akÄ±ÅŸÄ±

audit.log

Kart Ãœretim MantÄ±ÄŸÄ± (Ã¶zet)

Kaynak â†’ Kart: gelen Ã¶nerileri symbol bazlÄ± grupla (opsiyonel), cardId = \${origin}|${corrId}|${legId}`veya grup kart iÃ§inlegId="*"` kullan.

Sentinel filtresi: reduceOnlyOnSentinel true ve sentinelâ‰ NORMAL ise TOP_UP/OPEN/INCREASE iÃ§eren Ã¶nerileri kart dÄ±ÅŸÄ± bÄ±rak veya bilgilendirme kartÄ±na Ã§evir.

Zehirli kombinasyon (aynÄ± symbol iÃ§in aynÄ± anda TOP_UP ve TRIM) â†’ WARN ÅŸiddeti ve operatÃ¶r uyarÄ±sÄ±.

Timeout: expiresAt = now + timeoutMs. OperatÃ¶r kararÄ± gelmezse DEFAULT:

yeni risk iÃ§eriyorsa â†’ REJECT_ALL

yalnÄ±z reduce-only ise â†’ ACCEPT_ALL.

Idempotency: aynÄ± cardId ikinci kez Ã¼retilmez (versiyonlamak gerekirse cardId#v2).

Kota notu: paceHint.maxChildPerMin VIVO-02â€™ye yol gÃ¶sterir (sert enforce orada).

Kod Ä°skeleti (TypeScript)
// vivo/operatorPlaybookBridge.ts
import { EventEmitter } from "events";
import { bus } from "../core/bus";
import { logger } from "../core/logger";
import type {
  PlaybookCard, BridgePolicy, OperatorDecision, ActionProposal, ApplyCommand,
  RiskState, StdError
} from "./operatorPlaybookBridge.types";

const nowISO = ()=> new Date().toISOString();
const clamp = (x:number, lo:number, hi:number)=> Math.max(lo, Math.min(hi, x));

export class OperatorPlaybookBridge extends EventEmitter {
  ver="1.0.0"; src="VIVO-15";
  private policy: Required<BridgePolicy>;
  private risk: RiskState = { level:"GREEN", sentinel:"NORMAL", posture:"NEUTRAL" };
  private pending = new Map<string, PlaybookCard>();   // cardId -> card
  private decided = new Set<string>();                 // cardId#seq

  constructor(p?: Partial<BridgePolicy>){
    super();
    this.policy = {
      timeoutMs: 12000,
      reduceOnlyOnSentinel: true,
      maxProposalsPerCard: 20,
      groupBySymbol: true,
      ...p
    };
  }

  attach(){
    // kaynak akÄ±ÅŸlar
    bus.on<ActionProposal>("vivo.driftguard.action", (a)=> this.ingest([a], "DRIFT_FIX"));
    bus.on<any>("vivo.rebalance.suggest", (plan)=> {
      const arr: ActionProposal[] = (plan?.legs||[]).map((l:any, i:number)=>({
        origin:"SPOT_REBAL", corrId: plan.asOf, legId:`${l.symbol}#${i}`,
        symbol:l.symbol, side:l.side, kind: l.side==="BUY"?"INCREASE":"TRIM",
        notionalUsd:l.notionalUsd, execHint:l.execHint, reasons:l.reasons
      }));
      this.ingest(arr, "SPOT_REBAL");
    });
    bus.on<any>("vivo.risk.alloc.plan", (plan)=> {
      const arr: ActionProposal[] = (plan?.legs||[]).map((l:any, i:number)=>({
        origin:"RISK_ALLOC", corrId: plan.corrId, legId:`${l.symbol}#${i}`,
        symbol:l.symbol, side: l.targetRiskUsd>=0?"BUY":"SELL",
        kind: l.targetRiskUsd>=0?"OPEN":"REDUCE",
        notionalUsd: Math.abs(l.estNotionalUsd),
        execHint:{ childType:"LIMIT", limitOffsetBps:6, twapMs:1400, iceberg:0.12 },
        reasons:l.reasons
      }));
      this.ingest(arr, "RISK_ALLOC");
    });
    // risk/pacing
    bus.on<RiskState>("risk.state", r=> this.risk = r);
    // operatÃ¶r giriÅŸi
    bus.on<OperatorDecision>("vivo.operator.input", d=> this.onDecision(d));
  }

  /** Ã–nerileri kartlaÅŸtÄ±rÄ±r ve yayÄ±nlar */
  ingest(proposals: ActionProposal[], origin?: string){
    try{
      if (!proposals?.length) return;
      // sentinel filtresi
      const filtered = this.filterBySentinel(proposals);

      // grupla
      const groups = this.policy.groupBySymbol
        ? this.groupBy(filtered, p=> `${p.origin}|${p.corrId}|${p.symbol}`)
        : this.groupBy(filtered, p=> `${p.origin}|${p.corrId}|${p.legId}`);

      for (const [key, arr] of groups.entries()){
        if (!arr.length) continue;
        const cardId = this.policy.groupBySymbol ? `${arr[0].origin}|${arr[0].corrId}|${arr[0].symbol}` : `${arr[0].origin}|${arr[0].corrId}|${arr[0].legId}`;
        if (this.pending.has(cardId)) continue; // idempotent

        const severity = this.pickSeverity(arr);
        const card: PlaybookCard = {
          cardId,
          origin: arr[0].origin,
          title: this.makeTitle(arr),
          severity,
          proposals: arr.slice(0, this.policy.maxProposalsPerCard),
          meta:{
            risk: this.risk,
            createdAt: nowISO(),
            expiresAt: new Date(Date.now()+this.policy.timeoutMs).toISOString()
          }
        };
        this.pending.set(cardId, card);
        bus.emit<PlaybookCard>("vivo.operator.card", card);
        bus.emit("audit.log", { asOf: card.meta.createdAt, ver:this.ver, src:this.src, payload:{ msg:"card", cardId, n:card.proposals.length, severity }});

        // timeout planla
        setTimeout(()=> this.onTimeout(cardId), this.policy.timeoutMs);
      }
    } catch(e:any){
      logger.error({e}, "VIVO-15 ingest failed");
    }
  }

  private filterBySentinel(arr: ActionProposal[]){
    if (!this.policy.reduceOnlyOnSentinel) return arr;
    if (this.risk.sentinel==="NORMAL") return arr;
    // sentinel aktif â†’ yeni risk iÃ§erenler (OPEN/INCREASE/TOP_UP) dÃ¼ÅŸer
    return arr.filter(p=> !["OPEN","INCREASE","TOP_UP"].includes(p.kind));
  }

  private groupBy<T>(arr:T[], key:(t:T)=>string){
    const m = new Map<string,T[]>();
    for (const x of arr){ const k = key(x); (m.get(k) || m.set(k,[]).get(k)!).push(x); }
    return m;
  }

  private pickSeverity(arr: ActionProposal[]): "INFO"|"WARN"|"CRITICAL"{
    const hasReduce = arr.some(a=> ["TRIM","REDUCE"].includes(a.kind));
    const hasOpen   = arr.some(a=> ["OPEN","INCREASE","TOP_UP"].includes(a.kind));
    if (this.risk.sentinel!=="NORMAL") return "CRITICAL";
    if (hasReduce && hasOpen) return "WARN";
    return "INFO";
  }

  private makeTitle(arr: ActionProposal[]){
    const s = arr[0].symbol ?? arr[0].origin;
    const kinds = Array.from(new Set(arr.map(a=>a.kind))).join(",");
    return `${s} Â· ${kinds}`;
  }

  /** OperatÃ¶r kararÄ± (VIVO-03) */
  onDecision(d: OperatorDecision){
    try{
      const card = this.pending.get(d.cardId); if (!card) return;
      const sig = `${d.cardId}#${d.decisionSeq}`;
      if (this.decided.has(sig)) return; // idempotent

      const accepted = new Set( (d.choice==="PARTIAL" ? (d.acceptLegs||[]).map(x=>x.legId) : card.proposals.map(p=>p.legId)) );
      const cmds: ApplyCommand[] = [];

      if (d.choice==="REJECT_ALL"){
        // hiÃ§bir ÅŸey yayma, sadece audit
      } else {
        for (const p of card.proposals){
          if (d.choice==="PARTIAL" && !accepted.has(p.legId)) continue;
          cmds.push({
            cardId: card.cardId, seq: d.decisionSeq,
            corrId: p.corrId, legId: p.legId, symbol: p.symbol,
            side: p.side, kind: p.kind, notionalUsd: p.notionalUsd,
            execHint: p.execHint, acceptedBy: d.decidedBy
          });
        }
      }

      // publish
      if (cmds.length){
        for (const c of cmds) bus.emit<ApplyCommand>("vivo.apply.command", c);
      }
      bus.emit<OperatorDecision>("vivo.operator.decision", d);
      bus.emit("audit.log", { asOf: nowISO(), ver:this.ver, src:this.src,
        payload:{ msg:"decision", cardId:d.cardId, choice:d.choice, seq:d.decisionSeq, cmds:cmds.length }});

      // kartÄ± kapat
      this.pending.delete(d.cardId);
      this.decided.add(sig);

    } catch(e:any){
      logger.error({e}, "VIVO-15 decision failed");
    }
  }

  /** Timeout â†’ korumacÄ± default */
  private onTimeout(cardId:string){
    const card = this.pending.get(cardId); if (!card) return;
    // yeni risk iÃ§eriyorsa REJECT, yalnÄ±z reduce-only iÃ§eriyorsa ACCEPT
    const hasNewRisk = card.proposals.some(p=> ["OPEN","INCREASE","TOP_UP"].includes(p.kind));
    const d: OperatorDecision = {
      cardId, decidedAt: nowISO(), decidedBy:"TIMEOUT_DEFAULT", decisionSeq: 0,
      choice: hasNewRisk ? "REJECT_ALL" : "ACCEPT_ALL",
      notes: "auto-timeout default"
    };
    this.onDecision(d);
  }
}

Test Ä°skeleti (Vitest)
// vivo/__tests__/operatorPlaybookBridge.test.ts
import { describe,it,expect,vi } from "vitest";
import { OperatorPlaybookBridge } from "../operatorPlaybookBridge";
import type { ActionProposal, OperatorDecision } from "../operatorPlaybookBridge.types";

const mk = (p:Partial<ActionProposal>): ActionProposal => ({
  origin:"DRIFT_FIX", corrId:"c1", legId:"BTC#0", symbol:"BTCUSDT",
  side:"BUY", kind:"TOP_UP", notionalUsd:5000, execHint:{ childType:"LIMIT" },
  ...p
});

describe("VIVO-15 operatorPlaybookBridge", ()=>{
  it("emits a card and applies ACCEPT_ALL", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 5000 });
    const cards:any[] = []; const cmds:any[] = [];
    b.attach?.(); // not strictly needed in this unit
    // mock bus
    const origEmit = (b.constructor as any).prototype.emit;
    b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); if (ev==="vivo.apply.command") cmds.push(payload); return true; };

    b.ingest([mk({ kind:"TRIM", side:"SELL" })]);
    expect(cards.length).toBe(1);
    const d: OperatorDecision = { cardId: cards[0].cardId, decidedAt:new Date().toISOString(), decidedBy:"OPERATOR", decisionSeq:1, choice:"ACCEPT_ALL" };
    b.onDecision(d);
    expect(cmds.length).toBeGreaterThan(0);
  });

  it("defaults to REJECT when card has new risk and timeout occurs", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 10 });
    const cards:any[] = []; const cmds:any[] = [];
    b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); if (ev==="vivo.apply.command") cmds.push(payload); return true; };
    b.ingest([mk({ kind:"OPEN", side:"BUY" })]);
    expect(cards.length).toBe(1);
    // wait ~20ms and check that no cmds published (REJECT_ALL)
    return new Promise<void>(res=> setTimeout(()=>{ expect(cmds.length).toBe(0); res(); }, 25));
  });

  it("filters new risk when sentinel active", ()=>{
    const b:any = new OperatorPlaybookBridge({ timeoutMs: 50 });
    b["risk"] = { level:"RED", sentinel:"HALT_PARTIAL", posture:"RISK_OFF" };
    const cards:any[] = []; b.emit = (ev:string, payload:any)=>{ if (ev==="vivo.operator.card") cards.push(payload); return true; };
    b.ingest([mk({ kind:"TOP_UP" }), mk({ kind:"TRIM", side:"SELL" })]);
    expect(cards[0].proposals.every((p:any)=> p.kind!=="TOP_UP")).toBe(true);
  });
});

Entegrasyon AkÄ±ÅŸÄ±

Kaynak modÃ¼ller (VIVO-09/11/13/14) ve pacing/risk; Ã¶nerileri ActionProposal olarak yayÄ±nlar.

VIVO-15 bu Ã¶nerileri PlaybookCardâ€™a Ã§evirir â†’ vivo.operator.card.

VIVO-03 operatorDialog kartÄ± Telegram/CLIâ€™de butonlarla gÃ¶sterir (ACCEPT/REJECT/PARTIAL).

OperatÃ¶r seÃ§imi â†’ vivo.operator.input â†’ VIVO-15 vivo.apply.command Ã¼retir.

VIVO-02 komutlarÄ± gerÃ§ek emirlere Ã§evirir (LOT_SIZE, percent-price, TWAP/IOC/POST_ONLY, rate-limit, drift guard ile uyum).

Audit: tÃ¼m kart/karar/komut akÄ±ÅŸÄ± audit.logâ€™da tutulur; idempotency korunur.
_________________________________________________________________________________________________________________

VIVO-16 Â· signalDecisionRouter.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama promptu)
AmaÃ§

AynÄ± enstrÃ¼man ve yÃ¶nde birden Ã§ok sinyal geldiÄŸinde tek karar Ã¼retmek.

VIVOâ€™nun rol sÃ¶zleÅŸmesine uygun ÅŸekilde confirmationThreshold, signalVariant, biasWeightedTune deÄŸerlerini nihai karara baÄŸlamak.

TekilleÅŸtirme, Ã§akÄ±ÅŸma Ã§Ã¶zÃ¼mÃ¼, cooldown, pencere yÃ¶netimi, tekrar giriÅŸ (re-entry) kurallarÄ± ve duplicated/contradicting sinyaller iÃ§in politika uygulamak.

Ã‡Ä±ktÄ±yÄ± Event Bus Ã¼zerinden execution.intent.proposed kanalÄ±na gÃ¶ndermek; reddedilenleri execution.intent.rejected ile raporlamak.

Girdiler (JSON ÅemasÄ±)
{
  "timestamp": "iso8601",
  "symbol": "string", 
  "side": "long|short",
  "timeframe": "string",
  "source": "string", 
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number"
  },
  "vivoHints": {
    "confirmationThreshold": "number",
    "signalVariant": "base|aggressive|conservative",
    "biasWeightedTune": {
      "trend": "number",
      "orderflow": "number",
      "formation": "number"
    }
  },
  "liviaGate": {
    "safetyGate": "pass|hold",
    "riskLimitAdvice": "tight|normal|relaxed",
    "cooldownActive": "boolean"
  },
  "otobilinc": {
    "psychologyStability": "0..1",
    "fatigueScore": "0..1",
    "biasFlags": ["string"]
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number"
  }
}

Ã‡Ä±ktÄ±lar (JSON ÅemasÄ±)
{
  "decision": "approve|reject|defer",
  "reasonCodes": ["string"],
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "routing": {
    "busTopic": "execution.intent.proposed|execution.intent.rejected|execution.intent.deferred",
    "correlationId": "string"
  },
  "constraints": {
    "cooldownMs": "number",
    "maxConcurrentPositions": "number",
    "riskProfile": "tight|normal|relaxed"
  },
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "audit": {
    "symbol": "string",
    "side": "long|short",
    "receivedAt": "iso8601",
    "processedAt": "iso8601",
    "upstream": {"source": "string", "signalId":"string"}
  }
}

TypeScript ArayÃ¼zleri (AIâ€™den Ã¼retmesini iste)

SignalEnvelope, LiviaGate, OtobilincHints, VivoHints, RouterDecision, ReasonCode.

TÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlara runtime Zod validasyonu ekle; hatalÄ± veri reject(reason: "invalid_payload").

Event Bus KonularÄ±

In: signal.envelope (Grafik Beyni), livia.gate, psy.state (OtobilinÃ§).

Out: execution.intent.proposed, execution.intent.rejected, execution.intent.deferred.

Telemetry: vivo.router.metrics (p99_latency, approve_rate, reject_rate, dup_drop_rate).

Konfig & VarsayÄ±lanlar
{
  decisionWindowMs: 1500,     // aynÄ± sembol-yÃ¶n iÃ§in pencere
  duplicateKey: ["symbol","side","timeframe"], 
  minConfidence: 0.62,
  defaultVariant: "base",
  cooldownMs: {
    approve: 30000,
    reject: 10000,
    defer: 15000
  },
  conflictPolicy: "higherConfidenceWins|latestWins",
  maxConcurrentPerSymbol: 1
}

Ã–n-Ä°ÅŸleme

Pencere anahtarÄ±: symbol+side+timeframe. Bu pencerede gelen sinyalleri kuyruÄŸa al.

TekilleÅŸtirme: aynÄ± signalId â†’ drop (reason: "duplicate_id").

Zaman doÄŸrulama: timestamp drift > 2s ise reason: "clock_skew", not et ama tamamen atma; confidence-0.05 uygula.

LIVIA gate = hold â†’ defer (cooldown=cfg.cooldownMs.defer).

OtobilinÃ§ fatigueScore>0.7 â†’ confidence-0.08; psychologyStability<0.4 â†’ variant conservative.

Skorlama & Karar AÄŸacÄ±

BaseScore = 0.4*trendStrength + 0.3*rrScore + 0.3*orderflowBias.

VolAdj: volatility aÅŸÄ±rÄ± yÃ¼ksekse (z>1.5) â†’ +0.03; Ã§ok dÃ¼ÅŸÃ¼kse â†’ âˆ’0.03.

BiasWeightedTune uygula:
Adj = w_trend*trendStrength + w_of*orderflowBias + w_form*(formationPresence?0.05:0), toplam skora +Adj*0.1.

Variant seÃ§imi:

rrScoreâ‰¥0.65 & trendStrengthâ‰¥0.6 & psychologyStabilityâ‰¥0.5 â†’ aggressive

psychologyStability<0.4 or livia.riskLimitAdvice=="tight" â†’ conservative

aksi â†’ base

Onay:

livia.safetyGate=="pass" ve finalScoreâ‰¥minConfidence â†’ approve

livia.safetyGate=="hold" â†’ defer

aksi â†’ reject

Ã‡akÄ±ÅŸma Ã§Ã¶zÃ¼mÃ¼: aynÄ± pencere iÃ§inde birden fazla approve adayÄ± â†’ conflictPolicy uygula (varsayÄ±lan: daha yÃ¼ksek finalScore kazanÄ±r; eÅŸitse latestWins).

Kurallar (GerÃ§ek DÃ¼nya)

Bar kapanÄ±ÅŸÄ± kuralÄ±: kapanmamÄ±ÅŸ mumdan gelen sinyallerde reason:"open_bar" etiketi; confidence-0.04.

GÃ¼nlÃ¼k iÅŸlem sÄ±nÄ±rÄ± kontrolÃ¼ Ã¼st katmanda; ancak burada maxConcurrentPerSymbol enforced â†’ aksi reject("limit_hit").

Seri kayÄ±p sonrasÄ± LIVIA cooldownActive==true â†’ defer + cooldown uzat (cfg.defer*1.5).

Latency-safe: latencyMs>1000 â†’ reason:"stale_signal" confidence-0.03.

Ã‡Ä±ktÄ± YÃ¶nlendirme

approve â†’ execution.intent.proposed (ek alanlar: selectedVariant, riskProfile, tpSlStyle).

reject â†’ execution.intent.rejected (nedenlerle).

defer â†’ execution.intent.deferred (ne zaman tekrar deÄŸerlendirileceÄŸi cooldownMs ile).

Kodlama YÃ¶nlendirmesi (AIâ€™ye talimat)

Dosya yapÄ±sÄ±: src/vivo/signalDecisionRouter.ts + __tests__/signalDecisionRouter.test.ts.

Validasyon: Zod ÅŸemalarÄ±, parseOrThrow. Hata â†’ structured ReasonCode.

Durum: pencere baÅŸÄ±na InMemoryWindowStore (Map). TTL = decisionWindowMs.

Algoritma: Fonksiyonel, saf core + event adapter. Yan etkiler only bus publish.

Konfig: config/vivo.router.json yÃ¼kle, env override destekle.

Log/Telemetry: p99 hesapla; metrikleri busâ€™a per 10s publish.

Tip GÃ¼venliÄŸi: interfaceâ€™ler + Readonly alanlar; as const ile sabitle.

Hata YÃ¶netimi: unknown alanlar warn + drop deÄŸil; confidence penalize et.

Test Ä°skeleti: Jest ile

duplicate drop,

conflict resolution,

livia hold â†’ defer,

psychology low â†’ conservative,

final approve path publishes to execution.intent.proposed.

Runtime Guard: maxConcurrentPerSymbol ihlalinde publish etme; sadece rejected.

Ã–rnek Girdi
{
  "timestamp": "2025-09-01T08:10:05Z",
  "symbol": "AVAXUSDT",
  "side": "long",
  "timeframe": "M15",
  "source": "formation.breakout",
  "features": {"trendStrength":0.66,"rrScore":0.7,"volatility":0.9,"orderflowBias":0.55},
  "vivoHints": {
    "confirmationThreshold":0.62,
    "signalVariant":"base",
    "biasWeightedTune":{"trend":0.5,"orderflow":0.3,"formation":0.2}
  },
  "liviaGate":{"safetyGate":"pass","riskLimitAdvice":"normal","cooldownActive":false},
  "otobilinc":{"psychologyStability":0.58,"fatigueScore":0.32,"biasFlags":[]},
  "meta":{"signalId":"sig-234","formationTag":"ascendingTriangle","latencyMs":420}
}

Beklenen Ã‡Ä±ktÄ± (Ã¶zet)
{
  "decision":"approve",
  "reasonCodes":["score_ok","livia_pass"],
  "selectedVariant":"aggressive",
  "confidence":0.71,
  "routing":{"busTopic":"execution.intent.proposed","correlationId":"AVAXUSDT-long-M15-169356"},
  "constraints":{"cooldownMs":30000,"maxConcurrentPositions":1,"riskProfile":"normal"},
  "tuning":{"entryNudge":3,"tpSlStyle":"ATR","positionScaling":"laddered"},
  "audit":{"symbol":"AVAXUSDT","side":"long","receivedAt":"...","processedAt":"...","upstream":{"source":"formation.breakout","signalId":"sig-234"}}
}

Notlar (Entegrasyon)

VIVO â†’ Sinyal YÃ¶netim Merkezi ile aynÄ± sÃ¶zleÅŸme: tÃ¼m modÃ¼ller bu RouterDecision Ã§Ä±ktÄ±sÄ±nÄ± tÃ¼ketebilir.

Ã‡akÄ±ÅŸma ve pencere mantÄ±ÄŸÄ±, ileri aÅŸamada Sinyal YÃ¶netim Merkezine taÅŸÄ±nÄ±rsa, bu modÃ¼l â€œpolicy clientâ€ olarak Ã§alacak ÅŸekilde soyutla.
_________________________________________________________________________________________________________________
VIVO-17 Â· executionFeedbackLooper.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama promptu)
AmaÃ§

GerÃ§ekleÅŸen iÅŸlemler, PnL ve slippage verisine bakarak VIVOâ€™nun confirmationThreshold, biasWeightedTune ve variant (base/aggressive/conservative) tercihlerini dinamik ayarlamak.

Ã–ÄŸrenmeyi sembol Ã— timeframe Ã— variant Ã— formationTag kÄ±rÄ±lÄ±mÄ±nda yapÄ±p, kÃ¼resel politika sÄ±nÄ±rlarÄ±na (risk, gÃ¼nlÃ¼k iÅŸlem sayÄ±sÄ±, Kelly-light, seans filtresi) asla taÅŸmamak.

SonuÃ§larÄ± Event Bus Ã¼stÃ¼nden politikaya Ã¶neri olarak yayÄ±nlamak (otorite her zaman merkezÃ® Policy Engine/LIVIAâ€™dadÄ±r).

Girdiler (Event/JSON ÅemalarÄ±)
// execution.fill â€” pozisyon aÃ§Ä±lÄ±ÅŸÄ±/ekleme
{
  "event": "execution.fill",
  "timestamp": "iso8601",
  "tradeId": "string",
  "orderId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "price": "number",
  "qty": "number",
  "fees": "number",
  "slippageBps": "number",
  "latencyMs": "number",
  "signalMeta": {
    "signalId": "string",
    "formationTag": "string|null",
    "rrPlanned": "number",
    "tpSlStyle": "ATR|range|hybrid"
  }
}

// execution.close â€” pozisyon kapanÄ±ÅŸÄ± (TP/SL/manuel)
{
  "event": "execution.close",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "pnl": "number",            // realized PnL (quote cinsinden)
  "rMultiple": "number",      // realize R
  "holdingMins": "number",
  "exitReason": "tp|sl|timeout|manual|rule",
  "fees": "number",
  "slippageBps": "number",
  "drawdownBps": "number"
}

// telemetry.market â€” yÃ¼rÃ¼tme ortamÄ± metrikleri (opsiyonel)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",        // volatilite z
  "liquidityClass": "low|mid|high"
}

// policy.snapshot â€” Ã¼st politika sÄ±nÄ±rlarÄ± (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",  // 0.5â€“1 aralÄ±ÄŸÄ±nda
  "dailyMaxTrades": "number",   // 2â€“3
  "kellyCap": "number",         // 0.25 Kelly
  "maxConcurrentPerSymbol": 1,
  "confirmationBounds": {"min":0.55,"max":0.72}
}

Ã‡Ä±ktÄ±lar (Politika Ã–nerisi / GÃ¼ncelleme OlayÄ±)
{
  "event": "vivo.hints.update",
  "timestamp": "iso8601",
  "scope": {
    "symbol": "string",
    "timeframe": "string",
    "variant": "base|aggressive|conservative",
    "formationTag": "string|null"
  },
  "proposed": {
    "confirmationThreshold": "number",
    "biasWeightedTune": { "trend": "number", "orderflow": "number", "formation": "number" },
    "entryNudgeBps": "number",
    "cooldownMsAdjust": "number",
    "allowedVariants": ["base","aggressive","conservative"],
    "positionSizingHint": "single|laddered"
  },
  "reasonCodes": ["string"],
  "audit": {
    "dataWindow": {"trades":"int","days":"int"},
    "kpis": {"hitRate":"number","profitFactor":"number","avgR":"number","slippageBps":"number"},
    "guardsApplied": ["string"]
  }
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

ExecFill, ExecClose, MarketTelemetry, PolicySnapshot, VivoHintsUpdate

FeedbackKey = {symbol, timeframe, variant, formationTag?}

FeedbackStats = metrikler (EWMA/EMA alanlarÄ±, sample sayÄ±larÄ±, half-life bilgisi)

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlar iÃ§in runtime validasyon.

Event Bus KonularÄ±

In: execution.fill, execution.close, telemetry.market, policy.snapshot

Out: vivo.hints.update, vivo.feedback.metrics (telemetri)

Keying: symbol.timeframe.variant[.formationTag]

Konfig & VarsayÄ±lanlar
{
  // Ã¶ÄŸrenme pencereleri
  maxTradesWindow: 50,
  maxDaysWindow: 14,

  // EWMA half-life (trade adedi cinsinden)
  hl: { hitRate: 12, pf: 18, avgR: 12, slip: 10 },

  // sÄ±nÄ±rlar (policy.snapshot ile clamp edilir)
  confirmation: { base: 0.62, lo: 0.55, hi: 0.72, step: 0.01 },
  biasWeightsDefault: { trend: 0.5, orderflow: 0.3, formation: 0.2 },
  biasWeightsClamp: { min: 0.1, max: 0.7 },

  // slippage â†’ giriÅŸ ayarÄ±
  slipToNudgeFactor: 0.35,   // slip bps * factor â†’ entryNudgeBps

  // rejimler
  poorPerfThresholds: { pf: 1.0, hitRate: 0.35, avgR: 0.15 },
  goodPerfThresholds: { pf: 1.35, hitRate: 0.5,  avgR: 0.35 },

  // cooldown adaptasyonu
  cooldown: { baseMs: 30000, poorMult: 1.5, goodMult: 0.8 },

  // gÃ¼venlik
  minSamplesForChange: 12,
  maxDeltaPerUpdate: { confirmation: 0.02, weight: 0.1, nudgeBps: 4 }
}

Ã–n-Ä°ÅŸleme ve Durum YÃ¶netimi

FeedbackStateStore (in-memory + periyodik kalÄ±cÄ±: data/feedback.json veya sqlite). Anahtar: symbolÃ—timeframeÃ—variantÃ—formationTag.

Her execution.fill/close geldiÄŸinde ilgili anahtarÄ±n EWMA metriklerini gÃ¼ncelle:

hitRate (closeâ€™da rMultiple>0 â†’ 1, â‰¤0 â†’ 0)

profitFactor (grossProfit/grossLoss; loss=0 ise sÄ±nÄ±rlÄ± yÃ¼kseklik)

avgR (ortalama realize R)

slippageBps (fill/close ortalamasÄ±)

Pencere boyutlarÄ±: son maxTradesWindow ve maxDaysWindow ile sÄ±nÄ±rla (eski veriye azalÄ±r aÄŸÄ±rlÄ±k).

Algoritma (Ã–ÄŸrenme â†’ Ã–neri AkÄ±ÅŸÄ±)

KPI GÃ¼ncelle: EWMA ile hitRate, pf, avgR, slip Ã¼ret.

Rejim Tespiti:

pf < poor.pf veya hitRate < poor.hitRate â†’ POOR

pf â‰¥ good.pf ve hitRate â‰¥ good.hitRate ve avgR â‰¥ good.avgR â†’ GOOD

aksi â†’ NEUTRAL

Ã–neri KurallarÄ±:

POOR:

confirmationThreshold + step (clamp lo..hi ve maxDeltaPerUpdate).

allowedVariants â†’ ["base","conservative"] (aggressive devre dÄ±ÅŸÄ±).

biasWeightedTune â†’ trend+0.05, formation-0.05 (formation spesifik baÅŸarÄ±sÄ±zlÄ±k varsa daha fazla dÃ¼ÅŸÃ¼r).

cooldownMsAdjust = cooldown.baseMs * poorMult.

GOOD:

confirmationThreshold âˆ’ step (min: policy.confirmationBounds.min).

allowedVariants â†’ ["base","aggressive","conservative"] (aggressive aÃ§Ä±labilir).

biasWeightedTune â†’ orderflow+0.05 (Ã¶zellikle slip dÃ¼ÅŸÃ¼kse), formation+0.03 (formationTag performansÄ± iyiyse).

cooldownMsAdjust = cooldown.baseMs * goodMult.

NEUTRAL:

KÃ¼Ã§Ã¼k dÃ¼zeltmeler: confirmationThreshold â†’ no-op veya Â±0.01, biasWeightedTune â†’ yumuÅŸak normalize.

Slippage Tepkisi:

slip son 10 trade ort. > 8 bps â†’ entryNudgeBps = min( ceil(slip * slipToNudgeFactor), maxDeltaPerUpdate.nudgeBps ).

liquidityClass=="low" â†’ allowedVariantsâ€™tan aggressive geÃ§ici Ã§Ä±kar.

Formation-Spesifik Ayar:

AynÄ± formationTag iÃ§in pf<1.0 ve avgR<0.1 â†’ biasWeightedTune.formation âˆ’0.07 (clamp min).

Tersi iyi ise +0.05 (clamp max).

Guard Rails:

YalnÄ±zca samples â‰¥ minSamplesForChange ise Ã¶neri yayÄ±nla.

Her gÃ¼ncellemede maxDeltaPerUpdate sÄ±nÄ±rlarÄ±nÄ± uygula.

policy.snapshot sÄ±nÄ±rlarÄ±yla clamp: risk/dailyMaxTrades/confirmationBounds.

Seri kayÄ±p (son 5 iÅŸlemin â‰¥3â€™Ã¼ kayÄ±p) â†’ allowedVariants âŠ† ["base","conservative"], cooldown +%25.

Normalize & Publish:

biasWeightedTune toplamÄ± 1.0 olacak ÅŸekilde normalize (ve biasWeightsClamp aralÄ±klarÄ±).

vivo.hints.update olarak publish et; reasonCodes ve audit doldur.

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel ile uyumlu)

Bar KapanÄ±ÅŸÄ±: AÃ§Ä±k bar verisinden tÃ¼remiÅŸ agresif giriÅŸler kÃ¶tÃ¼ performans verirse confirmationThreshold otomatik olarak +0.01 yukarÄ± it.

YÃ¼rÃ¼tme Muhasebesi: PnLâ€™de komisyon+slipaj+fonlama dÃ¼ÅŸÃ¼lmÃ¼ÅŸ neti kullan.

Kelly-light & Risk: Ã–neriler asla riskPerTradePct, Kelly cap, gÃ¼nlÃ¼k 2â€“3 iÅŸlem sÄ±nÄ±rÄ±nÄ± gevÅŸetmez.

Latency-safe: Fill/close latency > 1500ms rejiminde aggressive kapat; entryNudgeBps artÄ±r.

Overfit KorumasÄ±: GÃ¼ncellemeler kademeli; her Ã¶neri ÅŸrinkage ile baselineâ€™a yakÄ±nsÄ±n (Ã¶r. %40 varsayÄ±lan karÄ±ÅŸÄ±mla).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±:

src/vivo/executionFeedbackLooper.ts

src/vivo/state/feedbackStore.ts (persist)

__tests__/executionFeedbackLooper.test.ts

Mimari:

Saf Ã§ekirdek (pure) fonksiyonlar: accumulateStats(), regimeDetect(), proposeUpdate(), applyGuards().

I/O adaptÃ¶rleri: bus subscribe/publish. Yan etkiler sadece adaptÃ¶rde.

Validasyon: Zod ÅŸemalarÄ±; hatalÄ± paketleri warn et, sayÄ±lara dÃ¶nÃ¼ÅŸemeyen alanlarÄ± drop et.

Telemetri: vivo.feedback.metrics her 10s: pf, hitRate, avgR, slip, p99_loop_latency.

Konfig: config/vivo.feedback.json + ENV override.

Tip GÃ¼venliÄŸi: TÃ¼m sÃ¶zleÅŸmeler interface + as const.

Persist: JSON/sqilte; uygulama restartâ€™Ä±nda kaldÄ±ÄŸÄ± yerden devam.

Test Ä°skeleti (Jest)

updates only after minSamplesForChange

poor regime â†’ confirmation + step, aggressive off

good regime â†’ confirmation âˆ’ step, aggressive allowed

high slippage â†’ entryNudgeBps increased

formation underperforms â†’ formation weight down

guards clamp deltas & bounds

normalize weights sum to 1.0

Ã–rnek Olay AkÄ±ÅŸÄ± (BasitleÅŸtirilmiÅŸ)

Girdi dizisi (Ã¶zet):

14 iÅŸlem kapanmÄ±ÅŸ: pf=1.42, hitRate=0.54, avgR=0.36, son-10 slip=6.5 bps

symbol=AVAXUSDT, M15, variant=base, formationTag=ascendingTriangle

policy.confirmationBounds = [0.55,0.72], mevcut confirmation=0.62

Beklenen Ã–neri:

{
  "event": "vivo.hints.update",
  "scope": {"symbol":"AVAXUSDT","timeframe":"M15","variant":"base","formationTag":"ascendingTriangle"},
  "proposed": {
    "confirmationThreshold": 0.61,
    "biasWeightedTune": {"trend":0.47,"orderflow":0.33,"formation":0.20},
    "entryNudgeBps": 3,
    "cooldownMsAdjust": 24000,
    "allowedVariants": ["base","aggressive","conservative"],
    "positionSizingHint": "laddered"
  },
  "reasonCodes": ["good_pf","good_hit","slip_moderate","shrinkage_applied"],
  "audit": {
    "dataWindow":{"trades":14,"days":6},
    "kpis":{"hitRate":0.54,"profitFactor":1.42,"avgR":0.36,"slippageBps":6.5},
    "guardsApplied":["clamp_confirmation_bounds","max_delta_limited"]
  }
}

Entegrasyon NotlarÄ±

Ã‡Ä±ktÄ±, VIVO-16 signalDecisionRouter tarafÄ±ndan okunup selectedVariant, tuning ve constraints kararlarÄ±nda kullanÄ±lacaktÄ±r.

LIVIA (risk dampingi) â€œseri kayÄ±pâ€ saptadÄ±ÄŸÄ±nda policy.snapshot Ã¼zerinden sÄ±kÄ±laÅŸma gelir; looper yalnÄ±zca Ã¶neri yayÄ±nlar, yetki LIVIA/Policyâ€™dedir.

Sinyal YÃ¶netim Merkezi ileride aÃ§Ä±ldÄ±ÄŸÄ±nda bu modÃ¼l policy client olarak Ã§alÄ±ÅŸmaya devam etmeli (adaptÃ¶r katmanÄ± soyutla).
_________________________________________________________________________________________________________________
VIVO-18 Â· executionIntentThrottler.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama promptu)
AmaÃ§

execution.intent.proposed (VIVO-16 Ã§Ä±kÄ±ÅŸÄ±) akÄ±ÅŸÄ±nÄ± alÄ±p politika sÄ±nÄ±rlarÄ± ve likidite/rezim koÅŸullarÄ±na gÃ¶re kabul / erteleme / reddetme kararÄ± vermek.

GÃ¼nlÃ¼k 2â€“3 iÅŸlem sÄ±nÄ±rÄ±, sembol baÅŸÄ±na en fazla 1 eÅŸzamanlÄ± pozisyon, re-entry cooldown ve oturum/likidite filtreleri ile patlama (burst) kontrolÃ¼nÃ¼ uygulamak.

Kabul edilenleri execution.intent.accepted, ertelenenleri execution.intent.deferred, reddedilenleri execution.intent.rejected olarak yayÄ±nlamak; neden kodlarÄ±nÄ± ve bir sonraki uygun zamanÄ± belirtmek.

Girdiler (Event/JSON ÅemalarÄ±)
// execution.intent.proposed â€” VIVO-16'den gelir
{
  "event": "execution.intent.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "constraints": {
    "cooldownMs": "number",
    "maxConcurrentPositions": "number",
    "riskProfile": "tight|normal|relaxed"
  },
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "audit": {
    "upstream": {"source":"string","signalId":"string"}
  }
}

// policy.snapshot â€” Ã¼st sÄ±nÄ±rlar (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",           // 0.5â€“1 aralÄ±ÄŸÄ±
  "dailyMaxTrades": "number",            // 2â€“3
  "kellyCap": "number",                  // 0.25 Kelly
  "maxConcurrentPerSymbol": 1,
  "globalMaxConcurrent": 3,
  "reentryMinMins": 45,                  // aynÄ± sembol-yÃ¶n iÃ§in minimum yeniden giriÅŸ sÃ¼resi
  "quietHours": {"start":"HH:mm","end":"HH:mm","tz":"Europe/Istanbul"},
  "throttle": {
    "burst": {"capacity": 2, "refillPerMin": 1},  // token bucket
    "perSymbolPerHour": 2
  }
}

// account.exposure â€” maruziyet ve aÃ§Ä±k pozisyonlar
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {"symbol":"string","side":"long|short","qty":"number","riskPct":"number","openedAt":"iso8601"}
  ],
  "totalRiskPctOpen": "number"
}

// telemetry.market â€” likidite/volatilite rejimi
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",
  "liquidityClass": "low|mid|high",
  "session": "asia|eu|us|mixed"
}

// livia.guard â€” acil durum/seri kayÄ±p freni
{
  "event": "livia.guard",
  "cooldownActive": "boolean",
  "seriesLoss": {"lastN": 5, "lossCount": 3},
  "emergency": "none|slowdown|halt"      // haltâ†’tÃ¼m yeni niyetler blok
}

Ã‡Ä±ktÄ±lar (Karar OlaylarÄ±)
// Kabul
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "reasonCodes": ["string"],
  "appliedGuards": ["string"],           // hangi throttle kurallarÄ± kontrol edildi
  "correlationId": "string"
}

// Erteleme
{
  "event": "execution.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "deferUntil": "iso8601",
  "reasonCodes": ["string"],
  "correlationId": "string"
}

// Red
{
  "event": "execution.intent.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["string"],
  "correlationId": "string"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

IntentProposed, IntentAccepted, IntentDeferred, IntentRejected

PolicySnapshot, AccountExposure, MarketTelemetry, LiviaGuard

YardÄ±mcÄ± tipler: ThrottleState, TokenBucket, CooldownRegistry, OpenPositionKey (symbol+side)

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlara runtime validasyon ekle.

Event Bus KonularÄ±

In: execution.intent.proposed, policy.snapshot, account.exposure, telemetry.market, livia.guard

Out: execution.intent.accepted, execution.intent.deferred, execution.intent.rejected, vivo.throttle.metrics

Konfig & VarsayÄ±lanlar
{
  // temel limitler
  dailyMaxTradesDefault: 3,                 // policy ile override
  globalMaxConcurrentDefault: 3,
  perSymbolConcurrent: 1,
  perSymbolPerHour: 2,

  // re-entry ve cooldown
  reentryMinMinsDefault: 45,
  sameDirectionMinMins: 60,                 // aynÄ± sembol-yÃ¶n
  oppositeDirectionMinMins: 20,

  // token bucket (burst kontrol)
  bucket: { capacity: 2, refillPerMin: 1 },

  // seans/likidite filtreleri
  quietHours: { start: "02:30", end: "05:00", tz: "Europe/Istanbul" }, // crypto 24/7, ama dÃ¼ÅŸÃ¼k likidite
  lowLiquidityAggressiveBlock: true,

  // eÅŸikler
  maxTotalRiskPctOpen: 2.0,                 // toplam aÃ§Ä±k risk %
  maxVolZForAggressive: 1.8,

  // telemetri
  metricsFlushSec: 10
}

Durum YÃ¶netimi

ThrottleStateStore (in-memory + periyodik kalÄ±cÄ±; data/throttle.json):

todayTradeCount (tarih bazlÄ± reset),

openPositionKeys (Set: symbol+side),

perSymbolHourlyCounter (Map: symbol â†’ {hourBucket: ISO, count}),

reentryCooldown (Map: symbol+side â†’ isoNextAllowed),

tokenBucket (global; capacity/refill),

lastDecisionForKey (audit iÃ§in),

quietWindow hesaplayÄ±cÄ±.

Algoritma (Karar AkÄ±ÅŸÄ±)

Ã–n Kontroller

EÄŸer livia.guard.emergency=="halt" â†’ reject("emergency_halt").

cooldownActive==true (LIVIA seri kayÄ±p) â†’ defer (min 30â€“45 dk) reason:"series_loss_cooldown".

Global Kapasite & GÃ¼nlÃ¼k Limit

todayTradeCount â‰¥ dailyMaxTrades â†’ reject("daily_limit_hit").

openPositions.length â‰¥ globalMaxConcurrent â†’ defer("global_concurrency_full", +15m).

Sembol BazlÄ± EÅŸzamanlÄ±lÄ±k & Re-entry

openPositionKeys aynÄ± symbol+side aÃ§Ä±k â†’ reject("per_symbol_concurrency").

reentryCooldown[symbol+side] > now â†’ defer("reentry_cooldown", until=cooldownTime).

Likidite/Seans & Variant KÄ±sÄ±tlarÄ±

quietHours iÃ§i ve selectedVariant=="aggressive" â†’ defer("+20m","quiet_hours").

MarketTelemetry.liquidityClass=="low" ve lowLiquidityAggressiveBlock â†’

selectedVariant=="aggressive" ise reject("low_liquidity_aggressive_block").

volZScore > maxVolZForAggressive â†’ aggressive â†’ reject("excess_vol_for_aggressive") (base/conservative iÃ§in devam).

Burst & Saatlik Oran

Token bucket: token yoksa â†’ defer("burst_limit", +5m).

perSymbolPerHour aÅŸÄ±ldÄ±ysa â†’ defer("per_symbol_hourly_limit", nextHourStart).

Risk Maruziyeti

AccountExposure.totalRiskPctOpen + proposedRiskPct > maxTotalRiskPctOpen â†’ defer("risk_cap_reached", +10m).

proposedRiskPct = riskPerTradePct (policyâ€™den) veya variant/riskProfileâ€™a gÃ¶re ayarlanan deÄŸer.

Kabul & Yan Etkiler

YukarÄ±dakilerin hiÃ§biri tetiklenmediyse:

accept ve yan etki olarak:

todayTradeCount++,

openPositionKeys.add(symbol+side) (pozisyon kapanÄ±ÅŸÄ±nda baÅŸka modÃ¼l temizleyecek),

perSymbolHourlyCounter[symbol].count++,

Token tÃ¼ket.

execution.intent.accepted yayÄ±nla; reasonCodes: ["ok_limits","ok_liquidity","ok_risk"].

Pozisyon KapanÄ±ÅŸÄ±nda (bilgi)

AyrÄ± bir tÃ¼ketici (trade close eventâ€™ini) openPositionKeys ve ilgili sayacÄ± temizlemeli; re-entry iÃ§in:

kapanÄ±ÅŸtan sonra reentryCooldown[symbol+side] = now + reentryMinMins.

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel ile uyumlu)

GÃ¼nlÃ¼k 2â€“3 Ä°ÅŸlem: dailyMaxTrades asla yÃ¼kseltilmez; policy ne diyorsa odur.

Kelly-light & Risk: Toplam aÃ§Ä±k risk %2 Ã¼stÃ¼ne Ã§Ä±kmaz; riskPerTradePct policyâ€™den alÄ±nÄ±r.

Latency-safe & Seans: DÃ¼ÅŸÃ¼k likidite veya sessiz saatlerde agresif varyantlar kÄ±sÄ±tlanÄ±r.

Bar KapanÄ±ÅŸÄ± KuralÄ±: VIVO-16â€™dan gelen aÃ§Ä±k-bar kaynaklÄ± sinyaller zaten cezalÄ±; throttler ek blok uygularsa reasonâ€™a open_bar_penalty eklenebilir.

Adil PaylaÅŸÄ±m: Sembol bazlÄ± saatlik limit adaleti saÄŸlar; tek sembol akÄ±ÅŸÄ± tÃ¼m kotayÄ± yemesin.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/executionIntentThrottler.ts

src/vivo/state/throttleStore.ts (persist)

__tests__/executionIntentThrottler.test.ts

Mimari

Ã‡ekirdek saf fonksiyon: throttleDecision(intent, state, policy, market, exposure, livia) â†’ Decision.

I/O adaptÃ¶rÃ¼: bus subscribe/publish; state persist ve periyodik reset (gÃ¼n deÄŸiÅŸtirdiÄŸinde todayTradeCount=0).

Validasyon

Zod ÅŸemalarÄ±; eksik MarketTelemetry varsa varsayÄ±lan liquidityClass="mid", volZ=0.

Telemetri

vivo.throttle.metrics her 10 sn: {p99_decision_ms, accept_rate, defer_rate, reject_rate, tokens, today_count}.

Konfig

config/vivo.throttle.json + ENV override; saat dilimi Europe/Istanbul.

Test Ä°skeleti (Jest)

halt â†’ reject(emergency_halt)

hit dailyMaxTrades â†’ reject(daily_limit_hit)

per symbol concurrency â†’ reject(per_symbol_concurrency)

reentry cooldown active â†’ defer(...)

quiet hours + aggressive â†’ defer(...)

low liquidity aggressive â†’ reject(...)

burst no tokens â†’ defer(...)

risk cap exceeded â†’ defer(...)

happy path â†’ accepted & counters updated

Ã–rnek Olay (Ã–zet)

Durum

policy.dailyMaxTrades=3, todayTradeCount=2, openPositions=["AVAXUSDT-long"]

account.totalRiskPctOpen=1.5, riskPerTradePct=0.5

Saat: 03:10 (Europe/Istanbul) â†’ quietHours iÃ§inde

MarketTelemetry: liquidityClass="low", volZScore=1.2

intent: symbol="LINKUSDT" side="long" selectedVariant="aggressive"

Beklenen Karar

quietHours + lowLiquidity + aggressive â†’ defer (20 dk)

{
  "event":"execution.intent.deferred",
  "symbol":"LINKUSDT",
  "side":"long",
  "deferUntil":"2025-09-01T00:30:00Z",
  "reasonCodes":["quiet_hours","low_liquidity_aggressive_block"],
  "correlationId":"LINKUSDT-long-..."}


Alternatif

AynÄ± koÅŸullarda selectedVariant="base" olsaydÄ± ve token mevcutsa:

Risk toplamÄ± 2.0%â€™Ä± aÅŸmÄ±yorsa accept.

Entegrasyon NotlarÄ±

VIVO-16 signalDecisionRouter â†’ Ã¶nerileri buraya yollar; throttler kabul/erteleme/ret verir.

VIVO-17 executionFeedbackLooper â†’ kabul/ret/erteleme oranlarÄ±nÄ± izleyip confirmationThreshold ve allowedVariants Ã¶nerilerini ayarlarken throttler metriklerini de gÃ¶z Ã¶nÃ¼ne alabilir (opsiyonel subscribe).

LIVIAâ€™nÄ±n acil durumlarÄ± her zaman Ã¼stÃ¼ndÃ¼r (halt/slowdown).
_________________________________________________________________________________________________________________
VIVO-19 Â· executionOrderComposer.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama promptu)
AmaÃ§

execution.intent.accepted olayÄ±nÄ± al ve Ã¼retim-gerÃ§ekÃ§iliÄŸinde bir emir planÄ±na dÃ¶nÃ¼ÅŸtÃ¼r:

Emir tipi seÃ§imi (trend kÄ±rÄ±lÄ±mÄ± â†’ stop-market, sweep-revert â†’ limit + TTLâ†’market failover),

Pozisyon bÃ¼yÃ¼klÃ¼ÄŸÃ¼ (riskPerTradePct, ATR/range tabanlÄ± SL mesafesine gÃ¶re),

Ladder (kademeli) giriÅŸ & kademeli TP,

TP/SL (ATR|range|hybrid), OCO/Bracket (borsa destekliyorsa) veya emÃ¼lasyon,

Price/Qty normalizasyonu (tick/lot/minNotional/PERCENT_PRICE),

Slipaj bÃ¼tÃ§esi ve timeout/escalation kurallarÄ±.

Ã‡Ä±ktÄ±: order.plan.proposed (yÃ¼rÃ¼tme katmanÄ± uygulayacak).

Girdiler (Event/JSON ÅemalarÄ±)
// VIVO-18'den kabul
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "tuning": {
    "entryNudge": "bps",
    "tpSlStyle": "ATR|range|hybrid",
    "positionScaling": "single|laddered"
  },
  "constraints": {
    "riskProfile": "tight|normal|relaxed"
  },
  "audit": {
    "upstream": {"source":"string","signalId":"string"}
  }
}

// policy.snapshot â€” risk/limit sÄ±nÄ±rlarÄ±
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",      // %0.5â€“1
  "kellyCap": "number",             // 0.25 Kelly (Ã¼st sÄ±nÄ±r)
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":0.55,"max":0.72}
}

// market.refs â€” gÃ¶stergeler ve seviyeler
{
  "event": "market.refs",
  "symbol": "string",
  "lastPrice": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "session": "asia|eu|us|mixed",
  "spreadBps": "number",
  "volZScore": "number"
}

// exchange.info â€” kural & filtreler
{
  "event": "exchange.info",
  "symbol": "string",
  "filters": {
    "tickSize": "number",
    "stepSize": "number",
    "minNotional": "number",
    "priceLimitRate": "number",     // PERCENT_PRICE(_BY_SIDE)
    "minQty": "number",
    "maxQty": "number"
  },
  "tradeMode": "spot|usdm|coinm"
}

// account.equity â€” bÃ¼yÃ¼klÃ¼k hesabÄ± iÃ§in
{
  "event": "account.equity",
  "equityQuote": "number"           // USDT gibi
}

Ã‡Ä±ktÄ± (Emir PlanÄ± OlayÄ±)
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [
      {
        "ratio": "0..1",            // toplamÄ± 1.0
        "type": "market|limit|stop_market|stop_limit",
        "price": "number",          // tick'e yuvarlanmÄ±ÅŸ
        "qty": "number",            // step'e yuvarlanmÄ±ÅŸ
        "ttlSec": "number",
        "slippageBudgetBps": "number",
        "failover": "none|market|price_step_escalation"
      }
    ]
  },
  "protection": {
    "stopLoss": {"type":"stop_market|stop_limit","price":"number","offset":"bps"},
    "takeProfit": [
      {"ratio":"0..1","type":"limit","price":"number"}
    ],
    "ocoCapable": "boolean",
    "trailing": {"enabled": "boolean","callbackRateBps":"number"}
  },
  "risk": {
    "riskPerTradePct": "number",
    "plannedRR": "number",
    "notional": "number",
    "maxSlipBps": "number"
  },
  "normChecks": {
    "priceRounded": "boolean",
    "qtyRounded": "boolean",
    "minNotionalOk": "boolean",
    "percentPriceOk": "boolean"
  },
  "audit": {
    "variant": "base|aggressive|conservative",
    "tpSlStyle": "ATR|range|hybrid",
    "basis": {"atr":"number","swingHigh":"number","swingLow":"number"},
    "refs": {"bestBid":"number","bestAsk":"number","mid":"number"},
    "reasonCodes": ["string"],
    "correlationId": "string"
  }
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

IntentAccepted, OrderPlan, EntryLeg, ProtectionBracket, RiskBlock, NormChecks.

ExchangeFilters, MarketRefs, PolicySnapshot, AccountEquity.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: execution.intent.accepted, market.refs, exchange.info, account.equity, policy.snapshot

Out: order.plan.proposed, order.compose.metrics (p99_plan_ms, plan_rr, ladder_count, oco_used)

(Opsiyonel uyarÄ±): order.plan.rejected (norm ihlali veya veri eksikliÄŸi varsa)

Konfig & VarsayÄ±lanlar
{
  // TP/SL katsayÄ±larÄ± (ATR Ã§oklayÄ±cÄ±larÄ±)
  atrK: { conservative: {tp: 2.2, sl: 2.0}, base: {tp: 1.8, sl: 1.5}, aggressive: {tp: 1.5, sl: 1.2} },

  // Range tamponlarÄ± (bps)
  rangeBufBps: { tp: 8, sl: 12 },

  // Ladder geometrisi
  ladder: {
    legs: { single: 1, laddered: 3 },
    weights: { laddered: [0.4, 0.35, 0.25] },
    spacingBps: { base: 6, aggressive: 10, conservative: 4 } // limit modunda iÃ§eri dizilim
  },

  // Emir tipi matrisi (Ã¶zet)
  orderMatrix: {
    breakout: { long: "stop_market", short: "stop_market" },
    sweepRevert: { long: "limit", short: "limit" },
    default: { long: "limit", short: "limit" }
  },

  // TTL ve failover
  ttlSec: { limit: 12, stop_limit: 15 },
  failover: { onPartialFillUnder: 0.6, mode: "market" },

  // Slipaj bÃ¼tÃ§esi
  maxSlipBps: { base: 8, aggressive: 12, conservative: 6 },

  // OCO desteÄŸi yoksa emÃ¼lasyon
  ocoEmulation: { enabled: true, pollMs: 300, cancelBeforePlace: true },

  // Normalizasyon
  roundMode: "floor", // fiyat->tick, qty->step
  minNotionalBufferPct: 0.02
}

Ã–n-Ä°ÅŸleme

Sembol whitelisti (kullanÄ±cÄ±nÄ±n listesi) iÃ§indeyse devam et; deÄŸilse reason:"symbol_not_whitelisted".

Gerekli referanslarÄ±n hepsi var mÄ±? (market.refs, exchange.info, account.equity, policy.snapshot) â€” yoksa plan.rejected.

tpSlStyle ve selectedVariantâ€™a gÃ¶re katsayÄ±larÄ± ve spacing parametrelerini seÃ§.

BoyutlandÄ±rma (Risk â†’ Qty)

SL mesafesi (price units):

ATR: slDist = atr.value * atrK[variant].sl

Range: long ise lastPrice - (swingLow - swingLow*buf_sl_bps), short ise swingHigh*(1+buf_sl_bps) - lastPrice

Hybrid: slDist = max( ATR tabanlÄ±, Range tabanlÄ± )

Risk Notyonu: riskQuote = equityQuote * (riskPerTradePct / 100)

Qty (quoteâ†’base): qtyRaw = riskQuote / slDist

Ladder: weights ile her bacaÄŸa qty_i = qtyRaw * weight_i

Yuvarlama: price tickSizeâ€™a, qty stepSizeâ€™a; minQty ve maxQty kontrolÃ¼.

Min Notional: her bacak iÃ§in price_i * qty_i â‰¥ minNotional*(1+buffer) olmalÄ±; deÄŸilse bacaÄŸÄ± birleÅŸtir veya planÄ± downscale et.

Percent Price: bacak fiyatlarÄ± PERCENT_PRICE kuralÄ± iÃ§inde kalmalÄ±.

Not: riskPerTradePct Kelly cap ile asla yukarÄ± itilmez; LIVIA guard aktifse (seri kayÄ±p) boyutlandÄ±rma Ã¼st katmanda sÄ±kÄ±lÄ±r; composer sadece verilen risk yÃ¼zdesini uygular.

GiriÅŸ PlanÄ± (Entry)

Order Type SeÃ§imi:

Trend kÄ±rÄ±lÄ±mÄ± (upstream formationTag veya kaynak ipucu): stop_market.

Sweep-revert / mean reversion: limit + ttlSec + failover.

Aksi durumda default matrisi.

FiyatlandÄ±rma:

market: fiyat yok; sadece slippage budget ve auditâ€™e market=true.

limit:

long: price = min(bestAsk, mid * (1 - entryNudge_bps)) deÄŸil; gerÃ§ekÃ§ilik â†’ likit ortamda fiyatÄ± almak iÃ§in:

â€œpasifâ€ istiyorsak price = bestBidâ€™e yakÄ±n (- nudge),

TTL sonunda fill<60% ise failover market.

short iÃ§in simetrik.

stop_market: tetik seviyesi = longâ€™da swingHigh + buffer veya lastPrice*(1+entryNudge_bps).

TTL & Escalation:

TTL doldu, dolum < onPartialFillUnder â†’

failover.mode=="price_step_escalation" ise fiyatÄ± +/- tick * kademeli artÄ±r ve tekrar TTL koy,

Aksi market failover.

Slippage BÃ¼tÃ§esi:

GerÃ§ekleÅŸen fill bps > maxSlipBps[variant] â†’ yÃ¼rÃ¼tme katmanÄ±na kapatma/iptal politikasÄ± ilet (composer auditâ€™e yazar).

TP/SL (Koruma)

SL:

tpSlStyle=="ATR" â†’ slPrice = entryRef -/+ atr.value * atrK[variant].sl

range â†’ swingLow/High Â± buffer

hybrid â†’ max(ATR, range) mesafesi kadar daha uzak olan SL (daha gÃ¼venli)

Yuvarla (tick). Stop_limit gerekiyorsa limit offset bps ekle.

TP:

Planlanan R:R: plannedRR = atrK[variant].tp / atrK[variant].sl (yaklaÅŸÄ±k) veya range bazlÄ± hedef.

Laddered TP (Ã¶rnek): [0.5, 0.3, 0.2] oranla; tp_i = entryPrice Â± RR * slDist * scale_i.

OCO/Bracket:

Borsa destekliyse native; deÄŸilse emÃ¼lasyon (SL/TP yerleÅŸtirme sÄ±rasÄ±: Ã¶nce SL, ardÄ±ndan TP; fill eventâ€™lerinde kalan qtyâ€™ye gÃ¶re ayarla).

Normalizasyon & Guard Rails

priceRounded, qtyRounded, minNotionalOk, percentPriceOk true olmak zorunda; aksi order.plan.rejected.

notional (toplam) gÃ¼nlÃ¼k risk/limitlerle Ã§eliÅŸiyorsa planÄ± downscale et (RR deÄŸiÅŸmeden).

Quiet hours + aggressive + low liquidity durumunda ladder aÄŸÄ±rlÄ±klarÄ±nÄ± Ã¶nden kÃ¼Ã§Ã¼lt (weights normalize < 1.0); auditâ€™e liquidity_downscale ekle.

AÃ§Ä±k bar kuralÄ±: upstream aÃ§Ä±k-bar kaynaklÄ± giriÅŸse TP/SL daha muhafazakÃ¢r (SL +0.1ATR; TP âˆ’0.1ATR).

Algoritma (Ã–zet AkÄ±ÅŸ)

Girdileri doÄŸrula (Zod).

SL mesafesini hesapla (ATR|range|hybrid).

Riskâ†’qtyâ†’ladder daÄŸÄ±t, tick/step/minNotional/PERCENT_PRICE kontrol et.

Emir tipi ve fiyatlarÄ±nÄ± belirle; TTL/failover kuralÄ±nÄ± uygula.

TP/SLâ€™yi hesapla; OCO/Bracket kur.

NormChecks ve guard rails uygula; ihlal varsa plan.rejected.

order.plan.proposed yayÄ±nla; telemetriyi gÃ¼ncelle (order.compose.metrics).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/executionOrderComposer.ts

src/vivo/lib/normalize.ts (tick/step/minNotional/PERCENT_PRICE)

src/vivo/lib/positionSizing.ts (riskâ†’qtyâ†’ladder)

__tests__/executionOrderComposer.test.ts

Mimari

Saf Ã§ekirdek: composeOrderPlan(intent, refs, filters, equity, policy, cfg)

IO adaptÃ¶rÃ¼: bus subscribe/publish + exchangeInfo/equity cache.

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlar finite(); negatif/NaN reddedilir.

Telemetri

order.compose.metrics her 10 sn: {p99_plan_ms, accept_rate, reject_rate, ladder_count_avg, rr_avg}

Konfig

config/vivo.composer.json + ENV override (Ã¶r. VIVO_COMPOSER_TTL_LIMIT).

Test Ä°skeleti (Jest)

atr style â†’ doÄŸru SL/TP ve RR

range style â†’ swing tabanlÄ± TP/SL

hybrid â†’ max(ATR, range) mesafesi

riskâ†’qty ladder daÄŸÄ±lÄ±mÄ± & rounding

minNotional ihlali â†’ downscale veya reject

PERCENT_PRICE ihlali â†’ reject

limit TTL <60% fill â†’ market failover

low liquidity + aggressive â†’ weights kÃ¼Ã§Ã¼lÃ¼r

oco yok â†’ emÃ¼lasyon sÄ±rasÄ± doÄŸru

Ã–rnek Senaryo (Ã–zet)

Girdi (kÄ±saltÄ±lmÄ±ÅŸ)

intent.accepted: symbol="LINKUSDT", side="long", variant="base", tuning={entryNudge:3,tpSlStyle:"hybrid",positionScaling:"laddered"}

policy: riskPerTradePct=0.7

equityQuote=10_000

market.refs: last=12.40, bestBid=12.39, bestAsk=12.41, mid=12.40, atr14=0.28, swingLow=11.95, swingHigh=12.55, spread=8 bps

filters: tick=0.01, step=0.1, minNotional=10, priceLimitRate=5%

Hesap Ã–zeti

hybrid slDist = max(ATR*1.5, last - swingLow + buf) â‰ˆ max(0.42, 0.47) = 0.47

riskQuote = 10_000 * 0.007 = 70

qtyRaw = 70 / 0.47 â‰ˆ 148.93 LINK

Ladder (0.4/0.35/0.25) â†’ 59.57/52.13/37.23 â†’ stepâ€™e yuvarla: 59.6/52.1/37.2

Limit giriÅŸ (mean-revert kabulÃ¼ ise): price1â‰ˆbestBid (12.39), spacingBps=6 â†’ p2â‰ˆ12.31, p3â‰ˆ12.24 (tickâ€™e yuvarla)

SL (hybrid): 12.40 - 0.47 = 11.93 â†’ tick: 11.93

TP (RR~1.2â€“1.4): Ã¶r. 12.40 + 0.56 â‰ˆ 12.96 (%50), 13.10 (%30), 13.25 (%20)

Ã‡Ä±ktÄ± (Ã¶zet)

{
  "event":"order.plan.proposed",
  "symbol":"LINKUSDT",
  "side":"long",
  "entryPlan":{
    "mode":"limit",
    "legs":[
      {"ratio":0.4,"type":"limit","price":12.39,"qty":59.6,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"},
      {"ratio":0.35,"type":"limit","price":12.31,"qty":52.1,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"},
      {"ratio":0.25,"type":"limit","price":12.24,"qty":37.2,"ttlSec":12,"slippageBudgetBps":8,"failover":"market"}
    ]
  },
  "protection":{
    "stopLoss":{"type":"stop_market","price":11.93,"offset":0},
    "takeProfit":[
      {"ratio":0.5,"type":"limit","price":12.96},
      {"ratio":0.3,"type":"limit","price":13.10},
      {"ratio":0.2,"type":"limit","price":13.25}
    ],
    "ocoCapable":false,
    "trailing":{"enabled":false,"callbackRateBps":0}
  },
  "risk":{"riskPerTradePct":0.7,"plannedRR":1.3,"notional":1845.0,"maxSlipBps":8},
  "normChecks":{"priceRounded":true,"qtyRounded":true,"minNotionalOk":true,"percentPriceOk":true},
  "audit":{"variant":"base","tpSlStyle":"hybrid","basis":{"atr":0.28,"swingHigh":12.55,"swingLow":11.95},"refs":{"bestBid":12.39,"bestAsk":12.41,"mid":12.40},"reasonCodes":["ok"],"correlationId":"LINKUSDT-long-..."}
}

Entegrasyon NotlarÄ±

Bu plan yÃ¼rÃ¼tme motoru tarafÄ±ndan emir yerleÅŸtirmeye dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r (bir sonraki modÃ¼l).

VIVO-17 (feedback looper) planlanan RR, slipaj, partial-fill sonuÃ§larÄ±nÄ± geri besleme iÃ§in dinleyebilir.

VIVO-18â€™in throttling kararlarÄ± Ã¼stÃ¼ndÃ¼r; composer boyutlandÄ±rmayÄ± yÃ¼kseltmez, sadece uygular.
_________________________________________________________________________________________________________________
VIVO-20 Â· orderExecutionManager.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama promptu)
AmaÃ§

order.plan.proposed planÄ±nÄ± atomik bir yÃ¼rÃ¼tme senaryosuna Ã§evirmek:

GiriÅŸ bacaklarÄ±nÄ± sÄ±rayla/eÅŸzamanlÄ± yerleÅŸtir (market/limit/stopâ€¦),

KÄ±smi dolumlarda dinamik miktar ile SL/TP (reduce-only) kur,

OCO/Bracket kullan (varsa), yoksa emÃ¼lasyon yap,

TTL dolumu yetersizse cancelâ†’replace veya market failover uygula,

Slipaj bÃ¼tÃ§esi aÅŸÄ±ldÄ±ÄŸÄ±nda korumacÄ± davran,

AÄŸ/limit/kurallar hatalarÄ±nda idempotent retry/backoff uygula.

Durum makinesiyle tÃ¼m yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶net; sonuÃ§larÄ± event busâ€™a yayÄ±nla.

Girdiler (Event/JSON ÅemalarÄ±)
// order.plan.proposed â€” VIVO-19'dan
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [
      {"ratio":"0..1","type":"market|limit|stop_market|stop_limit","price":"number","qty":"number","ttlSec":"number","slippageBudgetBps":"number","failover":"none|market|price_step_escalation"}
    ]
  },
  "protection": {
    "stopLoss": {"type":"stop_market|stop_limit","price":"number","offset":"bps"},
    "takeProfit": [{"ratio":"0..1","type":"limit","price":"number"}],
    "ocoCapable": "boolean",
    "trailing": {"enabled":"boolean","callbackRateBps":"number"}
  },
  "risk": {"riskPerTradePct":"number","plannedRR":"number","notional":"number","maxSlipBps":"number"},
  "normChecks": {"priceRounded":"boolean","qtyRounded":"boolean","minNotionalOk":"boolean","percentPriceOk":"boolean"},
  "audit": {"variant":"base|aggressive|conservative","tpSlStyle":"ATR|range|hybrid","reasonCodes":["string"],"correlationId":"string"}
}

// exchange.info â€” kural/Ã¶zellikler
{
  "event": "exchange.info",
  "symbol": "string",
  "features": {
    "ocoNative": "boolean",
    "reduceOnly": "boolean",     // futures
    "postOnly": "boolean",
    "timeInForce": ["GTC","IOC","FOK"]
  },
  "limits": {
    "tickSize":"number","stepSize":"number","minNotional":"number","minQty":"number","maxQty":"number","priceLimitRate":"number"
  }
}

// market.refs â€” anlÄ±k referanslar
{
  "event": "market.refs",
  "symbol": "string",
  "bestBid":"number","bestAsk":"number","mid":"number","spreadBps":"number","volZScore":"number"
}

// account.exposure â€” aÃ§Ä±k pozisyonlar ve risk
{
  "event": "account.exposure",
  "openPositions": [{"symbol":"string","side":"long|short","qty":"number","avgPrice":"number"}],
  "totalRiskPctOpen":"number"
}

// livia.guard â€” acil durumlar
{
  "event":"livia.guard",
  "emergency":"none|slowdown|halt"
}

Ã‡Ä±ktÄ±lar (YÃ¼rÃ¼tme OlaylarÄ±)
// Emir yerleÅŸtirme isteÄŸi/sonucu (adapter-agnostic)
{
  "event": "order.placement.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol":"string",
  "tradeMode":"spot|usdm|coinm",
  "legs": [{"clientOrderId":"string","type":"market|limit|stop_market|stop_limit","price":"number|null","qty":"number","tif":"GTC|IOC|FOK","reduceOnly":"boolean"}]
}

{
  "event": "order.placement.result",
  "timestamp": "iso8601",
  "correlationId": "string",
  "results": [
    {"clientOrderId":"string","exchangeOrderId":"string","status":"accepted|rejected","reason":"string|null"}
  ]
}

// CanlÄ± gÃ¼ncellemeler
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number"
}

// Ä°ptal/replace
{"event":"order.cancel.request","timestamp":"iso8601","correlationId":"string","clientOrderId":"string"}
{"event":"order.cancel.result","timestamp":"iso8601","correlationId":"string","clientOrderId":"string","status":"canceled|not_found|failed","reason":"string|null"}

// Bracket kurulum durumu
{
  "event":"order.bracket.ready",
  "timestamp":"iso8601",
  "correlationId":"string",
  "slOrderId":"string","tpOrderIds":["string"],
  "mode":"native_oco|emulated"
}

// Hatalar / zaman aÅŸÄ±mÄ±
{
  "event":"order.execution.error",
  "timestamp":"iso8601",
  "correlationId":"string",
  "stage":"placing_entry|placing_bracket|monitoring|cancel_replace|failover",
  "code":"network|ratelimit|percent_price|min_notional|insufficient_margin|unknown",
  "detail":"string"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

OrderPlan, PlacementRequest/Result, OrderUpdate, BracketReady, ExecError.

ExchangeInfo, MarketRefs, Exposure, LiviaGuard.

YardÄ±mcÄ±: ExecutionState, LegState, BracketState, RetryPolicy, BackoffPlan.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: order.plan.proposed, exchange.info, market.refs, account.exposure, livia.guard

Out: order.placement.request, order.placement.result, order.update, order.cancel.*, order.bracket.ready, order.execution.error, order.exec.metrics

Konfig & VarsayÄ±lanlar
{
  // Timeouts & TTL
  legPlaceTimeoutMs: 3000,
  entryLegTtlSecDefault: 12,           // plan bacaÄŸÄ± TTL override edebilir
  partialFillUnder: 0.6,               // TTL sonunda kÄ±smi dolum <60% ise escalation
  replaceMaxAttempts: 2,
  failoverModeDefault: "market",       // price_step_escalation | market

  // Price step escalation
  escalationTickSteps: [1, 2],         // her replace'te kaÃ§ tick Ã¶te
  escalationHoldSec: 5,                // yeni fiyatla bekleme

  // Slippage & koruma
  maxSlipBpsHard: 15,                  // variant'tan baÄŸÄ±msÄ±z Ã¼st sÄ±nÄ±r
  cancelIfSlipOverHard: true,

  // TIF tercihleri
  tif: { market: "IOC", limit: "GTC", stop_market: "GTC", stop_limit: "GTC" },

  // OCO emÃ¼lasyon
  ocoEmulation: { enabled: true, placeOrderDelayMs: 250, pollMs: 300, cancelOtherOnFill: true },

  // Idempotency & retry
  clientOrderIdFormat: "{symbol}-{side}-{ts}-{rand4}",
  retry: { max: 3, backoffMs: [250, 500, 1000] },

  // Telemetry
  metricsFlushSec: 10
}

Durum Makinesi (State Machine)

States

INIT â†’ PLACING_ENTRY â†’ WAITING_ENTRY_FILL â†’ (PLACE_PROTECTION â†’ MONITORING) â†’ COMPLETED

Ara durumlar: PARTIAL_ESCALATION, CANCEL_REPLACE, TIMEOUT_FAILOVER, ABORTED

Transitions (Ã¶zet)

INIT: Plan ve Ã¶n koÅŸullar doÄŸrulanÄ±r (limits, features, livia.halt?).

PLACING_ENTRY: TÃ¼m giriÅŸ bacaklarÄ± iÃ§in order.placement.request gÃ¶nder; result bekle.

WAITING_ENTRY_FILL:

Fill eventleri geldiÄŸinde avgFillPrice ve filledQty gÃ¼ncellenir.

TTL doldu + fillRatio < partialFillUnder â†’ PARTIAL_ESCALATION.

Slipaj Ã¶lÃ§Ã¼lÃ¼r; hard limit aÅŸÄ±lÄ±rsa CANCEL_REPLACE veya ABORTED.

PARTIAL_ESCALATION:

Bacak failover=="price_step_escalation" â†’ fiyat Â±tick ile replace (max replaceMaxAttempts).

Aksi â†’ TIMEOUT_FAILOVER (market).

PLACE_PROTECTION:

SL/TP kur. exchange.features.ocoNative==true ise native OCO; deÄŸilse emÃ¼lasyon:

futures: reduceOnly SL & TP ayrÄ± emirler, fill geldiÄŸinde diÄŸeri iptal.

MONITORING:

order.update akÄ±ÅŸÄ± dinlenir; TP veya SL tetiklenirse kalan karÅŸÄ± emir iptal (OCO emÃ¼lasyonu).

Pozisyon kapanÄ±nca COMPLETED.

CANCEL_REPLACE:

GeÃ§erli bacaÄŸÄ± iptal et, yeni fiyatla yeniden yerleÅŸtir. BaÅŸarÄ±sÄ±zsa TIMEOUT_FAILOVER.

TIMEOUT_FAILOVER:

Market failover uygula (slippage bÃ¼tÃ§esi iÃ§inde).

BaÅŸarÄ±lÄ±ysa PLACE_PROTECTION, deÄŸilse ABORTED.

ABORTED:

TÃ¼m bekleyen giriÅŸ ve koruma emirlerini iptal et; hata yayÄ±nla.

Algoritma (AyrÄ±ntÄ±)
1) GiriÅŸ YerleÅŸtirme

TIF: marketâ†’IOC, limitâ†’GTC. Post-Only gerekiyorsa postOnly=true (destekleniyorsa).

clientOrderId deterministik ve benzersiz Ã¼ret (idempotency).

order.placement.result.status=="rejected" ise hata koduna gÃ¶re:

percent_price â†’ plan hatasÄ±; ABORTED ve order.execution.error(code="percent_price").

min_notional â†’ ABORTED (plan dÃ¼zeyi Ã§Ã¶zmeliydi).

ratelimit/network â†’ backoff retry (en fazla retry.max).

insufficient_margin â†’ ABORTED.

2) KÄ±smi Dolum & Ortalama Fiyat

avgFillPrice = weightedAvg(prevQty, prevAvg, newQty, newPrice).

Her fillâ€™de kalan koruma miktarlarÄ± yeniden hesaplanÄ±r (reduce-only).

3) TTL, Escalation ve Failover

TTL bitti, fill < %60:

price_step_escalation: fiyatÄ± Â± tick * escalationTickSteps[i] kaydÄ±r â†’ replace.

Aksi: market failover (slip bÃ¼tÃ§esi â‰¤ maxSlipBpsHard ve plan risk.maxSlipBps).

4) Slipaj Muhasebesi

Her fillâ€™de lastFillSlipBps = abs(fillPrice - (limitPrice||mid)) / mid * 1e4.

lastFillSlipBps > risk.maxSlipBps â†’ uyarÄ±; > maxSlipBpsHard ve cancelIfSlipOverHard==true â†’ CANCEL_REPLACE (veya ABORTED).

5) Bracket Kurulumu

Native OCO:

Spot: OCO ile TP + SL aynÄ± anda; baÅŸarÄ± â†’ order.bracket.ready(mode="native_oco").

EmÃ¼lasyon:

Ã–nce SL yerleÅŸtir, ardÄ±ndan TP (reducesOnly/closeOnTrigger).

Fill/trigger updateâ€™lerinde diÄŸeri iptal.

EmÃ¼lasyon dÃ¶ngÃ¼sÃ¼ pollMs ile order status kontrol eder.

6) Trailing Stop (opsiyonel)

trailing.enabled==true â†’ exchange destekliyorsa native; yoksa emÃ¼lasyon: periyodik fiyat izleme + SL fiyatÄ±nÄ± yukarÄ±/aÅŸaÄŸÄ± ticks ile gÃ¼ncelle (rate-limit korumasÄ±).

7) Ä°ptal/Replace

Replace sÃ¼recinde:

Eski emri order.cancel.request â†’ result bekle â†’ yeni ÅŸartlarla placement.

not_found ise, muhtemelen tetiklenmiÅŸ/filled; status query ile doÄŸrula (Ã§ifte yerleÅŸtirme yapma).

8) Telemetri & Audit

order.exec.metrics (10 sn):
{p99_place_ms, p99_first_fill_ms, replace_count, failover_count, avg_slip_bps, oco_emulated_rate, error_rate}

order.updateâ€™lar Ã¼zerinden filled notional, realized slipaj hesaplanÄ±r ve VIVO-17 (feedback) kullanÄ±r.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/orderExecutionManager.ts (durum makinesi + orkestrasyon)

src/exchange/adapter.ts (abstract: place, cancel, query, time, features)

src/vivo/lib/slippage.ts, src/vivo/lib/avgFill.ts

__tests__/orderExecutionManager.test.ts

Mimari

Saf Ã§ekirdek: advance(state, event) â†’ state (deterministik).

IO adaptÃ¶rleri: bus subscribe/publish + exchange adapter Ã§aÄŸrÄ±larÄ±.

Idempotency: her clientOrderId tekil; yeniden baÅŸlatmada reconcile akÄ±ÅŸÄ±.

Validasyon

Zod ÅŸemalarÄ±; tÃ¼m sayÄ±sal alanlar finite(). HatalÄ± paket â†’ order.execution.error(code="invalid_payload").

Zaman Senkronu

exchange.time() ile drift Ã¶lÃ§; TTL/timeout hesaplarÄ±nda kullan.

Hata HaritasÄ±

Bilinen exchange kodlarÄ±nÄ± percent_price|min_notional|rate_limit|insufficient_margin|duplicate_client_id|unknownâ€™a eÅŸle.

GÃ¼nlÃ¼k Reset

Gerekli sayaÃ§lar (telemetri) gÃ¼n sonunda sÄ±fÄ±rlanÄ±r (Europe/Istanbul).

Test Ä°skeleti (Jest)

market leg â†’ IOC fill â†’ bracket native OCO

limit leg TTL<60% â†’ price step escalation â†’ fill

limit leg TTL<60% â†’ market failover

slippage > hard â†’ cancel_replace/abort

emulated OCO â†’ TP fill â†’ SL auto-cancel

network/ratelimit â†’ backoff retry

percent_price violation â†’ aborted with error

idempotent restart â†’ reconcile open orders, no duplicates

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel uyumlu)

Latency-safe: Bekleyen aÃ§Ä±k bar sinyalinde zaten cezalar uygulandÄ±; burada market failover olsa bile slipaj Ã¼st sÄ±nÄ±rlarÄ±na sadÄ±k kal.

YÃ¼rÃ¼tme muhasebesi: TÃ¼m fillâ€™lerde komisyon+slipaj metriklerini hesapla; VIVO-17â€™ye yayÄ±nla.

Risk & Kelly-light: BoyutlandÄ±rma VIVO-19â€™da sabitlendi; asla artÄ±rma. YalnÄ±zca aÅŸaÄŸÄ± Ã¶lÃ§ekleyebilirsin (percent_price/minNotional baskÄ±sÄ± vb.).

Rate limit & Flood: Replace/failoverâ€™da hÄ±z limitlerini aÅŸma; backoff uygula.

Futures: reduce-only zorunlu; hedge mode varsa symbol+side anahtarÄ±yla yÃ¶net.

Ã–rnek Olay (KÄ±saltÄ±lmÄ±ÅŸ)

Plan

LINKUSDT long, tradeMode=spot, laddered limit 3 bacak (TTL=12s), maxSlipBps=8, OCO yok (emÃ¼lasyon).

AkÄ±ÅŸ

PLACING_ENTRY: 3 limit bacaÄŸÄ± GTC gÃ¶nderildi â†’ result: accepted.

WAITING_ENTRY_FILL:

8sâ€™de 1. bacaÄŸÄ±n %40â€™Ä± doldu, avgSlip=5 bps.

12s TTL: toplam fill %50 < %60 â†’ PARTIAL_ESCALATION.

CANCEL_REPLACE: 2. bacak iptalâ†’yeniden yerleÅŸtir (+1 tick), 3. bacak +2 tick.

5s sonra fill %85 â†’ PLACE_PROTECTION.

PLACE_PROTECTION:

EmÃ¼lasyon: Ã¶nce SL, sonra TP emirleri (reduce-only/closeOnTrigger).

order.bracket.ready(mode="emulated") yayÄ±nlandÄ±.

MONITORING:

TP1 doldu â†’ kalan qtyâ€™ye gÃ¶re SL/TP yeniden ayarlandÄ±.

Sonra SL tetiklendi â†’ TP otomatik iptal â†’ COMPLETED.

Telemetri: replace_count=1, failover_count=0, avg_slip_bps=6.1.

Entegrasyon NotlarÄ±

VIVO-18 Throttler kabul verdikten sonra bu modÃ¼l devreye girer; abort olursa sebep execution.error ile geri yayÄ±nlanÄ±r ve VIVO-17 feedback tarafÄ±ndan Ã¶ÄŸrenmeye alÄ±nÄ±r.

VIVO-19 Composer ile sÃ¶zleÅŸme: fiyat/qty/limit kontrolleri planda geÃ§miÅŸtir; Execution Manager yalnÄ±zca uygular, kural ihlali gelirse raporlar.

Signal YÃ¶netim Merkezi ileride gelirse, correlationId ile tÃ¼m zincir uÃ§tan uca izlenebilir.
_________________________________________________________________________________________________________________
VIVO-21 Â· livePositionSupervisor.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)

Bu promptu diÄŸer yapay zekÃ¢ya ver; modÃ¼lÃ¼ Node.js + TypeScript ile yazsÄ±n. Kod istemiyoruz; ama nasÄ±l kodlamasÄ± gerektiÄŸini net yÃ¶nlendiriyoruz. TÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸ JSON ve event-driven.

AmaÃ§

AÃ§Ä±k pozisyonlarÄ± canlÄ± izleyip ÅŸu kararlarÄ± otomatik yÃ¶netmek:

Trailing stop (ATR/chandelier veya callback-bps) kur/ilerlet.

KÄ±smi TP sonrasÄ± yeniden dengeleme (kalan miktara gÃ¶re SL/TP gÃ¼ncelle).

Stagnation/timeout durumunda korumacÄ± kapatma (time-based exit).

BaÄŸlantÄ± kesintisi ve veri tazeliÄŸi dÃ¼ÅŸÃ¼ÅŸÃ¼nde gÃ¼venli moda geÃ§iÅŸ.

Abnormal spread/volatilite rejiminde SL sÄ±kÄ±laÅŸtÄ±rma, agresif varyantlarÄ±n geÃ§ici bloklanmasÄ±.

TÃ¼m operasyonlarÄ± reduce-only mantÄ±ÄŸÄ±yla, slipaj/limit kurallarÄ±na saygÄ± ile yÃ¼rÃ¼tmek.

Girdiler (Event / JSON ÅemalarÄ±)
// order.bracket.ready â€” VIVO-20 kurulum tamam
{
  "event": "order.bracket.ready",
  "timestamp": "iso8601",
  "correlationId": "string",
  "mode": "native_oco|emulated",
  "slOrderId": "string",
  "tpOrderIds": ["string"]
}

// order.update â€” borsa akÄ±ÅŸÄ±
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number"
}

// position.snapshot â€” periyodik pozisyon Ã¶zeti
{
  "event": "position.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeId": "string",
  "qtyOpen": "number",
  "avgPrice": "number",
  "unrealizedPnlQuote": "number",
  "entryTime": "iso8601"
}

// market.refs â€” anlÄ±k fiyat/ATR/swing referanslarÄ±
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "lastPrice": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// telemetry.market â€” likidite rejimi (opsiyonel farklÄ± kaynak)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "liquidityClass": "low|mid|high",
  "session": "asia|eu|us|mixed"
}

// connectivity.heartbeat â€” veri/baÄŸ tazeliÄŸi
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean"
}

// policy.snapshot â€” Ã¼st sÄ±nÄ±rlar (salt-okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"},
  "maxHoldMins": 240,
  "drawdownFromPeakR": {"aggressive":0.25,"base":0.35,"conservative":0.45}
}

// vivo.hints.update â€” (VIVO-17 Ã¶nerileri; trailing modu vs.)
{
  "event": "vivo.hints.update",
  "timestamp": "iso8601",
  "scope": {"symbol":"string","timeframe":"string","variant":"base|aggressive|conservative"},
  "proposed": {
    "entryNudgeBps": "number",
    "cooldownMsAdjust": "number",
    "positionSizingHint": "single|laddered",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  }
}

Ã‡Ä±ktÄ±lar (Supervisor Karar OlaylarÄ±)
// SL/TP/trailing gÃ¼ncellemesi (reduce-only dÃ¼zenlemeleri)
{
  "event": "order.modify.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "actions": [
    {
      "type": "move_sl|move_tp|enable_trailing|disable_trailing",
      "orderId": "string|null",
      "newPrice": "number|null",
      "callbackRateBps": "number|null",
      "reduceOnly": true
    }
  ],
  "reasonCodes": ["string"]
}

// Kademeli Ã§Ä±kÄ±ÅŸ / yeniden dengeleme
{
  "event": "position.rebalance.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "scaleOut": [{"ratio":"0..1","mode":"limit|market","price":"number|null"}],
  "reasonCodes": ["string"]
}

// Acil/korumacÄ± kapatma
{
  "event": "order.close.request",
  "timestamp": "iso8601",
  "correlationId": "string",
  "symbol": "string",
  "mode": "market|limit",
  "reasonCodes": ["string"]
}

// Bilgilendirme/telemetri
{
  "event": "vivo.supervisor.metrics",
  "timestamp": "iso8601",
  "symbol": "string",
  "p99_loop_ms": "number",
  "trailUpdates": "number",
  "scaleOuts": "number",
  "timeouts": "number",
  "emergencyCloses": "number"
}

{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["string"]}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

BracketReady, OrderUpdate, PositionSnapshot, MarketRefs, MarketTelemetry, ConnectivityHeartbeat, PolicySnapshot, VivoHintsUpdate.

SupervisorDecision (union: modify/scaleOut/close).

TrailingState, PositionState, PeakTracker, StagnationTimer.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlara runtime validasyon.

Event Bus KonularÄ±

In: order.bracket.ready, order.update, position.snapshot, market.refs, telemetry.market, connectivity.heartbeat, policy.snapshot, vivo.hints.update

Out: order.modify.request, position.rebalance.request, order.close.request, vivo.supervisor.metrics, vivo.supervisor.alert

Konfig & VarsayÄ±lanlar
{
  // Trailing
  trailingModeDefault: "chandelier_atr",      // "callback_bps" destekle
  chandelier: { atrPeriod: 14, k: { aggressive: 2.0, base: 2.5, conservative: 3.0 } },
  callbackBps: { aggressive: 80, base: 60, conservative: 45 },
  minTrailStepBps: 6,                         // yeni SL, eski SL'den en az bu kadar daha iyi olmalÄ±
  lockProfitAtR: 0.4,                         // realize edilmemiÅŸ R >= 0.4 ise SL'i break-even Ã¼stÃ¼ne kilitle

  // Stagnation / Timeout
  stagnation: { lookbackMins: 20, minATRMove: 0.5, action: "scale_out_25" },
  maxHoldMinsDefault: 180,                    // policy.maxHoldMins overrides

  // Abnormal rejim eÅŸikleri
  abnormal: {
    spreadBpsWarn: 20, spreadBpsPanic: 35,
    volZWarn: 1.6, volZPanic: 2.2
  },

  // BaÄŸlantÄ± / veri tazeliÄŸi
  freshness: { maxMarketGapMs: 3000, maxOrderGapMs: 5000, panicAfterMs: 8000 },

  // Risk & guard rails
  drawdownFromPeakR: { aggressive: 0.25, base: 0.35, conservative: 0.45 },  // policy ile clamp
  minQtyToAct: 1e-6,                        // step check Ã¼stÃ¼nde olmak zorunda
  preferStopMarketOnEmergency: true,

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

PositionStateStore (in-memory + periyodik persist data/supervisor.json):

key = symbol+side+tradeId

entryTime, avgPrice, qtyOpen, variant, tpSlStyle, bracketMode

Peak tracker: peakPrice (long iÃ§in max, short iÃ§in min), peakR

Trailing state: son SL fiyatÄ±, mod, callbackBps, son gÃ¼ncelleme zamanÄ±

Stagnation timer: son anlamlÄ± hareket zamanÄ± (ATR tabanlÄ±)

Freshness: son market/order heartbeat zamanÄ±

Algoritma (Karar AkÄ±ÅŸÄ±)

Ã–n KoÅŸullar & Freshness

marketStreamAlive==false veya now - lastMarketRef > freshness.maxMarketGapMs â†’ SAFE MODE:

EÄŸer borsada native SL yoksa acil SL yerleÅŸtir/gÃ¼ncelle (preferStopMarketOnEmergency).

Gap > panicAfterMs â†’ order.close.request(mode="market") (reason: data_stale_panic).

Peak & R HesabÄ±

Long: peakPrice = max(peakPrice, lastPrice); Short: min.

R = (lastPrice - avgPrice) / slDistance (long; kÄ±sa iÃ§in ters).

peakR gÃ¼ncellenir; drawdownFromPeakR ihlalinde:

SLâ€™i yeni trailing seviyesine taÅŸÄ± (minTrailStepBps koÅŸullu).

Retiestte tekrar ihlal olursa scale-out 25% veya close (policyâ€™ye gÃ¶re).

Trailing KuralÄ±

Chandelier ATR:

Long SL adayÄ± = peakPrice - k*ATR; Short = peakPrice + k*ATR.

Callback Bps:

Long SL adayÄ± = peakPrice * (1 - callbackBps/10000); Short simetrik.

newSL > oldSL + minTrailStepBps (long) ise order.modify.request(move_sl).

R â‰¥ lockProfitAtR â†’ SL break-even Ã¼stÃ¼ne alÄ±n.

Quiet hours + low liquidity â†’ trailing daha tutucu (k katsayÄ± +10%).

KÄ±smi TP / Rebalance

order.update.status=="filled" ve bir TP bacaÄŸÄ± dolduysa:

Kalan qtyâ€™ye gÃ¶re SL/TP yeniden proportional ayarlanÄ±r (reduce-only).

EÄŸer kalan qty Ã§ok kÃ¼Ã§Ã¼k (< minQtyToAct) â†’ order.close.request (temizle).

Stagnation / Timeout

stagnation.lookbackMins iÃ§inde ATR-normalize hareket < minATRMove ve R â‰¤ 0.2:

action "scale_out_25" â†’ position.rebalance.request (market veya yakÄ±n limit).

Devam ederse maxHoldMins dolumunda close.

Abnormal Spread/Vol

spreadBps â‰¥ spreadBpsPanic VEYA volZScore â‰¥ volZPanic:

SLâ€™i sÄ±kÄ±laÅŸtÄ±r, aggressive varyant geÃ§ici devre dÄ±ÅŸÄ± (alert yayÄ±nla).

Durum sÃ¼rerse scale-out 50% veya close (liquidityClass="low" ise market).

Ladder TP Senkronizasyonu

EmÃ¼lasyon modunda TP/SL Ã§ifti: TP tetiklenince karÅŸÄ± emir iptal/yeniden yerleÅŸtir (reduce-only ve kalan qtyâ€™ye gÃ¶re).

Native OCOâ€™da borsa halleder; yine de denetim iÃ§in order.update dinle, tutarsÄ±zlÄ±kta dÃ¼zelt.

Telemetri & Feedback

Her 10 sn: vivo.supervisor.metrics.

Kayda deÄŸer kararlar (move_sl, scale_out, close) iÃ§in vivo.supervisor.alert + reasonCodes.

VIVO-17â€™nin Ã¶ÄŸrenmesi iÃ§in outcome Ã¶zetini (trailUpdates, emergencyCloses) logla.

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel ile uyumlu)

Reduce-only zorunlu (futures); boyutu arttÄ±rma yok.

Slipaj ve limit kurallarÄ± korunur; acil durumlarda stop-market tercih edilir.

Bar kapanÄ±ÅŸÄ± kuralÄ±na saygÄ± (sinyal tarafÄ± zaten uyguluyor); burada yÃ¼rÃ¼tme gÃ¼venliÄŸi Ã¶ncelikli.

Kelly-light ve gÃ¼nlÃ¼k 2â€“3 iÅŸlem sÄ±nÄ±rÄ± baÅŸka modÃ¼llerde tutulur; Supervisor sadece aÃ§Ä±k pozisyonu korur.

Europe/Istanbul saat dilimi esas; quiet hoursâ€™ta trailing tutucu.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/livePositionSupervisor.ts

src/vivo/state/supervisorStore.ts (persist)

src/vivo/lib/trailing.ts (chandelier/callback hesaplarÄ±)

__tests__/livePositionSupervisor.test.ts

Mimari

Saf Ã§ekirdek: supervise(positionState, refs, policy, cfg, telemetry) â†’ SupervisorDecision[]

I/O adaptÃ¶rÃ¼: bus subscribe/publish; state persist; timers.

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlar finite(); eksik kritik veri â†’ SAFE MODE.

Zaman

connectivity.heartbeat ile drift takip; timeout hesaplarÄ±nda kullan.

Idempotency

AynÄ± SL seviyesine tekrar move_sl gÃ¶ndermeyi engelle (debounce/hash).

Loglama

Her karar traceId/correlationId ile auditlensin.

Test Ä°skeleti (Jest)

chandelier_atr â†’ SL adÄ±mÄ± doÄŸru ve minTrailStepBpsâ€™ten kÃ¼Ã§Ã¼kse gÃ¼ncelleme YOK

callback_bps â†’ peakPriceâ€™dan gerilemede SL yukarÄ± taÅŸÄ±nÄ±r

drawdownFromPeakR ihlali â†’ move_sl ardÄ±ndan tekrar ihlalde scale_out

stagnation 20dk + dÃ¼ÅŸÃ¼k R â†’ scale_out_25

maxHoldMins dolunca â†’ close

spreadâ‰¥panic veya volZâ‰¥panic â†’ emergency tighten â†’ close|scale_out

heartbeat gap > panicAfterMs â†’ data_stale_panic â†’ close market

TP fill â†’ SL/TP yeniden Ã¶lÃ§eklenir

Ã–rnek Senaryo (Ã–zet)

Durum

symbol=AVAXUSDT long, avgPrice=9.80, qtyOpen=120

ATR=0.22, variant=base, trailingMode=chandelier_atr(k=2.5)

peakPrice=10.45 â†’ trailSL = 10.45 - 2.5*0.22 = 9.90

current last=10.20, Râ‰ˆ(10.20-9.80)/((9.80 - initialSL)) ~ Ã¶rn. 0.6

Beklenen Kararlar

move_sl â†’ newPrice=9.90 (oldSL 9.72 idi; minTrailStepBps saÄŸlandÄ±)

20 dk boyunca ATR-normalize hareket < 0.5 ve R â‰¤ 0.2 â†’ position.rebalance.request(scaleOut 25%)

spreadBps=36 ve volZ=2.3 â†’ move_sl (daha sÄ±kÄ±) + order.close.request(mode="market") (likidite low ise)

Entegrasyon NotlarÄ±

VIVO-20â€™den sonra devrededir; bracket native/emÃ¼lasyon farkÄ±nÄ± gÃ¶zetir.

VIVO-17 geri besleme modÃ¼lÃ¼, Supervisorâ€™Ä±n scale_out/close oranlarÄ±nÄ± kullanÄ±p eÅŸikleri ayarlayabilir.

Throttler (VIVO-18) yeni iÅŸlem baÅŸlatma iÅŸini kÄ±sÄ±tlasa da, Supervisor aÃ§Ä±k pozisyonu her zaman korur.

correlationId zinciri ile uÃ§tan uca izlenebilirlik korunur.
_________________________________________________________________________________________________________________
VIVO-22 Â· postTradePerformanceLogger.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Her iÅŸlemin uÃ§tan-uca yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ kayda almak: giriÅŸ/partial-fill/TT L/escalation/SL-TP/manuel/timeout gibi tÃ¼m aÅŸamalar.

GerÃ§ekleÅŸen PnL (komisyon+slipaj+fonlama dÃ¼ÅŸÃ¼lmÃ¼ÅŸ net), R multiple, MFE/MAE, time-to-first-fill, time-in-trade ve slippage bps gibi metrikleri hesaplayÄ±p kalÄ±cÄ±laÅŸtÄ±rmak.

GÃ¼nlÃ¼k/haftalÄ±k simb olÃ—timeframeÃ—variantÃ—formationTag kÄ±rÄ±lÄ±mlarÄ±nda Ã¶zet KPIâ€™lar (PF, hitRate, avgR, expectancy, feeRatio, avgSlipBps, maxDD) Ã¼retmek.

VIVO-17 (executionFeedbackLooper) ve Denetim AsistanÄ± iÃ§in hem ham olay akÄ±ÅŸÄ± hem de normalize Ã¶zet saÄŸlamak.

TÃ¼m saat/tarih iÅŸlemleri Europe/Istanbul; bar kapanÄ±ÅŸÄ±/latency kurallarÄ± proje-genelle uyumlu. Idempotent ve tekrar Ã§alÄ±ÅŸtÄ±rÄ±labilir tasarla.

Girdiler (Event / JSON ÅemalarÄ±)
// execution.fill â€” (VIVO-20/Exchange adapter'Ä±ndan)
{
  "event": "execution.fill",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "formationTag": "string|null",
  "price": "number",
  "qty": "number",
  "fees": "number",
  "slippageBps": "number",
  "latencyMs": "number",
  "entryLegId": "string",
  "planRef": { "tpSlStyle": "ATR|range|hybrid", "plannedRR": "number", "slBasisDist": "number" }
}

// order.bracket.ready â€” (VIVO-20)
{
  "event": "order.bracket.ready",
  "timestamp": "iso8601",
  "correlationId": "string",
  "tradeId": "string",
  "mode": "native_oco|emulated",
  "slOrderId": "string",
  "tpOrderIds": ["string"]
}

// order.update â€” canlÄ± durum (SL/TP tetik, cancel/replace, vs.)
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number",
  "reason": "string|null"
}

// execution.close â€” pozisyon tamamen kapanÄ±nca (VIVO-20)
{
  "event": "execution.close",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "symbol": "string",
  "side": "long|short",
  "pnlQuote": "number",
  "rMultiple": "number",
  "exitReason": "tp|sl|timeout|manual|rule|emergency|liquidation",
  "holdingMins": "number",
  "feesTotal": "number",
  "slippageBpsAvg": "number"
}

// market.refs â€” giriÅŸ/Ã§Ä±kÄ±ÅŸ anÄ± baÄŸlamÄ± (opsiyonel ama tavsiye)
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "atr": {"period":14,"value":"number"},
  "range": {"swingHigh":"number","swingLow":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// policy.snapshot â€” politika Ã¼st sÄ±nÄ±rlarÄ± (okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"}
}

// vivo.supervisor.alert â€” (VIVO-21'den Ã¶nemli yol iÃ§i olaylar)
{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["string"]}
}

Ã‡Ä±ktÄ±lar (Logger OlaylarÄ±)
// Ham gÃ¼nlÃ¼k satÄ±rÄ± (append-only)
{
  "event": "trade.log.append",
  "timestamp": "iso8601",
  "tradeId": "string",
  "correlationId": "string",
  "phase": "entry|scale_in|bracket_ready|scale_out|tp_hit|sl_hit|timeout|manual|emergency|close",
  "payload": { "any": "json" }
}

// Normalize edilmiÅŸ kapatma Ã¶zeti (Ã¶ÄŸrenme ve rapor iÃ§in)
{
  "event": "trade.summary.closed",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "formationTag": "string|null",
  "entry": { "time": "iso8601", "avgPrice": "number", "notional": "number" },
  "exit": { "time": "iso8601", "avgPrice": "number", "reason": "tp|sl|timeout|manual|rule|emergency|liquidation" },
  "durMins": "number",
  "pnl": { "gross": "number", "fees":"number", "net":"number" },
  "rMultiple": "number",
  "slippageBpsAvg": "number",
  "path": { "mfeR": "number", "maeR": "number", "peakR": "number", "ddFromPeakR": "number" },
  "timings": { "tFirstFillMs": "number", "tToBracketMs":"number" },
  "flags": ["open_bar_entry?","quiet_hours","low_liquidity","high_vol","emergency_flow"],
  "audit": { "tpSlStyle":"ATR|range|hybrid","plannedRR":"number","slBasisDist":"number" }
}

// VIVO-17 iÃ§in ham Ã¶ÄŸrenme giriÅŸi (istenen sÃ¶zleÅŸme)
{
  "event": "vivo.feedback.raw",
  "timestamp": "iso8601",
  "scope": { "symbol":"string","timeframe":"string","variant":"base|aggressive|conservative","formationTag":"string|null" },
  "kpis": { "hit": "0|1", "profitFactor":"number", "rMultiple":"number", "slippageBps":"number", "fees":"number" },
  "samples": { "fills":"int" }
}

// GÃ¼nlÃ¼k roll-up KPI'larÄ±
{
  "event": "vivo.performance.daily",
  "date": "YYYY-MM-DD",
  "scope": { "symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null" },
  "kpis": {
    "trades":"int","wins":"int","hitRate":"number","profitFactor":"number","avgR":"number",
    "expectancyR":"number","avgSlipBps":"number","feeToGrossPct":"number","maxDD_R":"number"
  }
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

ExecFill, OrderBracketReady, OrderUpdate, ExecClose, MarketRefs, PolicySnapshot, SupervisorAlert.

TradeLogRow, TradeSummaryClosed, FeedbackRaw, DailyKpis.

YardÄ±mcÄ±: TradeSessionState, MfeMaeTracker, ClockDriftGuard.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: execution.fill, order.bracket.ready, order.update, execution.close, market.refs, policy.snapshot, vivo.supervisor.alert

Out: trade.log.append, trade.summary.closed, vivo.feedback.raw, vivo.performance.daily, vivo.logger.metrics, vivo.logger.alert

Konfig & VarsayÄ±lanlar
{
  // Depolama & elde tutma
  storage: { driver: "sqlite|json", file: "data/trades.db", retentionDays: 120 },

  // EWMA half-life (Ã¶rneklem)
  ewma: { slip: 10, r: 14 },

  // ZamanlandÄ±rma
  rollupFlushSec: 15,
  dailyCutoffHour: 0, // Europe/Istanbul'da gÃ¼n sonu

  // Anomali eÅŸikleri
  anomaly: {
    slipBpsHigh: 12,
    feeToGrossMaxPct: 0.40,
    tFirstFillSlowMs: 3000,
    dataGapPanicMs: 8000
  },

  // GÃ¼venlik & guard rails
  clamp: { rMultipleMin: -5, rMultipleMax: 5, slipBpsMaxAbs: 80 },

  // Telemetri
  metricsFlushSec: 10
}

Durum & KalÄ±cÄ±lÄ±k

TradeSessionState (in-memory + persist):

key = tradeId

startedAt, entryAvg, entryNotional, fills[], tFirstFillMs, tToBracketMs

mfeMae: {peakPrice, troughPrice, mfeR, maeR, peakR, ddFromPeakR}

lastMarketRef, lastOrderUpdate, openBarEntryFlag, quietHoursFlag, liquidityFlag, volZFlag

SQLite ÅŸema Ã¶nerisi: trades, fills, events, daily_kpis (indeksler: symbol, timeframe, variant, formationTag, date).

Algoritma (YÃ¼ksek Seviye AkÄ±ÅŸ)

BaÅŸlat / GÃ¼ncelle

Ä°lk execution.fill â†’ trade oturumu aÃ§; entryAvg, entryNotional, tFirstFillMs.

order.bracket.ready â†’ tToBracketMs hesapla.

Her order.update / market.refs â†’ MFE/MAE/peakR/ddFromPeakR gÃ¼ncelle.

vivo.supervisor.alert â†’ ilgili flagsâ€™e ekle (Ã¶rn. emergency_flow).

Slippage ve Ãœcret Muhasebesi

Fill bazÄ±nda slippageBps EWMA gÃ¼ncelle.

Ãœcretleri ve (varsa) fonlamayÄ± biriktir; feeToGrossPctâ€™yi sÄ±nÄ±rla/anomali iÅŸaretle.

KapanÄ±ÅŸ

execution.close geldiÄŸinde:

Net PnL = pnlQuote - fees - funding.

R multiple = netPnLQuote / (riskQuote); riskQuote = equity * riskPerTradePct (policyâ€™den) veya plan sl mesafesine gÃ¶re notional/SLdist; seÃ§ime gÃ¶re audit.slBasisDist ile kayda geÃ§.

TradeSummaryClosedâ€™Ä± Ã¼ret â†’ yayÄ±nla.

FeedbackRaw Ã¼ret â†’ VIVO-17 tÃ¼ketecek.

Roll-Up KPIâ€™larÄ±

GÃ¼n iÃ§inde kapananlar iÃ§in scope key (symbolÃ—tfÃ—variantÃ—formationTag) bazÄ±nda kÃ¼mÃ¼le et.

GÃ¼n sonunda (cutoff) vivo.performance.daily yayÄ±nla; maxDD_R kapalÄ± iÅŸlemler Ã¼zerinden (equity simÃ¼lasyonu yoksa close-to-close R drawdown).

Guard Rails

AykÄ±rÄ± deÄŸerleri clamp ile sÄ±nÄ±rla; uyarÄ± olarak vivo.logger.alert.

Zaman uyumsuzluÄŸu/eksik alan â†’ satÄ±rÄ± append et ama flags=["invalid_payload"] + alert.

Telemetri

10 snâ€™de bir vivo.logger.metrics: {p99_ingest_ms, rows_appended, summaries_published, anomalies}.

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel)

YÃ¼rÃ¼tme muhasebesi: Komisyon + slipaj + fonlama mutlaka dÃ¼ÅŸÃ¼lmÃ¼ÅŸ net PnL raporla.

Bar kapanÄ±ÅŸÄ± kuralÄ±: AÃ§Ä±k bar kaynaklÄ± giriÅŸ varsa flagsâ€™e iÅŸaretle; performans analizinde ayrÄ±ÅŸtÄ±rÄ±labilir olsun.

Kelly-light & gÃ¼nlÃ¼k 2â€“3 iÅŸlem: Logger politika deÄŸiÅŸtirmez; yalnÄ±zca raporlar.

Latency-safe: tFirstFillMs > anomaly.tFirstFillSlowMs ise â€œgeÃ§ giriÅŸâ€ uyarÄ±sÄ±.

PERCENT_PRICE / minNotional ihlali sonucu abort edilen planlar trade olarak sayÄ±lmaz; fakat trade.log.append(phase="abort") ile kaydedilir.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/postTradePerformanceLogger.ts

src/vivo/state/tradeStore.ts (SQLite/JSON sÃ¼rÃ¼cÃ¼)

src/vivo/lib/mfeMae.ts, src/vivo/lib/kpi.ts, src/vivo/lib/ewma.ts

__tests__/postTradePerformanceLogger.test.ts

Mimari

Saf Ã§ekirdek: ingest(event) â†’ updates[], close(tradeId) â†’ summary.

IO adaptÃ¶rÃ¼: bus subscribe/publish + storage persist + roll-up scheduler.

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlar finite(). HatalÄ± paket drop etme â€” iÅŸaretle ve alert yayÄ±nla.

Idempotency

(tradeId, eventId||hash) ile aynÄ± eventi iki kez iÅŸlememek iÃ§in WAL/idempotency anahtarÄ±.

Zaman & TZ

TÃ¼m aggregasyonlar Europe/Istanbul; gÃ¼nlÃ¼k cutoff 00:00 (konfig ile deÄŸiÅŸtirilebilir).

Test Ä°skeleti (Jest)

first fill â†’ session open & tFirstFillMs hesaplanÄ±r

bracket_ready â†’ tToBracketMs

mfe/mae/peakR/ddFromPeakR hesaplarÄ± (long/short senaryolarÄ±)

close â†’ netPnL, rMultiple, feeRatio, slip EWMA

abort edilen plan â†’ trade olarak sayÄ±lmaz

anomali eÅŸik aÅŸÄ±mlarÄ± â†’ logger.alert

idempotent ingest (aynÄ± event iki kez) â†’ tek kayÄ±t

daily roll-up â†’ doÄŸru PF, hitRate, avgR, expectancyR

Ã–rnek Senaryo (Ã–zet)

Girdiler (kÄ±saltÄ±lmÄ±ÅŸ)

execution.fill (3 kez, IOC+limit), toplam qty 1.5 ETH, avgFill 2950; tFirstFillMs=420

order.bracket.ready (emulated), tToBracketMs=2100

SÃ¼re boyunca market.refs ile peakR=0.9, ddFromPeakR=0.35 Ã¶lÃ§Ã¼ldÃ¼

execution.close: pnlQuote=+58.4, feesTotal=5.2, slippageBpsAvg=7.9, rMultiple=+0.78, exitReason=tp

Beklenen Ã‡Ä±ktÄ±

trade.summary.closed net PnL 53.2, path {mfeRâ‰ˆ0.95, maeRâ‰ˆ-0.18, peakRâ‰ˆ0.9, ddFromPeakRâ‰ˆ0.35}, timings {420,2100}

vivo.feedback.raw hit=1, pf>1, rMultiple=0.78, slip=7.9

GÃ¼n sonunda vivo.performance.daily LINKUSDT/ M15 / base / ascendingTriangle kÄ±rÄ±lÄ±mÄ±yla gÃ¼ncel KPIâ€™lar.

Entegrasyon NotlarÄ±

VIVO-17 bu modÃ¼lÃ¼n vivo.feedback.raw ve trade.summary.closed olaylarÄ±nÄ± birincil veri kaynaÄŸÄ± olarak kullanmalÄ±.

Denetim AsistanÄ± ve raporlama katmanÄ±, daily_kpis ve trade.summary.closed ile haftalÄ±k rapor Ã§Ä±karabilir.

VIVO-21â€™den gelen alert ve path metrikleri (drawdown, emergency) flags iÃ§inde tutulur; gelecekte neden-sonuÃ§ analizi iÃ§in kullanÄ±lacak.
_________________________________________________________________________________________________________________
VIVO-23 Â· riskBreachIncidentReporter.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Risk ve politika ihlallerini anÄ±nda tespit edip olay (â€œincidentâ€) olarak aÃ§mak, izlemek ve kapatmak.

OlaylarÄ± sÄ±nÄ±flandÄ±rmak (taxonomi), kÃ¶k neden (root-cause) ve katkÄ± faktÃ¶rleri ile kayda geÃ§irmek.

YÃ¶netiÅŸim Ã¶nerileri Ã¼retmek (Ã¶r. â€œcooldown uygulaâ€, â€œaggressive varyantÄ± kapatâ€, â€œyeni niyetleri durdurâ€).

VIVO-17 (feedback) ve Denetim AsistanÄ± iÃ§in Ã¶ÄŸrenme olayÄ± yayÄ±nlamak.

Bu modÃ¼l karar vermez (trade aÃ§/kapat). Ã–nerileri yayÄ±mlar; uygulama yetkisi Policy/LIVIA ve ilgili modÃ¼llerdedir.

Girdiler (Event / JSON ÅemalarÄ±)
// policy.snapshot â€” Ã¼st sÄ±nÄ±rlar
{
  "event": "policy.snapshot",
  "riskPerTradePct": 0.5,
  "dailyMaxTrades": 3,
  "kellyCap": 0.25,
  "maxConcurrentPerSymbol": 1,
  "globalMaxConcurrent": 3,
  "confirmationBounds": {"min":0.55,"max":0.72}
}

// livia.guard â€” acil durum / seri kayÄ±p
{
  "event": "livia.guard",
  "cooldownActive": true,
  "seriesLoss": {"lastN": 5, "lossCount": 3},
  "emergency": "none|slowdown|halt"
}

// account.exposure â€” aÃ§Ä±k risk ve pozisyonlar
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {"symbol":"string","side":"long|short","qty":1.23,"riskPct":0.6}
  ],
  "totalRiskPctOpen": 1.8
}

// execution.intent.* â€” throttler kararlarÄ±
{
  "event": "execution.intent.rejected|execution.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["daily_limit_hit","risk_cap_reached","per_symbol_concurrency","burst_limit","emergency_halt"],
  "correlationId": "string"
}

// order.execution.error â€” yÃ¼rÃ¼tme hatalarÄ± (VIVO-20)
{
  "event": "order.execution.error",
  "timestamp": "iso8601",
  "correlationId": "string",
  "stage": "placing_entry|placing_bracket|monitoring|cancel_replace|failover",
  "code": "network|ratelimit|percent_price|min_notional|insufficient_margin|unknown",
  "detail": "string"
}

// vivo.supervisor.alert â€” aÃ§Ä±k pozisyonda riskli durumlar (VIVO-21)
{
  "event": "vivo.supervisor.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "correlationId": "string",
  "context": {"symbol":"string","reasonCodes":["data_stale_panic","abnormal_spread","abnormal_vol","drawdown_breach"]}
}

// trade.summary.closed â€” iÅŸlem kapanÄ±ÅŸÄ± (VIVO-22)
{
  "event": "trade.summary.closed",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "timeframe": "string",
  "variant": "base|aggressive|conservative",
  "rMultiple": "number",
  "pnl": {"gross":"number","fees":"number","net":"number"},
  "path": {"peakR":"number","ddFromPeakR":"number"},
  "flags": ["quiet_hours","open_bar_entry","emergency_flow"]
}

// telemetry.market â€” rejim/likidite sinyalleri (opsiyonel)
{
  "event": "telemetry.market",
  "timestamp": "iso8601",
  "symbol": "string",
  "spreadBps": "number",
  "volZScore": "number",
  "liquidityClass": "low|mid|high"
}

Ã‡Ä±ktÄ±lar (Incident & Ã–neri OlaylarÄ±)
// Olay aÃ§ma
{
  "event": "risk.incident.open",
  "timestamp": "iso8601",
  "incidentId": "RIS-20250901-AVAXUSDT-0001",
  "type": "policy_violation|exposure_breach|series_loss|drawdown_breach|limit_breach|execution_anomaly|data_staleness|emergency_halt|governance_override",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "correlationId": "string|null",
  "rootCause": {"trigger":"string","immediate":"string","contributing":["string"]},
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "openReasonCodes": ["string"]
}

// Olay gÃ¼ncelleme (tekrar ihlal, metrik gÃ¼ncel, seviye artÄ±ÅŸÄ±)
{
  "event": "risk.incident.update",
  "timestamp": "iso8601",
  "incidentId": "string",
  "severity": "low|medium|high|critical",
  "appendReasonCodes": ["string"],
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "notes": "string"
}

// Olay kapatma (iyileÅŸme/recovery)
{
  "event": "risk.incident.closed",
  "timestamp": "iso8601",
  "incidentId": "string",
  "resolution": "auto_recovered|manual_intervention|policy_applied|timeout",
  "durationSec": "number",
  "finalNotes": "string"
}

// YÃ¶netiÅŸim Ã¶nerisi (uygulama Policy/LIVIAâ€™da)
{
  "event": "risk.governance.recommendation",
  "timestamp": "iso8601",
  "incidentId": "string",
  "recommendations": [
    "apply_cooldown_30m",
    "halt_new_intents_10m",
    "disable_aggressive_variant_2h",
    "tighten_confirmation_by_0.01",
    "reduce_risk_per_trade_to_0.5pct",
    "limit_per_symbol_per_hour_to_1"
  ],
  "rationale": ["string"]
}

// VIVO-17 Ã¶ÄŸrenmesi iÃ§in Ã¶zet
{
  "event": "vivo.feedback.incident",
  "timestamp": "iso8601",
  "type": "string",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "reasonCodes": ["string"]
}

Taxonomi & Haritalama (Reason â†’ Incident Type)

policy_violation: daily_limit_hit, per_symbol_concurrency, burst_limit, confirmation_out_of_bounds

exposure_breach: risk_cap_reached, totalRiskPctOpen > cfg.maxTotalRiskPctOpen

series_loss: livia.guard.seriesLoss.lossCount >= cfg.seriesLoss.minLosses

drawdown_breach: vivo.supervisor.alert.reasonCodes iÃ§inde drawdown_breach veya trade.summary.closed.path.ddFromPeakR â‰¥ cfg.ddFromPeakR[variant]

limit_breach: percent_price|min_notional (order.execution.error)

execution_anomaly: ratelimit|network|failover_excess|slippage_excess

data_staleness: data_stale_panic (supervisor) veya heartbeats eksikliÄŸi (baÅŸka modÃ¼lden geliyorsa)

emergency_halt: livia.guard.emergency == "halt"

TypeScript ArayÃ¼zleri (Ã¼rettir)

PolicySnapshot, LiviaGuard, AccountExposure

IntentDecision (rejected/deferred), ExecError, SupervisorAlert, TradeSummaryClosed, MarketTelemetry

RiskIncidentOpen|Update|Closed, GovernanceRecommendation, IncidentFeedback

YardÄ±mcÄ±: IncidentState, IncidentKey (type+symbol+timeframe), Severity

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: policy.snapshot, livia.guard, account.exposure, execution.intent.*, order.execution.error, vivo.supervisor.alert, trade.summary.closed, telemetry.market

Out: risk.incident.open, risk.incident.update, risk.incident.closed, risk.governance.recommendation, vivo.feedback.incident, risk.incident.metrics, risk.incident.alert

Konfig & VarsayÄ±lanlar
{
  // EÅŸikler
  "maxTotalRiskPctOpen": 2.0,
  "seriesLoss": { "window": 5, "minLosses": 3 },
  "ddFromPeakR": { "aggressive": 0.25, "base": 0.35, "conservative": 0.45 },
  "slippageBpsHard": 15,
  "spreadBpsPanic": 35,
  "volZPanic": 2.2,

  // Olay Ã¶mrÃ¼
  "dedupeWindowSec": 600,               // aynÄ± type+symbol iÃ§in tek aÃ§Ä±k olay
  "autoCloseQuietSec": 1800,            // ihlal yoksa otomatik kapanÄ±ÅŸ
  "escalateAfterRepeats": 2,            // tekrar sayÄ±sÄ±nda seviye artÄ±r

  // Ã–neri ÅŸablonlarÄ±
  "recommendationProfiles": {
    "series_loss": ["apply_cooldown_30m","disable_aggressive_variant_2h"],
    "exposure_breach": ["halt_new_intents_10m","reduce_risk_per_trade_to_0.5pct"],
    "data_staleness": ["halt_new_intents_10m"],
    "execution_anomaly": ["tighten_confirmation_by_0.01"]
  },

  // Telemetri
  "metricsFlushSec": 10,
  "tz": "Europe/Istanbul"
}

Durum YÃ¶netimi

IncidentStateStore (in-memory + periyodik persist data/incidents.json veya SQLite):

openByKey: Map<IncidentKey, IncidentRecord>

history: append-only gÃ¼nlÃ¼k

SayaÃ§lar: tekrar sayÄ±sÄ±, son gÃ¶rÃ¼lme, ilk/son zaman damgasÄ±

Algoritma (Karar AkÄ±ÅŸÄ±)

Normalize & SÄ±nÄ±flandÄ±r

OlayÄ± Zod ile doÄŸrula, reasonâ†’type eÅŸle.

IncidentKey = type + (symbol||"*") + (timeframe||"*").

De-dupe & AÃ§/Kor

dedupeWindowSec iÃ§inde aynÄ± IncidentKey aÃ§Ä±k ise update yap; deÄŸilse open.

escalateAfterRepeats eÅŸiÄŸinde severity bir kademe artÄ±r.

KÃ¶k Neden & FaktÃ¶rler

rootCause.trigger = tetikleyen olay (Ã¶r. daily_limit_hit).

immediate = doÄŸrudan ihlal (Ã¶r. totalRiskPctOpen 2.1%).

contributing = liquidityClass=low, volZ>2.2, quiet_hours, network.

Metrik Ata

MÃ¼mkÃ¼nse totalRiskPctOpen, ddFromPeakR, slipBps gibi sayÄ±larÄ± doldur.

Ã–neri Ãœret

recommendationProfiles[type] starting set; baÄŸlama gÃ¶re ekle/Ã§Ä±kar:

severity=="critical" â†’ halt_new_intents_10m ekle.

variant=="aggressive" ve tekrar varsa â†’ disable_aggressive_variant_2h.

YayÄ±nla

risk.incident.open|update + risk.governance.recommendation + vivo.feedback.incident.

KapanÄ±ÅŸ

autoCloseQuietSec boyunca yeni ihlal yoksa risk.incident.closed(resolution="auto_recovered").

livia.guard.emergency=="halt" kalkÄ±nca ve metrikler normalleÅŸince kapat.

Telemetri

10 snâ€™de bir risk.incident.metrics: {open_incidents, updates, closes, critical_rate}.

Ã–nemli durumlarda risk.incident.alert(level="warn|error").

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/riskBreachIncidentReporter.ts

src/vivo/state/incidentStore.ts

src/vivo/lib/incidentMap.ts (reasonâ†’type, severity baÅŸlangÄ±cÄ±)

__tests__/riskBreachIncidentReporter.test.ts

Mimari

Saf Ã§ekirdek: ingest(event, state, cfg) â†’ emissions[].

I/O adaptÃ¶rÃ¼: bus subscribe/publish + persist + periodic auto-close timer.

Validasyon

TÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸ Zod; bilinmeyen reasonâ€™lar execution_anomaly altÄ±na graceful dÃ¼ÅŸsÃ¼n (notes ile).

Idempotency

AynÄ± olay tekrar gelirse eventHash ile yoksay (historyâ€™ye tek satÄ±r).

Log/Audit

TÃ¼m aÃ§Ä±k olaylar traceId/correlationId ile izlenebilir; kapanÄ±ÅŸta sÃ¼resini yaz.

Test Ä°skeleti (Jest)

daily_limit_hit â†’ policy_violation(open); tekrarÄ±nda update + severityâ†‘

totalRiskPctOpen>2% â†’ exposure_breach(open); normalleÅŸince auto_close

seriesLoss(â‰¥3/5) â†’ series_loss(open); Ã¶neri: cooldown + aggressive off

order.execution.error(percent_price) â†’ limit_breach(open)

supervisor data_stale_panic â†’ data_staleness(critical); Ã¶neri: halt_new_intents

drawdown_breach from trade.summary.closed â†’ drawdown_breach(open)

unknown reason â†’ execution_anomaly(open); graceful degrade

dedupeWindowSec iÃ§inde ikinci aynÄ± olay â†’ update, open sayÄ±sÄ± artmaz

Ã–rnek Senaryo (Ã–zet)

Girdiler

execution.intent.rejected reason=risk_cap_reached, account.exposure.totalRiskPctOpen=2.3

3 dk sonra vivo.supervisor.alert reason=abnormal_spread (spread=38 bps)

15 dk ihlal yok

Beklenen YayÄ±nlar

{
  "event":"risk.incident.open",
  "type":"exposure_breach",
  "severity":"high",
  "scope":{"symbol":null,"timeframe":null,"variant":null},
  "metrics":{"totalRiskPctOpen":2.3},
  "openReasonCodes":["risk_cap_reached"]
}

{
  "event":"risk.governance.recommendation",
  "incidentId":"RIS-...","recommendations":["halt_new_intents_10m","reduce_risk_per_trade_to_0.5pct"],
  "rationale":["open_risk_2.3pct_over_2.0pct","recent_abnormal_spread"]
}


15 dk sonra:

{"event":"risk.incident.closed","resolution":"auto_recovered","durationSec":900}

Entegrasyon NotlarÄ±

VIVO-18 Throttler ve VIVO-21 Supervisorâ€™dan gelen reasonâ€™lar bu modÃ¼lÃ¼ tetikler.

Policy/LIVIA risk.governance.recommendation olaylarÄ±nÄ± dinleyerek gerÃ§ekte uygular (cooldown/slowdown/halt).

VIVO-17 vivo.feedback.incident ile eÅŸiklerini yeniden ayarlarken incident tip ve ÅŸiddetini dikkate alÄ±r.

Denetim AsistanÄ± haftalÄ±k raporlarÄ±nda incident history + governance uygulama oranÄ± KPIâ€™larÄ±nÄ± kullanÄ±r.
_________________________________________________________________________________________________________________
VIVO-24 Â· signalQualityAssurance.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

GrafiÌ‡k Beyni ve diÄŸer kaynaklardan gelen sinyalleri yayÄ±nlanmadan Ã¶nce â€œfail-fastâ€ kalite kontrolÃ¼nden geÃ§irmek:

Åema/alan validasyonu, tazelik (freshness), bar kapanÄ±ÅŸÄ± kuralÄ±,

Anomali damgalarÄ± (uÃ§ deÄŸer, z-score sapmasÄ±, open-bar, clock-skew, replay),

Rejim uyumu ve likidite filtreleri,

TekilleÅŸtirme / anti-replay ve kaynak gÃ¼ven katmanÄ±,

Ã–zelliklerin normalize/standartlaÅŸtÄ±rÄ±lmasÄ± ve qualityScore hesaplanmasÄ±.

SonuÃ§ olarak sinyali geÃ§ir, ertele (hold) veya reddet; gerekÃ§eleri ve metrikleri yayÄ±mla.

Bu modÃ¼l â€œkalite kapÄ±sÄ±dÄ±râ€. Karar Ã¼retmez; temizlenmiÅŸ sinyali VIVO-16 signalDecisionRouterâ€™a iletir.

Girdiler (Event / JSON ÅemalarÄ±)
// signal.envelope.raw â€” Grafik Beyni ve diÄŸer Ã¼reticilerden gelir (ham)
{
  "event": "signal.envelope.raw",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",               // M1|M5|M15|H1|H4|D1...
  "source": "string",                  // formation.breakout|orderflow.imbalance|ext.alphaX ...
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number"
  },
  "vivoHints": {
    "confirmationThreshold": "number|null",
    "signalVariant": "base|aggressive|conservative|null",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number|null",
    "barState": "open|closed|null"     // sinyal Ã¼retildiÄŸi anda bar durumu
  }
}

// market.refs â€” Ã§apraz doÄŸrulama baÄŸlamÄ±
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "bestBid": "number",
  "bestAsk": "number",
  "atr": {"period":14,"value":"number"},
  "spreadBps": "number",
  "volZScore": "number"
}

// regime.snapshot â€” rejim tespiti (Grafik Beyni veya ayrÄ±)
{
  "event": "regime.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "regime": "trend|range|breakout|highVol|illiquid"
}

// exchange.info â€” sembol filtreleri (tick/step/minNotional vs. doÄŸrulama iÃ§in opsiyonel)
{
  "event": "exchange.info",
  "symbol": "string",
  "filters": {"tickSize":"number","stepSize":"number","minNotional":"number"}
}

// connectivity.heartbeat â€” veri tazeliÄŸi izleme
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "marketStreamAlive": "boolean",
  "latencyMs": "number"
}

Ã‡Ä±ktÄ±lar (QA KararÄ± & Telemetri)
// GeÃ§en sinyal (temizlenmiÅŸ/enriched) â†’ VIVO-16
{
  "event": "signal.envelope",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "features": {
    "trendStrength": "number",
    "rrScore": "number",
    "volatility": "number",
    "orderflowBias": "number",
    "zScores": {"trend":"number","rr":"number","vol":"number","of":"number"}   // eklenti
  },
  "vivoHints": {
    "confirmationThreshold": "number|null",
    "signalVariant": "base|aggressive|conservative|null",
    "biasWeightedTune": {"trend":"number","orderflow":"number","formation":"number"}
  },
  "qa": {
    "qualityScore": "0..1",
    "tags": ["string"],                       // open_bar, high_vol, illiquid, clock_skew...
    "reasonCodes": ["string"],                // pass gerekÃ§eleri ve cezalar
    "sourceTier": "core|experimental|external",
    "freshnessMs": "number"
  },
  "meta": {
    "signalId": "string",
    "formationTag": "string|null",
    "latencyMs": "number|null",
    "barState": "open|closed|null"
  }
}

// Reddedilen sinyal (log & izleme)
{
  "event": "signal.qa.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "signalId": "string",
  "reasonCodes": ["invalid_payload","stale","duplicate_id","illiquid_block","clock_skew","anomaly_outlier"],
  "qa": {"qualityScore":"0..1","tags":["string"]}
}

// Erteleme (bar kapanÄ±ÅŸÄ± veya veri eksikliÄŸi nedeniyle)
{
  "event": "signal.qa.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "source": "string",
  "signalId": "string",
  "deferUntil": "iso8601",
  "reasonCodes": ["await_bar_close","await_market_refs","network_latency_high"]
}

// Telemetri
{
  "event": "signal.qa.metrics",
  "timestamp": "iso8601",
  "p99_ms": "number",
  "pass_rate": "number",
  "reject_rate": "number",
  "defer_rate": "number",
  "dup_drop_rate": "number",
  "avg_quality": "number"
}

{
  "event": "signal.qa.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string","source":"string","reasonCodes":["string"]}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

RawSignalEnvelope, CleanSignalEnvelope, QABlock, QAMetrics, QAReject, QADefer.

BaÄŸlam: MarketRefs, RegimeSnapshot, ExchangeInfo, ConnectivityHeartbeat.

YardÄ±mcÄ±: BaselineStats (rolling mean/std/z), DedupKey, BloomLikeSet.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon; NaN/âˆ/null sapmalarÄ± yakala.

Event Bus KonularÄ±

In: signal.envelope.raw, market.refs, regime.snapshot, exchange.info, connectivity.heartbeat

Out: signal.envelope (temiz), signal.qa.rejected, signal.qa.deferred, signal.qa.metrics, signal.qa.alert

Konfig & VarsayÄ±lanlar
{
  // Tazelik pencereleri (timeframe'e gÃ¶re max timestamp drift)
  freshnessMsByTF: { "M1": 3000, "M5": 5000, "M15": 8000, "H1": 15000, "H4": 30000, "D1": 60000 },

  // Bar kapanÄ±ÅŸÄ± politikasÄ±
  openBarPolicy: { mode: "penalize|defer|block", penalty: 0.04, deferMs: 5000 },

  // Kaynak gÃ¼ven katmanÄ±
  sourceTiers: { "formation.breakout": "core", "orderflow.imbalance": "core", "ext.alphaX": "experimental", "*": "external" },
  minQualityByTier: { "core": 0.58, "experimental": 0.64, "external": 0.68 },

  // Rejim/likidite filtreleri
  illiquidBlock: true,
  highVolPenalty: 0.03,       // regime=highVol ise qualityScore cezalarÄ±
  illiquidPenalty: 0.06,

  // Ã–zellik normalizasyonu (clamp & z-score)
  featureClamp: { min: -3, max: 3 },         // normalized alanlarda
  zScoreWindow: 200,                          // rolling baseline Ã¶rnek sayÄ±sÄ±

  // Anti-duplicate / replay
  dedupe: { windowMs: 1500, keyFields: ["symbol","side","timeframe","source","meta.signalId"] },

  // Clock skew & latency
  maxClockSkewMs: 2000,
  highLatencyPenalty: 0.03,

  // QualityScore aÄŸÄ±rlÄ±klarÄ±
  qualityWeights: {
    payload: 0.30,     // ÅŸema/alan bÃ¼tÃ¼nlÃ¼ÄŸÃ¼, clamp ihlalsiz
    freshness: 0.20,   // tazelik, clock skew yok
    barClose: 0.10,    // closed bar avantajÄ±
    regimeFit: 0.15,   // rejim-formation uyumu
    sourceTrust: 0.15, // tier aÄŸÄ±rlÄ±ÄŸÄ±
    anomalySafe: 0.10  // z-score ve uÃ§-deÄŸer kontrolleri
  },

  // Anomali/Outlier eÅŸikleri
  outlier: { zAbsMax: 3.5, rrMin: 0.0, rrMax: 1.0, trendMin: 0.0, trendMax: 1.0 },

  // Defer bekleme
  awaitRefsMaxMs: 4000,

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

QABaselineStore (in-memory + periyodik persist data/qa.baseline.json):

Rolling mean/std (trendStrength, rrScore, volatility, orderflowBias), count.

Son gÃ¶rÃ¼len market.refs ve regime.snapshot timestamps (tazelik).

DedupLRU/Bloom set (key â†’ expiresAt).

QAMetricsState: kaydÄ±rmalÄ± sayaÃ§lar (pass/reject/defer/dup_drop, p99 loop ms, avg_quality).

Algoritma (Karar AkÄ±ÅŸÄ±)

Åema & Tip Validasyonu

Zod ile RawSignalEnvelope doÄŸrula. SayÄ±sal alanlar finite(); rrScore, trendStrength, orderflowBias â†’ [0,1] clamp.

HatalÄ± â†’ reject("invalid_payload"); signal.qa.rejected yayÄ±nla.

De-dupe & Anti-Replay

DedupKey = join(cfg.dedupe.keyFields) + Math.floor(timestamp/cfg.dedupe.windowMs) dilimi.

Varsa â†’ reject("duplicate_id"); yoksa sete ekle (TTL = windowMs).

Tazelik & Saat KaymasÄ±

now - timestamp > freshnessMsByTF[timeframe] â†’ reject("stale").

|timestamp - now| > maxClockSkewMs â†’ penalize (clock_skew) veya reject (skew Ã§ok bÃ¼yÃ¼kse).

Bar KapanÄ±ÅŸÄ± PolitikasÄ±

meta.barState=="open":

openBarPolicy.mode=="penalize" â†’ qualityScore âˆ’ penalty, qa.tags += ["open_bar"].

"defer" â†’ deferred (deferUntil = bar kapanÄ±ÅŸÄ± tahmini).

"block" â†’ reject("open_bar").

Piyasa ReferanslarÄ± & Rejim

Son market.refs taze mi? DeÄŸilse defer("await_market_refs"), en fazla awaitRefsMaxMs.

regime.snapshot.regime == "illiquid" â†’ illiquidBlock ? reject : penalize.

regime=="highVol" â†’ penalize (highVolPenalty).

Formation uyumu:

formationTag â€œbreakoutâ€ & regime â€œrangeâ€ â†’ kÃ¼Ã§Ã¼k ceza.

formationTag â€œmeanRevertâ€ & regime â€œtrendâ€ â†’ ceza.

EÅŸleÅŸen kombinasyonlara mini bonus (0.01â€“0.02).

Anomali/Outlier Kontrolleri

Rolling baselineâ€™dan z-score hesapla; herhangi bir Ã¶zelliÄŸin |z|> outlier.zAbsMax â†’ reject("anomaly_outlier").

rrScore, trendStrength gibi [0,1] dÄ±ÅŸÄ± deÄŸerler clamp sonrasÄ± bÃ¼yÃ¼k sapma yaratÄ±yorsa penalize("clamp_hit").

Kaynak GÃ¼veni & EÅŸikler

sourceTier = cfg.sourceTiers[source] || "external".

qualityScore hesapla (aÄŸÄ±rlÄ±klar).

qualityScore < minQualityByTier[sourceTier] â†’ reject("quality_below_tier_min").

ZenginleÅŸtirme ve YayÄ±n

features.zScores alanÄ±nÄ± ekle, qa.tags ve reasonCodesâ€™u doldur.

pass ise signal.envelope olarak yayÄ±nla.

defer ise signal.qa.deferred (tekrar deneme iÃ§in) yayÄ±nla.

Metrikler & UyarÄ±lar

SayaÃ§larÄ± ve p99 dÃ¶ngÃ¼ sÃ¼resini gÃ¼ncelle; signal.qa.metrics her 10 snâ€™de yayÄ±nla.

Seri stale veya illiquid_block artarsa alert Ã¼ret.

GerÃ§ek DÃ¼nya KurallarÄ± (Proje-genel uyumlu)

Fail-fast: Åema/tazelik ihlali anÄ±nda reject; â€œyumuÅŸatmayaâ€ Ã§alÄ±ÅŸma.

Idempotency: AynÄ± ham sinyal tekrar iÅŸlense aynÄ± DedupKey ile drop edilir.

Open Bar: VarsayÄ±lan penalize; VIVO-16 zaten aÃ§Ä±k barlarÄ± cezalÄ± ele alÄ±r.

Likidite: â€œilliquidâ€ rejiminde agresif varyantlar sistemin diÄŸer katmanlarÄ±nda da kÄ±sÄ±tlÄ±; burada blok/ceza â€œilk bariyerâ€.

TZ: Europe/Istanbul; bar kapanÄ±ÅŸÄ± tahminlerinde local saate gÃ¶re hesap.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/signalQualityAssurance.ts

src/vivo/state/qaStore.ts (baseline + dedupe + metrics persist)

src/vivo/lib/zscore.ts, src/vivo/lib/qualityScore.ts

__tests__/signalQualityAssurance.test.ts

Mimari

Saf Ã§ekirdek: qaCheck(raw, ctx, cfg) â†’ {decision: "pass|defer|reject", emissions[]}

I/O adaptÃ¶rÃ¼: bus subscribe/publish + ctx cache (market.refs, regime.snapshot).

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlara finite(), [0,1] beklenenleri clamp + tag.

Bilinmeyen alanlar â†’ warn ve ignore; drop etme (fail-fast yalnÄ±zca kritiklerde).

Performans

p99 < 5ms hedef; z-score iÃ§in O(1) gÃ¼ncellenen â€œrolling mean/stdâ€ uygula.

Idempotency

signalId + zaman dilimi anahtarÄ±yla tekrar iÅŸlemleri Ã¶nle.

Log/Audit

TÃ¼m kararlar traceId/correlationId (yoksa Ã¼ret) ile auditlenir.

Test Ä°skeleti (Jest)

invalid payload â†’ reject(invalid_payload)

duplicate within window â†’ reject(duplicate_id)

stale timestamp (M1>3s) â†’ reject(stale)

openBar penalize|defer|block davranÄ±ÅŸÄ±

illiquid regime + illiquidBlock=true â†’ reject(illiquid_block)

highVol â†’ qualityScore penalty uygulandÄ±

outlier z>|3.5| â†’ reject(anomaly_outlier)

experimental source quality < min â†’ reject(quality_below_tier_min)

await market refs â†’ deferred & tekrar denemede pass

metrics counters & p99 loop gÃ¼ncellenir

Ã–rnek Senaryo (Ã–zet)

Girdi (ham)

{
  "event":"signal.envelope.raw",
  "timestamp":"2025-09-01T07:12:05Z",
  "symbol":"AVAXUSDT","side":"long","timeframe":"M5",
  "source":"formation.breakout",
  "features":{"trendStrength":0.68,"rrScore":0.66,"volatility":0.92,"orderflowBias":0.51},
  "vivoHints":{"confirmationThreshold":0.62,"signalVariant":"base","biasWeightedTune":{"trend":0.5,"orderflow":0.3,"formation":0.2}},
  "meta":{"signalId":"sig-889","formationTag":"ascendingTriangle","latencyMs":420,"barState":"open"}
}


BaÄŸlam

market.refs (taze), spreadBps=9, volZScore=1.4

regime.snapshot.regime="trend"

openBarPolicy.mode="penalize" (0.04)

Beklenen Ã‡Ä±ktÄ± (Ã¶zet)

{
  "event":"signal.envelope",
  "symbol":"AVAXUSDT","side":"long","timeframe":"M5","source":"formation.breakout",
  "features":{"trendStrength":0.68,"rrScore":0.66,"volatility":0.92,"orderflowBias":0.51,
    "zScores":{"trend":0.7,"rr":0.5,"vol":1.1,"of":0.2}},
  "qa":{"qualityScore":0.62,"tags":["open_bar"],"reasonCodes":["payload_ok","fresh_ok","bar_penalize","regime_fit"],"sourceTier":"core","freshnessMs":1200},
  "meta":{"signalId":"sig-889","formationTag":"ascendingTriangle","latencyMs":420,"barState":"open"}
}


(EÅŸikleri aÅŸmayan kalite â†’ pass; open-bar nedeniyle quality -0.04 ceza.)

Entegrasyon NotlarÄ±

VIVO-16 signalDecisionRouter bu modÃ¼lden geÃ§en signal.envelopeâ€™Ä± tÃ¼ketir; qa.qualityScore ve qa.tags karar sÃ¼recine ipucu olur.

VIVO-18 Throttler ve VIVO-21 Supervisor aÃ§Ä±k-bar / highVol etiketlerine gÃ¶re daha korumacÄ± davranabilir.

VIVO-17 Feedback â€œqa.rejected/deferredâ€ oranlarÄ±nÄ± izleyip confirmationThreshold Ã¶nerilerini ayarlarken QA Ã§Ä±ktÄ±larÄ±nÄ± kullanÄ±r.
_________________________________________________________________________________________________________________
VIVO-25 Â· portfolioExposureBalancer.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Yeni kabul edilmiÅŸ iÅŸlem niyeti (VIVO-18) gelmeden Ã¶nce/gelir gelmez, portfÃ¶yÃ¼n toplam risk tavanÄ±, kÃ¼me (cluster) limitleri ve korelasyon-temelli marjinal riske gÃ¶re dengelemek.

AÅŸÄ±rÄ± korelasyonlu/aynÄ± kÃ¼meye yÄ±ÄŸÄ±lmÄ±ÅŸ pozisyonlarÄ± yumuÅŸak (downscale) veya sert (reject/defer) biÃ§imde yÃ¶netmek.

Net yÃ¶n sapmasÄ± (long vs short), beta/faktÃ¶r yoÄŸunluÄŸu ve tekil enstrÃ¼man tavanlarÄ±nÄ± uygulamak.

Ã‡Ä±ktÄ±: portfolio.intent.approved|adjusted|deferred|rejected (gerekirse risk yÃ¼zdesi dÃ¼ÅŸÃ¼rÃ¼lmÃ¼ÅŸ).

Bu katman boyutu yÃ¼kseltmez; yalnÄ±zca aynÄ± tutar bÄ±rakÄ±r veya azaltÄ±r/bloklar. YÃ¼rÃ¼tme planlamasÄ± VIVO-19â€™dadÄ±r.

Girdiler (Event / JSON ÅemalarÄ±)
// execution.intent.accepted â€” throttler'dan sonra gelen kabul edilmiÅŸ niyet (giriÅŸ)
{
  "event": "execution.intent.accepted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "timeframe": "string",
  "selectedVariant": "base|aggressive|conservative",
  "confidence": "0..1",
  "constraints": { "riskProfile": "tight|normal|relaxed" },
  "tuning": { "positionScaling": "single|laddered" },
  "audit": { "upstream": {"source":"string","signalId":"string"} }
}

// account.exposure â€” aÃ§Ä±k pozisyonlar ve aÃ§Ä±k risk
{
  "event": "account.exposure",
  "timestamp": "iso8601",
  "openPositions": [
    {
      "symbol":"string","side":"long|short",
      "riskPct":"number",                 // iÅŸlemde risklenen % (equity'e gÃ¶re)
      "cluster":"L1|L2|DeFi|Layer1|AI|PerpAlts|BTCComplex|StablePair|Other",
      "beta":{"BTC":"number","Market":"number"},
      "corrKey":"string"                  // risk model anahtarÄ±
    }
  ],
  "totalRiskPctOpen": "number"
}

// risk.model.snapshot â€” korelasyon/kovaryans ve kÃ¼meler (risk modeli)
{
  "event": "risk.model.snapshot",
  "timestamp": "iso8601",
  "universe": ["AVAXUSDT","BTCUSDT","ETHUSDT","..."],
  "corr": [["1.0","0.78","..."],["0.78","1.0","..."],["..."]],
  "volBps": {"AVAXUSDT": "number", "BTCUSDT": "number"},
  "clusters": {"AVAXUSDT":"Layer1","ETHUSDT":"Layer1","LINKUSDT":"Infra","..."},
  "factorBeta": {"AVAXUSDT":{"BTC":0.82,"Market":1.1},"BTCUSDT":{"BTC":1.0,"Market":1.0}}
}

// portfolio.policy â€” portfÃ¶y tavanlarÄ± ve kurallar
{
  "event": "portfolio.policy",
  "timestamp": "iso8601",
  "caps": {
    "totalRiskPct": 2.0,                   // toplam aÃ§Ä±k risk %2
    "perSymbolPct": 0.8,                   // tek iÅŸlem risk tavanÄ± %
    "perClusterPct": {"Layer1": 1.2, "DeFi": 0.8, "Infra": 0.8, "Other": 0.8},
    "perFactorBetaAbs": {"BTC": 1.8, "Market": 2.5},  // |beta-weighted net|
    "longShortImbalancePct": 1.0           // |netLong - netShort| â‰¤ 1.0%
  },
  "correlation": {
    "hardPairThreshold": 0.85,             // bu eÅŸik Ã¼zeri aynÄ± yÃ¶nde â†’ sert kontrol
    "softPairThreshold": 0.7,              // bu eÅŸik Ã¼zeri â†’ downscale
    "defaultSameCluster": 0.5,             // model yoksa varsayÄ±lan
    "marginalRiskMaxPct": 0.6              // yeni niyetin marjinal katkÄ±sÄ± (toplam riske oran)
  },
  "actions": {
    "onHardBreach": "reject",              // reject|defer
    "onSoftBreach": "adjust"
  }
}

// mapping.meta â€” sembolâ†’cluster/beta override (opsiyonel)
{
  "event": "mapping.meta",
  "overrides": {"SUIUSDT":{"cluster":"Layer1","beta":{"BTC":0.74,"Market":1.05}}}
}

Ã‡Ä±ktÄ±lar (Karar OlaylarÄ±)
// OlduÄŸu gibi onay
{
  "event": "portfolio.intent.approved",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "riskPerTradePct": "number",
  "reasonCodes": ["ok_total","ok_cluster","ok_corr","ok_factor","ok_balance"],
  "correlationNotes": {"topPairs":[{"symbol":"string","rho":"number"}]}
}

// Downscale (yumuÅŸak ayar)
{
  "event": "portfolio.intent.adjusted",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "riskPerTradePctOriginal": "number",
  "riskPerTradePctAdjusted": "number",
  "scaleFactor": "number",                   // 0..1
  "reasonCodes": ["soft_pair_corr","cluster_cap_tight","total_cap_close","beta_saturation"],
  "correlationNotes": {"topPairs":[{"symbol":"string","rho":"number"}]}
}

// Ertele (Ã¶r. model tazeliÄŸi yok, exposure snapshot eski)
{
  "event": "portfolio.intent.deferred",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "deferUntil": "iso8601",
  "reasonCodes": ["stale_risk_model","stale_exposure"]
}

// Red (sert ihlal)
{
  "event": "portfolio.intent.rejected",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "reasonCodes": ["hard_pair_corr","cluster_cap_exceeded","total_cap_exceeded","beta_over","imbalance_exceeded"]
}

// Opsiyonel tavsiye (hedge/scale-out hedefleri)
{
  "event": "portfolio.hedge.suggestion",
  "timestamp": "iso8601",
  "suggestions": [
    {"action":"scale_out","symbol":"ETHUSDT","ratio":0.25,"reason":"cluster_overflow"},
    {"action":"open_hedge","symbol":"BTCUSDT","side":"short","riskPct":0.3,"reason":"beta_over_BTC"}
  ],
  "rationale": ["reduce Layer1 cluster from 1.6%â†’1.2%", "lower BTC beta from 2.1â†’1.7"]
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

IntentAccepted (VIVO-18), AccountExposure, RiskModelSnapshot, PortfolioPolicy, MappingMeta.

Ã‡Ä±kÄ±ÅŸlar: PortfolioIntentApproved|Adjusted|Deferred|Rejected, PortfolioHedgeSuggestion.

YardÄ±mcÄ±: ExposureVector, ClusterExposure, FactorExposure, PairCorrelation, RiskContribution.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: execution.intent.accepted, account.exposure, risk.model.snapshot, portfolio.policy, mapping.meta

Out: portfolio.intent.*, portfolio.hedge.suggestion, portfolio.balancer.metrics, portfolio.balancer.alert

Konfig & VarsayÄ±lanlar
{
  // Tazelik
  freshness: { modelMaxAgeSec: 180, exposureMaxAgeSec: 10 },

  // VarsayÄ±lan korelasyonlar (model yokken)
  defaults: { sameClusterRho: 0.5, crossClusterRho: 0.2 },

  // Ã–lÃ§ekleme mantÄ±ÄŸÄ±
  scale: {
    minFactor: 0.2,                      // asgari bÄ±rakÄ±lacak risk
    step: 0.05,                          // iteratif azaltÄ±m adÄ±mÄ±
    preferDownscaleOverDefer: true
  },

  // Net yÃ¶n sapmasÄ±
  imbalance: { maxAbsPct: 1.0 },         // |netLong - netShort| â‰¤ 1.0%

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

PortfolioState (in-memory + periyodik persist data/portfolio.state.json):

Son AccountExposure, RiskModelSnapshot, PortfolioPolicy, MappingMeta.

TÃ¼retilmiÅŸ: clusterExposure (Map), factorExposure (beta-weighted), netLongPct, netShortPct.

CorrelationCache: (symbolA,symbolB) â†’ rho (model yoksa defaults).

Hesaplamalar (BasitleÅŸtirilmiÅŸ ama saÄŸlam)

Aday Niyetin Risk AÄŸÄ±rlÄ±ÄŸÄ±

w_new = riskPerTradePct_candidate (yeni niyetin risk yÃ¼zdesi).

Mevcut PortfÃ¶y VektÃ¶rleri

w_i = riskPct (aÃ§Ä±k iÅŸlemlerin risk yÃ¼zdeleri), iÅŸaret: long=+; short=âˆ’ (net dengesi iÃ§in).

Cluster toplamlarÄ±: Î£ |w_i| kÃ¼meye gÃ¶re.

Factor (beta) maruziyeti: Î£ (sign_i * |w_i| * beta_i[f]).

Ã‡ift Korelasyonu

Aday sembol S ile her aÃ§Ä±k sembol i iÃ§in rho(S,i) (model yoksa default/cluster tabanlÄ±).

Marjinal Risk KatkÄ±sÄ± (MRC ~)

YaklaÅŸÄ±k: mrc â‰ˆ w_new * ( Î£_i ( |w_i| * rho(S,i) ) + |w_new| ) / ( totalRiskPctOpen + |w_new| ).

Kabul iÃ§in: mrc â‰¤ portfolio.policy.correlation.marginalRiskMaxPct.

Limit Kontrolleri

Total: totalRiskPctOpen + |w_new| â‰¤ caps.totalRiskPct.

Per-Symbol: |w_new| â‰¤ caps.perSymbolPct.

Cluster: clusterExposure[cluster(S)] + |w_new| â‰¤ caps.perClusterPct[cluster].

Hard Pair Corr: varsa aynÄ± yÃ¶nde aÃ§Ä±k i ve rho(S,i) â‰¥ hardPairThreshold â†’ hard breach.

Soft Pair Corr: rho â‰¥ softPairThreshold â†’ downscale hedefi.

Factor Beta: |factorExposure[f] + sign_new*|w_new|*beta_S[f]| â‰¤ caps.perFactorBetaAbs[f].

Imbalance: | (netLongPct + longNew) - (netShortPct + shortNew) | â‰¤ caps.longShortImbalancePct.

Downscale Stratejisi (Soft ihlallerde)

Ã–nce soft pair ve cluster ihlallerini giderene kadar w_new *= (1 - step) iterasyonu.

mrc ve factor limitleri saÄŸlanana kadar sÃ¼rdÃ¼r.

Alt sÄ±nÄ±r scale.minFactor altÄ±na dÃ¼ÅŸerse actions.onSoftBreach=="adjust" ise rejecte dÃ¶n; aksi defer.

Hard Breach

actions.onHardBreach uyarÄ±nca reject veya defer.

AyrÄ±ca hedge.suggestion Ã¼ret (Ã¶r. en bÃ¼yÃ¼k korelasyonlu aÃ§Ä±k pozisyonda scale_out 25%).

Algoritma (AkÄ±ÅŸ)

Tazelik & BaÄŸlam

Risk modeli age > modelMaxAgeSec â†’ defer("stale_risk_model").

Exposure age > exposureMaxAgeSec â†’ defer("stale_exposure").

KÃ¼meler/Beta Override

mapping.meta.overrides ile sembol Ã¶zelliklerini gÃ¼ncelle.

Sert Limitler

Total/Per-Symbol aÅŸÄ±mÄ± â†’ rejected (total_cap_exceeded/per_symbol_cap).

Hard pair corr â†’ rejected("hard_pair_corr").

YumuÅŸak Limitler & MRC

Soft pair/cluster/factor/imbalance ihlallerinde downscale dÃ¶ngÃ¼sÃ¼.

mrc â‰¤ eÅŸik olduÄŸunda adjusted yayÄ±nla.

Temiz Onay

HiÃ§biri tetiklenmediyse approved.

Hedge Ã–nerileri (opsiyonel)

Cluster overflow veya beta aÅŸÄ±mÄ± varsa, en bÃ¼yÃ¼k katkÄ± yapan aÃ§Ä±k pozisyonlar iÃ§in portfolio.hedge.suggestion.

Telemetri

portfolio.balancer.metrics 10 sn: {approved, adjusted, deferred, rejected, avg_scale, top_corr_pair}.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/portfolioExposureBalancer.ts

src/vivo/state/portfolioStore.ts (model+exposure+policy cache)

src/vivo/lib/corr.ts (rho fetch & default), src/vivo/lib/mrc.ts (marginal risk)

__tests__/portfolioExposureBalancer.test.ts

Mimari

Saf Ã§ekirdek: balance(intent, state, policy, cfg) â†’ Emission[].

I/O adaptÃ¶rÃ¼: bus subscribe/publish; state persist; freshness kontrolleri.

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlar finite(); unknown alanlar ignore + warn.

Idempotency

AynÄ± correlationId iÃ§in tekrarÄ± engelle (WAL/idempotent key).

Performans

N aÃ§Ä±k pozisyon iÃ§in O(N) deÄŸerlendirme; rho lookup cacheâ€™li.

Test Ä°skeleti (Jest)

total cap exceeded â†’ rejected(total_cap_exceeded)

per-symbol cap exceeded â†’ rejected(per_symbol_cap)

hard pair corr (Ïâ‰¥0.85 same direction) â†’ rejected(hard_pair_corr)

soft pair corr (Ïâ‰¥0.70) â†’ adjusted(scaleFactor<1)

cluster cap near â†’ adjusted ve clusterExposure sÄ±nÄ±r iÃ§inde

factor beta over â†’ adjusted veya rejected(beta_over) (policyye gÃ¶re)

imbalance > cap â†’ adjusted/rejected (netLong-netShort dÃ¼zeltilir)

stale model/exposure â†’ deferred

marginal risk > limit â†’ adjusted until â‰¤ limit or reject if <minFactor

no issues â†’ approved (risk pct unchanged)

Ã–rnek Senaryo (Ã–zet)

Durum

AÃ§Ä±klar:

ETHUSDT long 0.7% (cluster=Layer1, Ï(ETH,BTC)=0.79)

BTCUSDT long 0.6% (cluster=BTCComplex)

Toplam aÃ§Ä±k risk: 1.3%

Politika: total=2.0%, perSymbol=0.8%, perCluster.Layer1=1.2%, softPairâ‰¥0.70, hardPairâ‰¥0.85

Risk modeli: Ï(AVAX,ETH)=0.82, Ï(AVAX,BTC)=0.68, beta_AVAX.BTC=0.84

Yeni niyet: AVAXUSDT long, riskPerTradePct_candidate=0.7%, cluster=Layer1

Hesap

Total sonrasÄ±: 1.3 + 0.7 = 2.0 â†’ total OK.

Cluster Layer1: ETH 0.7 + AVAX 0.7 = 1.4% > 1.2% â†’ cluster soft breach.

Pair corr: Ï(AVAX,ETH)=0.82 â‰¥ soft (0.70) ve < hard (0.85) â†’ soft pair.

MRC baÅŸlangÄ±Ã§ta yÃ¼ksek â†’ downscale: 0.7 â†’ 0.55 â†’ 0.50 (iteratif).

0.50% ile Cluster: 1.2% tam dolar; MRC â‰¤ eÅŸik.

Beklenen Ã‡Ä±ktÄ±

{
  "event":"portfolio.intent.adjusted",
  "symbol":"AVAXUSDT","side":"long",
  "riskPerTradePctOriginal":0.7,
  "riskPerTradePctAdjusted":0.5,
  "scaleFactor":0.714,
  "reasonCodes":["cluster_cap_tight","soft_pair_corr","mrc_capped"],
  "correlationNotes":{"topPairs":[{"symbol":"ETHUSDT","rho":0.82}]}
}


Opsiyonel:

{
  "event":"portfolio.hedge.suggestion",
  "suggestions":[{"action":"scale_out","symbol":"ETHUSDT","ratio":0.25,"reason":"cluster_overflow"}],
  "rationale":["reduce Layer1 exposure from 1.4% to 1.2%"]
}

Entegrasyon NotlarÄ±

SÄ±ra: execution.intent.accepted (VIVO-18) â†’ VIVO-25 balancer â†’ (gerekirse ayarlanmÄ±ÅŸ riskPct ile) VIVO-19 composer.

YÃ¼kseltme yok: Balancer riskPctâ€™yi yalnÄ±zca â†“ azaltÄ±r (veya deÄŸiÅŸmez).

VIVO-17 bu modÃ¼lden adjusted/rejected oranlarÄ±nÄ± izleyip allowedVariants ve confirmationThreshold Ã¶nerilerini ÅŸekillendirebilir.

Risk Incident Reporter (VIVO-23) ile uyum: aÅŸÄ±rÄ± korelasyon/hard ihlaller incident tetikleyebilir.
_________________________________________________________________________________________________________________
VIVO-26 Â· latencyAndSlippageGuard.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

GerÃ§ek zamanlÄ± slipaj ve gecikme Ã¶lÃ§Ã¼mlerine gÃ¶re iÅŸlem akÄ±ÅŸÄ±nÄ± geÃ§ici olarak kÄ±sÄ±tlamak:

AÅŸÄ±rÄ± slipaj anlarÄ±nda market failoverâ€™Ä± kapat, post-only/limit dayat, bekleyen giriÅŸleri iptal/ertele.

YerleÅŸtirme/ilk dolum gecikmesi yÃ¼kselirse yavaÅŸlat (slowdown), aggressive varyantÄ± geÃ§ici kapat.

AkÄ±ÅŸ/WS gecikmesi veya kalp atÄ±ÅŸÄ± (heartbeat) zayÄ±fladÄ±ÄŸÄ±nda halt_entry (yeni giriÅŸleri durdur) ve aÃ§Ä±k emirleri gÃ¼venle kapat.

Yetki alanÄ±: Sadece kÄ±sÄ±tlama/ertleme/iptal uygular; risk bÃ¼yÃ¼tmez, bÃ¼tÃ§e geniÅŸletmez.

Girdiler (Event / JSON ÅemalarÄ±)
// order.placement.result â€” VIVO-20â€™dan yerleÅŸtirme latencies
{
  "event": "order.placement.result",
  "timestamp": "iso8601",
  "correlationId": "string",
  "results": [
    {"clientOrderId":"string","exchangeOrderId":"string","status":"accepted|rejected","reason":"string|null","placeLatencyMs":"number"}
  ],
  "symbol": "string",
  "side": "long|short",
  "variant": "base|aggressive|conservative"
}

// order.update â€” fill/trigger ve slipaj sinyali
{
  "event": "order.update",
  "timestamp": "iso8601",
  "correlationId": "string",
  "clientOrderId": "string",
  "exchangeOrderId": "string",
  "status": "new|partially_filled|filled|canceled|expired|replaced|rejected|triggered",
  "filledQty": "number",
  "avgFillPrice": "number",
  "lastFillSlipBps": "number",
  "firstFillLatencyMs": "number|null"
}

// market.refs â€” spread/vol baÄŸlamÄ±
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "bestBid": "number",
  "bestAsk": "number",
  "mid": "number",
  "spreadBps": "number",
  "volZScore": "number"
}

// connectivity.heartbeat â€” aÄŸ/WS saÄŸlÄ±ÄŸÄ±
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean"
}

// policy.snapshot â€” Ã¼st sÄ±nÄ±rlar (okunur)
{
  "event": "policy.snapshot",
  "riskPerTradePct": "number",
  "kellyCap": "number",
  "dailyMaxTrades": "number",
  "confirmationBounds": {"min":"number","max":"number"},
  "slippageHardBps": 15,
  "latencyHardMs": 1800
}

// order.plan.proposed â€” (opsiyonel) plan gÃ¶rÃ¼nÃ¼mÃ¼ (failover modu vs)
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "entryPlan": {"mode":"market|limit|stop_market|stop_limit","legs":[{"type":"string","ttlSec":"number","failover":"none|market|price_step_escalation"}]},
  "risk": {"maxSlipBps":"number"},
  "audit": {"variant":"base|aggressive|conservative"}
}

Ã‡Ä±ktÄ±lar (Guard Direktifleri & Eylemler)
// Muhafaza direktifi (VIVO-18/19/20/21 tarafÄ±ndan dikkate alÄ±nÄ±r)
{
  "event": "latency_slip.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|slowdown|block_aggressive|halt_entry|cancel_open_orders",
  "scope": {"symbol":"string|null","variant":"base|aggressive|conservative|null"},
  "expiresAt": "iso8601",
  "actions": [
    "disallow_market_failover",
    "force_post_only",
    "cap_slippage_bps",
    "defer_new_entries",
    "cancel_pending_entries"
  ],
  "limits": {"maxSlippageBps":"number","maxNewEntriesPerMin":"number"},
  "reasonCodes": ["string"]
}

// Tek emre yÃ¶nelik anlÄ±k override (execution manager okur)
{
  "event": "execution.policy.override",
  "timestamp": "iso8601",
  "correlationId": "string",
  "directives": {
    "failover":"none|price_step_escalation",   // market failover kapatÄ±lÄ±r ya da step'e Ã§evrilir
    "postOnly": true,
    "maxSlippageBps": "number"
  },
  "reasonCodes": ["string"]
}

// Telemetri ve uyarÄ±
{
  "event": "latency_slip.guard.metrics",
  "timestamp": "iso8601",
  "ewma": {"placeMs":"number","firstFillMs":"number","slipBps":"number","spreadBps":"number"},
  "modeRates": {"normal":"number","slowdown":"number","block_aggressive":"number","halt_entry":"number"},
  "panicCount": "number"
}
{
  "event": "latency_slip.guard.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string|null","reasonCodes":["string"]}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

PlacementResult, OrderUpdate, MarketRefs, ConnectivityHeartbeat, PolicySnapshot, OrderPlanProposed.

Ã‡Ä±kÄ±ÅŸlar: GuardDirective, ExecutionPolicyOverride, GuardMetrics, GuardAlert.

YardÄ±mcÄ±: EwmaTracker, GuardState, Hysteresis, ScopeKey (symbol|* + variant|*).

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: order.placement.result, order.update, market.refs, connectivity.heartbeat, policy.snapshot, order.plan.proposed

Out: latency_slip.guard.directive, execution.policy.override, latency_slip.guard.metrics, latency_slip.guard.alert

Konfig & VarsayÄ±lanlar
{
  // EÅŸikler (variantâ€™a gÃ¶re)
  slipWarnBps: { aggressive: 10, base: 8, conservative: 6 },
  slipPanicBps: 15,                            // policy.slippageHardBps ile clamp
  placeLatencyWarnMs: 800,
  firstFillLatencyWarnMs: 1200,
  streamLatencyWarnMs: 700,
  panicWhenStreamsDeadMs: 8000,

  // Histerezis (Ã§Ä±rpÄ±nmayÄ± Ã¶nlemek)
  hysteresis: { exitPct: 0.75, minHoldSec: 60 },

  // Slowdown etkileri
  slowdown: { maxNewEntriesPerMin: 1, expireSec: 300 },

  // Mod sÃ¼releri
  ttlSec: { block_aggressive: 900, halt_entry: 600, cancel_open_orders: 120 },

  // EWMAs
  ewmaHalfLife: { slip: 10, placeMs: 8, firstFillMs: 8, spread: 6 },

  // Aksiyon haritasÄ±
  overrides: {
    onSlipWarn: ["disallow_market_failover", "cap_slippage_bps"],
    onSlipPanic: ["cancel_pending_entries", "defer_new_entries"],
    onLatencyWarn: ["force_post_only", "disallow_market_failover"],
    onStreamsPanic: ["halt_entry", "cancel_open_orders"]
  },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

GuardStateStore (in-memory + periyodik persist data/latency_slip.guard.json):

perScope (symbol/variant/*) EWMA: slipBps, placeMs, firstFillMs, spreadBps.

Aktif mod ve expiresAt, enteredAt, reasonCodes[].

Hysteresis: modu sonlandÄ±rma eÅŸiÄŸi, minimum bekleme.

GÃ¼nlÃ¼k sayaÃ§lar: panicCount, slowdownSeconds.

Algoritma (Karar AkÄ±ÅŸÄ±)

Ã–lÃ§Ã¼mleri GÃ¼ncelle

Her order.update.lastFillSlipBps â†’ ewma.slipBps.

order.placement.result.placeLatencyMs â†’ ewma.placeMs.

order.update.firstFillLatencyMs â†’ ewma.firstFillMs.

market.refs.spreadBps â†’ ewma.spreadBps.

AkÄ±m SaÄŸlÄ±ÄŸÄ±

connectivity.heartbeat: streamâ€™ler down veya latencyMs > streamLatencyWarnMs â†’ latency_warn.

marketStreamAlive==false || orderStreamAlive==false ve now - lastHeartbeat > panicWhenStreamsDeadMs â†’ streams_panic.

EÅŸik DeÄŸerlendirme (Variantâ€™a gÃ¶re)

ewma.slipBps â‰¥ slipWarnBps[variant] â†’ SlipWarn.

lastFillSlipBps â‰¥ slipPanicBps (tekil olay) veya ewma.slipBps â‰¥ slipPanicBps*0.9 â†’ SlipPanic.

ewma.placeMs â‰¥ placeLatencyWarnMs veya ewma.firstFillMs â‰¥ firstFillLatencyWarnMs â†’ LatencyWarn.

Mod SeÃ§imi (Ã–ncelik)
streams_panic â†’ halt_entry (+ cancel_open_orders)
SlipPanic â†’ block_aggressive + cancel_pending_entries
LatencyWarn â†’ slowdown + force_post_only
SlipWarn â†’ disallow_market_failover + cap_slippage_bps
(Birden fazla tetik varsa en sert mod seÃ§ilir.)

Histerezis & SÃ¼re

Mod aktifse minHoldSec dolmadan dÃ¼ÅŸÃ¼rme.

Ã–lÃ§Ã¼mler exitPct oranÄ±nda normale dÃ¶nÃ¼nce modu normalâ€™a indir; aksi halde expiresAtâ€™a dek sÃ¼rdÃ¼r.

Eylemler & YayÄ±n

Scope: mÃ¼mkÃ¼nse symbol+variant, deÄŸilse global (*).

GuardDirective yayÄ±nla (mode, actions, limits, expiresAt).

EÄŸer spesifik bir order.plan.proposed gÃ¶rÃ¼nÃ¼yorsa, order bazÄ±nda execution.policy.override da gÃ¶nder:

failover: none|price_step_escalation, postOnly: true, maxSlippageBps = min(plan.risk.maxSlipBps, slipWarnBps[variant]).

Panik Durumu

streams_panic â†’ latency_slip.guard.alert(level="error", reason="streams_panic"),
ardÄ±ndan halt_entry ve cancel_open_orders direktifleri.

Telemetri

10 snâ€™de bir latency_slip.guard.metrics (EWMAâ€™lar, mod oranlarÄ±, panicCount).

GerÃ§ek DÃ¼nya KurallarÄ± (Uyum)

Risk artÄ±rma yok: maxSlippageBps sadece azaltÄ±lÄ±r; failover kapatÄ±lÄ±r veya step-escalationâ€™a Ã§evrilir.

Reduce-only disiplinine saygÄ±: Bekleyen giriÅŸ iptalleri pozisyon kapatmaz; kapatma kararÄ± VIVO-21â€™dedir.

Variant yÃ¶netimi: block_aggressive modunda aggressive varyant sisteme giriÅŸ yapamaz (Throttler ve Router dinler).

Sessiz saatler + yÃ¼ksek spread birlikteyse eÅŸikler daha katÄ± yorumlanabilir (opsiyonel: +10% sÄ±kÄ±laÅŸtÄ±r).

Idempotency: AynÄ± moda aynÄ± scope iÃ§in tekrar direktif gÃ¶nderme (hash/debounce).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/latencyAndSlippageGuard.ts

src/vivo/state/guardStore.ts (persist + histerezis)

src/vivo/lib/ewma.ts, src/vivo/lib/hysteresis.ts

__tests__/latencyAndSlippageGuard.test.ts

Mimari

Saf Ã§ekirdek: evaluate(event, state, cfg) â†’ emissions[]

I/O adaptÃ¶rÃ¼: bus subscribe/publish + state persist

Validasyon

Zod ÅŸemalarÄ±; sayÄ±sal alanlar finite(); negatif/NaN â†’ event drop + alert.

Performans

p99 < 5ms hedef; EWMA gÃ¼ncellemesi O(1).

GÃ¼n Sonu Reset

SayaÃ§lar ve moda iliÅŸkin metrikler Europe/Istanbul gÃ¼n sonunda sÄ±fÄ±rlanÄ±r.

Test Ä°skeleti (Jest)

slipWarn â†’ directive(disallow_market_failover, cap_slippage_bps)

slipPanic (tekil â‰¥ hard) â†’ block_aggressive + cancel_pending_entries

placeLatencyWarn â†’ slowdown + force_post_only

streams_panic â†’ halt_entry + cancel_open_orders + alert(error)

hysteresis exitPct Ã§alÄ±ÅŸÄ±r, minHoldSec dolmadan mod dÃ¼ÅŸmez

execution.policy.override maxSlippageBps â‰¤ plan.maxSlipBps

idempotent directive (aynÄ± mod & scope) â†’ tek yayÄ±n

variant=aggressive iken block_aggressive aktif â†’ throttler yeni niyeti reddeder (simÃ¼le)

Ã–rnek Senaryo (Ã–zet)

Durum

variant="aggressive", son 6 fillâ€™de slipEWMA â‰ˆ 11 bps (warn Ã¼stÃ¼), tek bir fill 17 bps (panic).

placeLatencyEWMA = 900 ms, firstFillEWMA = 1400 ms.

market.refs.spreadBps=28, WS alive fakat latencyMs=800ms.

Beklenen YayÄ±nlar

{
  "event":"latency_slip.guard.directive",
  "mode":"block_aggressive",
  "scope":{"symbol":"*","variant":"aggressive"},
  "expiresAt":"...+PT15M",
  "actions":["cancel_pending_entries","disallow_market_failover","cap_slippage_bps"],
  "limits":{"maxSlippageBps":10},
  "reasonCodes":["slip_panic","latency_warn","wide_spread"]
}


AyrÄ±ca yeni plana spesifik:

{
  "event":"execution.policy.override",
  "correlationId":"LINKUSDT-long-...",
  "directives":{"failover":"price_step_escalation","postOnly":true,"maxSlippageBps":10},
  "reasonCodes":["guard_active_block_aggressive"]
}


Durum normale dÃ¶ndÃ¼ÄŸÃ¼nde histerezis koÅŸullarÄ±yla mode: "normal" direktifi gÃ¶nderilir.

Entegrasyon NotlarÄ±

VIVO-18 Throttler: block_aggressive ve halt_entry direktiflerini dinleyip kararlarÄ±nÄ± sÄ±kÄ±laÅŸtÄ±rÄ±r.

VIVO-19 Composer: execution.policy.override ile failover/post-only/slip tavanÄ±nÄ± uygular.

VIVO-20 Execution Manager: tekil emir overrideâ€™larÄ±nÄ± zorunlu uygular; slipaj aÅŸÄ±mÄ±nda cancel/replace davranÄ±r.

VIVO-21 Supervisor: halt_entry aktifken aÃ§Ä±k pozisyonlarÄ± korur; kapatma kararÄ± Supervisorâ€™dadÄ±r.
_________________________________________________________________________________________________________________
VIVO-27 Â· exchangeConnectivitySentry.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Borsa WS/REST baÄŸlantÄ±larÄ±nÄ±n saÄŸlÄ±ÄŸÄ±nÄ± izlemek, sequence gap (sÄ±ra atlamasÄ±) yakalamak, snapshotâ†’replay ile akÄ±ÅŸÄ± yeniden senkronize etmek.

Clock drift (yerel saat â†” borsa saati) Ã¶lÃ§Ã¼p dÃ¼zeltmek.

Otomatik yeniden baÄŸlanma, uÃ§ nokta (primaryâ†’secondary) failover, devre kesici (circuit breaker) ve backoff+jitter politikalarÄ±nÄ± uygulamak.

Sorun anÄ±nda Ã¼st katmanlara net, uygulanabilir direktifler Ã¼retmek (Ã¶r. â€œstreams_panic â†’ halt_entryâ€, â€œresubscribeâ€, â€œswitch_endpointâ€).

VIVO-26 (Latency/Slippage Guard), VIVO-20 (Execution Manager) ve VIVO-21 (Supervisor) ile uyumlu sinyaller yayÄ±nlamak.

Bu modÃ¼l sadece baÄŸlantÄ±/akÄ±ÅŸ bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nden sorumludur; emir ve risk mantÄ±ÄŸÄ±na dokunmaz.

Girdiler (Event / JSON ÅemalarÄ±)
// config.exchange.endpoints â€” uÃ§ noktalar ve abone setleri
{
  "event": "config.exchange.endpoints",
  "timestamp": "iso8601",
  "primary": {"wsUrl":"wss://...", "restUrl":"https://..."},
  "secondary": {"wsUrl":"wss://backup...", "restUrl":"https://backup..."},
  "subscriptions": [
    {"channel":"bookTicker","symbols":["BTCUSDT","ETHUSDT","AVAXUSDT"]},
    {"channel":"aggTrades","symbols":["BTCUSDT"]},
    {"channel":"depth@100ms","symbols":["BTCUSDT","ETHUSDT"], "snapshotRestPath":"/api/depth?symbol=${sym}&limit=1000"}
  ],
  "auth": {"apiKeyId":"string","scope":"read_public"},
  "heartbeat": {"intervalMs": 1000, "timeoutMs": 4000}
}

// external.trigger.resubscribe â€” Ã¼st katman manuel tetikleyebilir
{
  "event": "external.trigger.resubscribe",
  "timestamp": "iso8601",
  "reason": "manual|policy_change|symbol_rotation",
  "note": "string|null"
}

// order.update / market.refs (pasif dinlenir â€” tazelik Ã¶lÃ§Ã¼mÃ¼ne katkÄ±)
// (ÅŸemalar Ã¶nceki modÃ¼llerde tanÄ±mlÄ±; burada yalnÄ±zca timestamp'leri kullanÄ±lÄ±r)

Ã‡Ä±ktÄ±lar (Sentry OlaylarÄ± & Direktifler)
// SaÄŸlÄ±k nabzÄ± (ust katmanlar VIVO-26/21 bunu tÃ¼ketir)
{
  "event": "connectivity.heartbeat",
  "timestamp": "iso8601",
  "latencyMs": "number",                 // serverTime ping roundtrip EWMA
  "marketStreamAlive": "boolean",
  "orderStreamAlive": "boolean",
  "wsEndpoint": "primary|secondary",
  "clockSkewMs": "number"                // local-now - exchangeServerTime
}

// WS baÄŸlantÄ± durumu
{
  "event": "sentry.ws.status",
  "timestamp": "iso8601",
  "status": "connecting|open|closing|closed|failed",
  "endpoint": "primary|secondary",
  "sessionId": "string",
  "reason": "string|null",
  "attempt": "number"
}

// Abonelik/senkronizasyon akÄ±ÅŸÄ±
{
  "event": "sentry.subscription.status",
  "timestamp": "iso8601",
  "channel": "bookTicker|aggTrades|depth@100ms|custom",
  "symbol": "string|null",
  "state": "subscribed|unsubscribed|resyncing|snapshot_loaded",
  "detail": "string|null"
}

// Sequence gap tespiti (Ã¶r. order book/aggTrades)
{
  "event": "sentry.sequence.gap",
  "timestamp": "iso8601",
  "channel": "depth@100ms|aggTrades|...",
  "symbol": "string",
  "expectedSeq": "number",
  "receivedSeq": "number",
  "gapSize": "number",
  "action": "replay|resnapshot|switch_endpoint"
}

// Kurtarma aksiyonlarÄ± (Ã¼st katmanlar bilgilensin)
{
  "event": "sentry.recovery.action",
  "timestamp": "iso8601",
  "action": "resubscribe|reload_snapshot|replay_from|switch_endpoint|reconnect",
  "endpoint": "primary|secondary",
  "context": {"channel":"string","symbol":"string|null","fromSeq":"number|null"},
  "reasonCodes": ["string"]
}

// Sentry direktifi (guardâ€™lara kÃ¶prÃ¼)
{
  "event": "sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic",
  "expiresAt": "iso8601",
  "reasonCodes": ["clock_drift_high","sequence_gap_repeated","ws_flaps","no_heartbeat"],
  "hints": {"suggestHaltEntry": true, "suggestCancelOpenOrders": false}
}

// Metrik & alarm
{
  "event": "sentry.metrics",
  "timestamp": "iso8601",
  "ewma": {"pingMs":"number","wsMsgsPerSec":"number"},
  "gaps": {"count":"number","avgGap":"number"},
  "reconnects": "number",
  "endpointSwitches": "number"
}
{
  "event": "sentry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"endpoint":"primary|secondary","reason":"string","sessionId":"string"}
}

Ä°Ã§ Veri & YardÄ±mcÄ± AkÄ±ÅŸlar (Sentry yÃ¶netir)
// depth.snapshot.cached â€” REST'ten alÄ±nan anlÄ±k snapshot (persist iÃ§in opsiyonel)
{
  "event": "depth.snapshot.cached",
  "timestamp": "iso8601",
  "symbol": "string",
  "lastUpdateId": "number"
}

// depth.delta.applied â€” delta uygulandÄ± (sequence tutarlÄ±lÄ±ÄŸÄ± doÄŸrulandÄ±)
{
  "event": "depth.delta.applied",
  "timestamp": "iso8601",
  "symbol": "string",
  "prevSeq": "number",
  "newSeq": "number",
  "appliedCount": "number"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

EndpointsConfig, SubscriptionSpec, HeartbeatCfg, WsStatus, SubscriptionStatus.

SequenceGap, RecoveryAction, SentryGuardDirective, SentryMetrics, SentryAlert.

YardÄ±mcÄ±: ConnectionState, BackoffPlan, CircuitBreaker, SeqTracker (per channel+symbol), ClockSkewTracker.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: config.exchange.endpoints, external.trigger.resubscribe

Out: connectivity.heartbeat, sentry.ws.status, sentry.subscription.status,
sentry.sequence.gap, sentry.recovery.action, sentry.guard.directive,
sentry.metrics, sentry.alert, depth.snapshot.cached, depth.delta.applied

Konfig & VarsayÄ±lanlar
{
  // BaÄŸlantÄ±
  reconnectBackoffMs: [300, 600, 1200, 2500, 5000],  // + jitter %20
  circuitBreaker: { failThreshold: 5, openMs: 30000, halfOpenProbes: 2 },

  // Snapshot / replay
  depth: { snapshotTTLms: 120000, maxReplayBatch: 2000, gapHard: 500, gapSoft: 50 },

  // Saat
  clock: { pingIntervalMs: 2000, driftWarnMs: 800, driftPanicMs: 2000 },

  // SaÄŸlÄ±k
  heartbeat: { intervalMs: 1000, timeoutMs: 4000 },
  msgRateWarnPerSec: 120,         // spam/sel taÅŸmasÄ± iÃ§in uyarÄ±
  wsFlapWarnCount: 3,             // 10 dk iÃ§inde

  // Failover
  switchToSecondaryOn: { repeatedGaps: 3, reconnectsIn10m: 4, driftPanic: true },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

ConnectionStateStore (in-memory + periyodik persist data/sentry.state.json):

endpoint (primary/secondary), status, sessionId, attempt, lastOpenAt.

circuitBreakerState.

seqTrackers (Map: channel|symbol â†’ {lastSeq, gapsCount, lastGapAt}).

clockSkewTracker (EWMA).

Son heartbeatAt, wsFlapCounter, endpointSwitches, reconnects.

Idempotency: sessionId + monotonik seq eÅŸleÅŸmesiyle yeniden iÅŸlemede Ã§ift yayÄ±n Ã¶nlenir.

Algoritma (Karar AkÄ±ÅŸÄ±)

BaÅŸlat / BaÄŸlan

config.exchange.endpoints alÄ±nÄ±r â†’ WS CONNECT (primary). sentry.ws.status("connecting") yayÄ±nla.

BaÅŸarÄ±lÄ±: status:"open", sessionId Ã¼ret. TÃ¼m subscriptions gÃ¶nder, her biri iÃ§in subscription.status("subscribed").

Heartbeat & Ping

Her heartbeat.intervalMs â†’ serverTime ping (REST/time veya WS ping-pong).

clockSkewMs = localNow - serverTime.

> driftWarnMs â†’ sentry.guard.directive(mode="degraded", reason="clock_drift_high").

> driftPanicMs â†’ mode="streams_panic" + sentry.alert(error).

Sequence Takibi

depth/aggTrades delta paketlerinde seqTracker kontrol:

Soft gap (gap â‰¤ gapSoft) â†’ replay_from (bufferâ€™da varsa uygula).

Hard gap (gap â‰¥ gapHard) â†’ resnapshot (REST snapshot al, lastUpdateId â‰¥ beklenen; ardÄ±ndan replay).

Tekrarlayan arÄ±zalar (â‰¥ switchToSecondaryOn.repeatedGaps) â†’ switch_endpoint(secondary).

Snapshotâ†’Replay SÃ¼reci

reload_snapshot Ã§aÄŸÄ±r â†’ RESTâ€™ten snapshot Ã§ek, depth.snapshot.cached yayÄ±nla.

WSâ€™den gelen deltaâ€™larÄ± lastUpdateId Ã¼stÃ¼ne sÄ±rayla uygula; her uygulamada depth.delta.applied.

Zaman aÅŸÄ±mÄ±/baÅŸarÄ±sÄ±zlÄ±kta reconnect + resubscribe.

Reconnect & Failover

WS kapanÄ±rsa: reconnectBackoffMs[attempt] + jitter ile yeniden baÄŸlan.

circuitBreaker aÃ§Ä±kken sadece halfOpenProbes dene.

10 dakikada reconnects â‰¥ N veya driftPanic â†’ switch to secondary; endpointSwitches++.

Flapping (SÄ±k AÃ§-Kapa)

Son 10 dkâ€™da wsFlapWarnCount aÅŸÄ±lÄ±rsa: sentry.guard.directive(mode="degraded", reason="ws_flaps") ve slow resubscribe (kademeli).

DÄ±ÅŸ Tetikleyici

external.trigger.resubscribe â†’ mevcut oturumda tam resubscribe; policy deÄŸiÅŸtiyse yeni sembol setiyle abone ol.

Timeout / No Heartbeat

now - lastHeartbeat > heartbeat.timeoutMs â†’ sentry.guard.directive(mode="streams_panic", reason="no_heartbeat"), ardÄ±ndan reconnect.

Telemetri

10 snâ€™de bir sentry.metrics: EWMA ping, msgRate, gaps, reconnects, endpointSwitches.

GerÃ§ek DÃ¼nya KurallarÄ± (Uyum)

Deterministik tekrar: AynÄ± sessionId altÄ±ndaki yeniden yayÄ±nlar idempotent olmalÄ±.

GÃ¼venli varsayÄ±lan: Senkronizasyon ÅŸÃ¼pheliyse trade etmeyin sinyali: sentry.guard.directive(mode="streams_panic").

Snapshot TTL: Eski snapshot ile replay yapma; TTL aÅŸÄ±lÄ±rsa tekrar indir.

Saat disiplini: Clock drift dÃ¼zeltme yalnÄ±zca Ã¶lÃ§Ã¼mdÃ¼r; OS saatini deÄŸiÅŸtirme. Ãœst katmanlara uyarÄ±/direktif ver.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/exchangeConnectivitySentry.ts

src/vivo/state/sentryStore.ts (persist + circuit breaker + seq trackers)

src/vivo/lib/backoff.ts, src/vivo/lib/seqTracker.ts, src/vivo/lib/clockSkew.ts

__tests__/exchangeConnectivitySentry.test.ts

Mimari

Saf Ã§ekirdek: advance(state, event, cfg) â†’ emissions[] (deterministik state machine).

IO adaptÃ¶rÃ¼: gerÃ§ek WS/REST client, subscribe/unsubscribe/snapshot Ã§aÄŸrÄ±larÄ±; event bus publish/subscribe.

Validasyon

Zod ile tÃ¼m dÄ±ÅŸ olaylar; sayÄ± alanlarÄ± finite(); endpoint URLâ€™leri non-empty.

Performans

p99 dÃ¶ngÃ¼ < 5ms (WS event baÅŸÄ±na). Replayâ€™de backpressure uygula (batch boyutu).

Idempotency & Debounce

AynÄ± recovery.actionâ€™Ä± aynÄ± baÄŸlamda art arda gÃ¶ndermeyi engelle (hash/time debounce).

GÃ¼n Sonu

SayaÃ§lar Europe/Istanbul gÃ¼n sonunda sÄ±fÄ±rlanÄ±r (metrics reset).

Test Ä°skeleti (Jest)

soft gap â†’ replay_from ve depth.delta.applied sÄ±ralÄ± ilerler.

hard gap â†’ resnapshot + replay ve akÄ±ÅŸ senkronize olur.

no heartbeat > timeoutMs â†’ streams_panic + reconnect.

clock drift > driftPanicMs â†’ streams_panic + endpoint switch (policy uygunsa).

ws flapping (â‰¥3/10m) â†’ degraded + slow resubscribe.

reconnect backoff & circuit breaker doÄŸru uygulanÄ±r.

external.trigger.resubscribe tam abonelik yeniler.

idempotent recovery.action tekrar yayÄ±nlanmaz.

Ã–rnek Senaryo (Ã–zet)

Durum

Primary WS aÃ§Ä±k, depth@100ms(BTCUSDT) iÃ§in expectedSeq=102340, gelen 102297 â†’ gap=43 (soft)

ArdÄ±ndan bir paket daha kaÃ§tÄ±: received=101700 â†’ gap=640 (hard)

serverTime ping EWMA=920 ms, clockSkew=+2300 ms (panic)

Beklenen YayÄ±nlar

{"event":"sentry.sequence.gap","channel":"depth@100ms","symbol":"BTCUSDT","expectedSeq":102340,"receivedSeq":102297,"gapSize":43,"action":"replay"}

{"event":"sentry.sequence.gap","channel":"depth@100ms","symbol":"BTCUSDT","expectedSeq":102340,"receivedSeq":101700,"gapSize":640,"action":"resnapshot"}

{"event":"sentry.recovery.action","action":"reload_snapshot","endpoint":"primary","context":{"channel":"depth@100ms","symbol":"BTCUSDT","fromSeq":null},"reasonCodes":["hard_gap"]}

{"event":"sentry.guard.directive","mode":"streams_panic","expiresAt":"...+PT10M","reasonCodes":["clock_drift_high"],"hints":{"suggestHaltEntry":true,"suggestCancelOpenOrders":false}}


(SonrasÄ±nda policy uygunsa secondaryâ€™e geÃ§ilir ve subscription.status akÄ±ÅŸÄ± yeniden kurulur.)

Entegrasyon NotlarÄ±

VIVO-26: connectivity.heartbeat ve sentry.guard.directive sinyallerine gÃ¶re halt_entry / slowdown modlarÄ±nÄ± tetikler.

VIVO-20/21: streams_panic aktifken yeni giriÅŸ yapmaz; Supervisor aÃ§Ä±k pozisyonlarÄ± korur.

VIVO-27 baÅŸka borsaya geÃ§iÅŸi (Ã§oklu adapter) destekleyecek ÅŸekilde geniÅŸletilebilir (opsiyonel multi-exchange).
_________________________________________________________________________________________________________________
VIVO-28 Â· fundingAndFeesForecaster.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Perp funding (8s/4s/1s periyotlu) ve iÅŸlem Ã¼cretleri (maker/taker, VIP tier, indirim tokenâ€™Ä± vb.) iÃ§in kÄ±sa vadeli maliyet tahmini Ã¼retmek.

Planlanan veya aÃ§Ä±k iÅŸlemler iÃ§in beklenen maliyet bÃ¼tÃ§esi (fees+funding) ile planlanan Râ€™Ä± karÅŸÄ±laÅŸtÄ±rÄ±p uyarÄ±/tavsiye yayÄ±nlamak.

Funding saati pencereleri Ã¶ncesi/sonrasÄ± iÃ§in â€œkaÃ§Ä±n/uygula/deÄŸiÅŸtirâ€ Ã¶nerileri Ã¼retmek (Ã¶r. â€œfunding +35 bp8h, 22 dk kaldÄ± â†’ giriÅŸ erteleâ€).

VIVO-19 (composer), VIVO-21 (supervisor) ve VIVO-26 (latency/slip guard) gibi modÃ¼llere uygulanabilir sinyaller saÄŸlamak.

Bu modÃ¼l yalnÄ±zca maliyetleri tahmin/rapor eder; emir/pozisyon yÃ¶netimi yapmaz.

Girdiler (Event / JSON ÅemalarÄ±)
// funding.snapshot â€” borsadan periyodik alÄ±nan funding verileri
{
  "event": "funding.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "period": "8h|4h|1h",
  "lastFundingRateBp": "number",     // Ã¶r: +3.2 (bp/period)
  "nextFundingTime": "iso8601",
  "predictedNextRateBp": "number|null",
  "basisBp": "number|null",          // mark-index yÄ±llÄ±klaÅŸtÄ±rÄ±lmÄ±ÅŸ bazis (bps/yÄ±l)
  "oiChangePct": "number|null"       // open interest % deÄŸiÅŸimi (son periyot)
}

// fees.schedule â€” maker/taker ve indirim bilgileri
{
  "event": "fees.schedule",
  "timestamp": "iso8601",
  "tradeMode": "spot|usdm|coinm",
  "vipTier": "number",
  "makerFeeBp": "number",            // bp (1 bp = 0.01%)
  "takerFeeBp": "number",
  "discounts": {"token":"string|null","enabled":true,"extraMakerBp":-0.5,"extraTakerBp":-0.5}
}

// account.tradingStats â€” kullanÄ±cÄ± hacmi ve beklenen tier deÄŸiÅŸimi
{
  "event": "account.tradingStats",
  "timestamp": "iso8601",
  "last30dVolumeUSD": "number",
  "projectedVipTierInHours": "number|null"
}

// order.plan.proposed â€” yeni plan (VIVO-19) â†’ maliyet deÄŸerlendirmesi iÃ§in
{
  "event": "order.plan.proposed",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeMode": "spot|usdm|coinm",
  "entryPlan": {
    "mode": "market|limit|stop_market|stop_limit",
    "legs": [{"type":"string","qty":"number","price":"number|null","ttlSec":"number"}]
  },
  "protection": {
    "stopLoss": {"price":"number"},
    "takeProfit": [{"ratio":"number","price":"number"}]
  },
  "risk": {"riskPerTradePct":"number","plannedRR":"number"},
  "audit": {"variant":"base|aggressive|conservative","tpSlStyle":"ATR|range|hybrid"}
}

// position.snapshot â€” aÃ§Ä±k pozisyonlar (funding etki sÃ¼resi iÃ§in)
{
  "event": "position.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "side": "long|short",
  "tradeId": "string",
  "qtyOpen": "number",
  "avgPrice": "number",
  "tradeMode": "usdm|coinm|spot",
  "entryTime": "iso8601"
}

// market.refs â€” baÄŸlam (gerektiÄŸinde; basis ve spread teyidi)
{
  "event": "market.refs",
  "timestamp": "iso8601",
  "symbol": "string",
  "mid": "number",
  "spreadBps": "number",
  "volZScore": "number"
}

Ã‡Ä±ktÄ±lar (Tahmin, BÃ¼tÃ§e ve UyarÄ±lar)
// Maliyet tahmini (instrument-level)
{
  "event": "cost.forecast.update",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeMode": "spot|usdm|coinm",
  "fee": {"makerBp":"number","takerBp":"number","effectiveMakerBp":"number","effectiveTakerBp":"number"},
  "funding": {
    "period": "8h|4h|1h",
    "nextFundingTime": "iso8601",
    "predictedNextRateBp": "number|null",
    "windowMinutesToFunding": "number",
    "signHint": "pay_long|pay_short|neutral"
  },
  "derived": {
    "basisBpAnnual":"number|null",
    "riskLevel": "low|elevated|high"        // funding+basis'e baÄŸlÄ± sÄ±nÄ±flandÄ±rma
  }
}

// Plan bazlÄ± maliyet/bÃ¼tÃ§e karÅŸÄ±laÅŸtÄ±rmasÄ± (VIVO-19 planÄ±na advisory)
{
  "event": "cost.budget.advice",
  "timestamp": "iso8601",
  "correlationId": "string|null",
  "symbol": "string",
  "side": "long|short",
  "plannedRR": "number",
  "assumptions": {
    "fillStyle": "maker|taker|mixed",
    "expectedHoldMinutes": "number"       // supervisor veya geÃ§miÅŸten tahmin
  },
  "expectedCosts": {
    "feesBp": "number",                    // notional'a gÃ¶re
    "fundingBp": "number",                 // beklenen hold sÃ¼resine gÃ¶re
    "totalBp": "number",
    "totalPctOfPlannedR": "number"         // (maliyet / (plannedRR*riskUnit)) normalize edilmiÅŸ oran
  },
  "recommendations": [
    "prefer_maker_post_only",
    "avoid_opening_within_20m_to_funding",
    "short_bias_ok_funding_positive",
    "reduce_hold_to_45m",
    "switch_to_spot_if_possible"
  ],
  "severity": "info|warn|block",
  "reasonCodes": ["high_funding_window","high_taker_fee","rr_eroded"]
}

// AÃ§Ä±k pozisyonlar iÃ§in funding yaklaÅŸÄ±rken uyarÄ±/aksiyon penceresi
{
  "event": "cost.window.supervisorHint",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeId": "string",
  "minutesToFunding": "number",
  "suggest": ["tighten_trailing","scale_out_25","close_before_funding"],
  "reasonCodes": ["funding_spike_risk"]
}

// AÅŸÄ±rÄ± maliyet/uygunsuz plan durumunda alarm
{
  "event": "cost.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"symbol":"string","correlationId":"string|null","reasonCodes":["string"]}
}

// Telemetri
{
  "event": "cost.forecaster.metrics",
  "timestamp": "iso8601",
  "avgAdviceMs": "number",
  "adviceRates": {"info":"number","warn":"number","block":"number"},
  "makerUsageSuggestRate": "number",
  "fundingWindowAvoidRate": "number"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

FundingSnapshot, FeesSchedule, AccountTradingStats, OrderPlanProposed, PositionSnapshot, MarketRefs.

CostForecastUpdate, CostBudgetAdvice, CostWindowSupervisorHint, CostAlert, CostForecasterMetrics.

YardÄ±mcÄ±: HoldEstimatorInput/Output, EffectiveFeeCalc, FundingCostCalc, AdviceSeverity.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: funding.snapshot, fees.schedule, account.tradingStats, order.plan.proposed, position.snapshot, market.refs

Out: cost.forecast.update, cost.budget.advice, cost.window.supervisorHint, cost.alert, cost.forecaster.metrics

Konfig & VarsayÄ±lanlar
{
  // Funding penceresi eÅŸikleri
  fundingWindow: { warnMin: 30, blockMin: 10 },     // funding'e kalan dakika
  fundingRiskBp: { elevated: 20, high: 35 },        // bp/period (mutlak)

  // Ãœcretler ve varsayÄ±m
  defaultFillStyle: "mixed",                        // maker %40, taker %60
  makerShare: 0.4,
  takerShare: 0.6,

  // Beklenen tutuÅŸ sÃ¼resi (hold) modeli (dk)
  holdEstimator: { fallbackMin: 90, useSupervisorPath: true },

  // Râ€™a gÃ¶re bÃ¼tÃ§e sÄ±nÄ±rlarÄ±
  costAsPctOfPlannedR: { warn: 0.25, block: 0.45 }, // maliyet / beklenen R

  // Spot geÃ§iÅŸ Ã¶nerisi
  suggestSpotIfCostly: true,

  // Tier projeksiyonu
  tierProjectionHorizonMin: 240,                    // 4 saat iÃ§inde tier dÃ¼ÅŸecekse beklensin mi?

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Hesaplamalar (FormÃ¼ller)

Effective Fee (bp)

makerEff = makerFeeBp + (discounts?.extraMakerBp || 0)

takerEff = takerFeeBp + (discounts?.extraTakerBp || 0)

Mixed: feesBp = makerEff * makerShare + takerEff * takerShare

Maker/Taker: feesBp = makerEff veya takerEff

Funding Cost (bp)

bp_per_period = predictedNextRateBp ?? lastFundingRateBp

holdPeriods = expectedHoldMinutes / periodMinutes

Signed cost:

long â†’ fundingBp = +bp_per_period * holdPeriods (pozitif BP = long Ã¶der)

short â†’ fundingBp = -bp_per_period * holdPeriods

Notionalâ€™a gÃ¶re parasal etkiler VIVO-22 (logger) tarafÄ±nda hesaplanÄ±r; burada bp raporlanÄ±r.

Total Cost & R KarÅŸÄ±laÅŸtÄ±rmasÄ±

totalBp = feesBp + fundingBp

totalPctOfPlannedR = |totalBp| / (plannedRR * 10000) (R â†’ bp Ã§evirimi: 1R â‰ˆ 10000bp* riskUnit varsayÄ±mÄ± yoksa normalize amaÃ§lÄ± oran; burada oran raporlanÄ±r)

EÅŸikler: warn ve block.

Risk Seviyesi & Pencere

minutesToFunding = diff(nextFundingTime, now)

riskLevel =

high if |bp_per_period| â‰¥ fundingRiskBp.high

elevated if â‰¥ fundingRiskBp.elevated

else low

signHint = pay_long (bp>0) | pay_short (bp<0) | neutral.

Algoritma (Karar AkÄ±ÅŸÄ±)

State GÃ¼ncelle

Son funding.snapshot, fees.schedule, account.tradingStats ve market.refs deÄŸerlerini cacheâ€™le.

fees.schedule geldiÄŸinde effective maker/taker bpâ€™lerini hesaplayÄ±p sakla.

Instrument Forecast

Her yeni funding.snapshot â†’ cost.forecast.update yayÄ±nla (risk seviyesi, pencere, signHint).

Plan DeÄŸerlendirme (order.plan.proposed)

Assumptions.fillStyle: defaultFillStyle veya plan moduna gÃ¶re tahmin (market â†’ taker, limit â†’ maker bias).

Expected hold: config/position.snapshot/VIVO-21 izlerinden tahmin (yoksa fallbackMin).

Costs: feesBp + fundingBp â†’ totalPctOfPlannedR karÅŸÄ±laÅŸtÄ±r.

Seviye:

block eÅŸiÄŸi aÅŸÄ±lÄ±rsa: recommendations += ["avoid_opening_within_Xm_to_funding","prefer_maker_post_only","reduce_hold"]

warn ise: tavsiyeler, severity="warn".

low ise: severity="info".

Spot geÃ§iÅŸi: tradeMode usdm|coinm ve suggestSpotIfCostly + totalPctOfPlannedR â‰¥ block â†’ "switch_to_spot_if_possible" Ã¶ner.

AÃ§Ä±k Pozisyon Penceresi (position.snapshot)

minutesToFunding â‰¤ fundingWindow.warnMin ve riskLevel != low:

cost.window.supervisorHint (Ã¶r. "tighten_trailing", "scale_out_25", "close_before_funding").

â‰¤ fundingWindow.blockMin ve riskLevel == high â†’ mesajda daha gÃ¼Ã§lÃ¼ Ã¶neriler.

Tier Projeksiyonu

projectedVipTierInHours â‰¤ tierProjectionHorizonMin/60 ise feesBp yakÄ±nda dÃ¼ÅŸecek; â€œerteleâ€ Ã¶nerisi ekle (non-block).

UyarÄ± & Telemetri

AykÄ±rÄ± deÄŸerler (bp > Â±100, window negatif vs.) â†’ cost.alert(warn|error).

Her 10 sn: cost.forecaster.metrics (ortalama gecikme, Ã¶neri oranlarÄ±).

GerÃ§ek DÃ¼nya KurallarÄ± (Uyum)

YÃ¶n baÄŸÄ±mlÄ± funding: long Ã¶der (bp>0), short alÄ±r; bp<0 ise long alÄ±r (pozitif katkÄ±). ModÃ¼l bunu iÅŸaretler ama karar vermez.

Maker Ã¶nceliÄŸi: EÄŸer severity="warn|block" ise ilk Ã¶neri post-only maker giriÅŸidir (VIVO-26 ile uyumlu).

Zamanlama: Fundingâ€™e Ã§ok az kala (â‰¤ blockMin) yeni giriÅŸ yerine ertelenmesi Ã¶nerilir.

Idempotency: AynÄ± plan/correlationId iÃ§in aynÄ± girdilerde aynÄ± advice Ã¼retilmeli (hash tabanlÄ± tekrar korumasÄ±).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/fundingAndFeesForecaster.ts

src/vivo/state/costStore.ts (fees/funding cache + per-symbol forecast)

src/vivo/lib/fees.ts (effective fee bp), src/vivo/lib/funding.ts (bp/period â†’ bp/hold hesaplarÄ±)

__tests__/fundingAndFeesForecaster.test.ts

Mimari

Saf Ã§ekirdek: evaluate(event, state, cfg) â†’ emissions[]

I/O adaptÃ¶rÃ¼: bus subscribe/publish; clock = Europe/Istanbul.

Validasyon

Zod; sayÄ±sal alanlar finite(); periodMinutes sÃ¶zlÃ¼ÄŸÃ¼ {8h:480,4h:240,1h:60}.

Performans

p99 < 5ms hedef; hafif hesap, state cache O(1).

GÃ¼n Sonu

Metrik sayaÃ§larÄ± gÃ¼n sonunda sÄ±fÄ±rla; forecast state korunur.

Test Ä°skeleti (Jest)

bp_per_period=+35 (8h), minutesToFunding=18 â†’ advice.severity="block", reason=high_funding_window

fillStyle=market â†’ takerEff kullanÄ±lÄ±r; mixedâ†’aÄŸÄ±rlÄ±klÄ± hesap

short tarafÄ±nda bp>0 â†’ fundingBp negatif (rebate) ve severity dÃ¼ÅŸer

holdEstimator fallback ile fundingBp Ã¶lÃ§eklenir

fees.discount enabled â†’ effective bp dÃ¼ÅŸer

projectedVipTierInHours < horizon â†’ ertele Ã¶nerisi eklenir

position.snapshot yakÄ±n funding high â†’ supervisorHint("tighten_trailing")

idempotent: aynÄ± plan iÃ§in aynÄ± advice

aykÄ±rÄ± deÄŸer â†’ cost.alert(warn|error)

Ã–rnek Senaryo (Ã–zet)

Durum

funding.snapshot: symbol=AVAXUSDT, period=8h, last=+32 bp, predicted=+38 bp, nextFunding=08:00, ÅŸimdi 07:45 (15 dk kaldÄ±).

fees.schedule: maker=1.6 bp, taker=5.0 bp, discounts.extraMaker=-0.4 bp.

order.plan.proposed: plannedRR=1.2, entryPlan.mode="market" (taker aÄŸÄ±rlÄ±klÄ±), tradeMode="usdm".

holdEstimator: 90 dk.

Hesap

Effective fees (taker): â‰ˆ 5.0 bp.

Funding: +38 bp/8h â†’ 90 dk â‰ˆ 1.5h/8h = 0.1875 period â†’ +7.125 bp (long Ã¶der).

Toplam: â‰ˆ 12.1 bp. totalPctOfPlannedR (normalize gÃ¶sterge) â†’ uyarÄ± dÃ¼zeyi.

Beklenen Ã‡Ä±ktÄ±lar (Ã¶zet)

{
  "event":"cost.budget.advice",
  "symbol":"AVAXUSDT","side":"long","plannedRR":1.2,
  "assumptions":{"fillStyle":"taker","expectedHoldMinutes":90},
  "expectedCosts":{"feesBp":5.0,"fundingBp":7.1,"totalBp":12.1,"totalPctOfPlannedR":0.33},
  "recommendations":["avoid_opening_within_20m_to_funding","prefer_maker_post_only","reduce_hold_to_45m","switch_to_spot_if_possible"],
  "severity":"block",
  "reasonCodes":["high_funding_window","rr_eroded","high_taker_fee"]
}


AÃ§Ä±k pozisyon varsa:

{
  "event":"cost.window.supervisorHint",
  "symbol":"AVAXUSDT","tradeId":"...","minutesToFunding":15,
  "suggest":["tighten_trailing","scale_out_25"],"reasonCodes":["funding_spike_risk"]
}

Entegrasyon NotlarÄ±

VIVO-19 Composer: cost.budget.advice severity="warn|block" ise post-only/maker ve TTL erteleme lehine parametre ayarlasÄ±n; switch_to_spot_if_possible Ã¶nerisini dikkate alabilir.

VIVO-21 Supervisor: cost.window.supervisorHint ile funding Ã¶ncesi trailing sÄ±kÄ±laÅŸtÄ±rma/scale-out/kapatma sinyallerini uygular.

VIVO-22 Logger: KapanÄ±ÅŸta funding kalemi net PnLâ€™den dÃ¼ÅŸer; bu modÃ¼lÃ¼n bp tahmini ile gerÃ§ekleÅŸen farkÄ± raporlar (Ã¶ÄŸrenmeye veri).

VIVO-26 Guard: block seviyesinde gelen advice, halt_entry veya block_aggressive ile birlikte daha sÄ±kÄ± giriÅŸ kÄ±sÄ±tÄ±na dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lebilir.
_________________________________________________________________________________________________________________
VIVO-29 Â· policyCoordinator.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

TÃ¼m politika kaynaklarÄ±nÄ± (varsayÄ±lanlar, LIVIA guard, manuel override, governance Ã¶nerileri vb.) tek kanonik politika snapshotâ€™Ä±nda birleÅŸtirmek.

Ã‡akÄ±ÅŸma Ã§Ã¶zÃ¼mÃ¼, Ã¶ncelik sÄ±rasÄ±, kapsam (global/cluster/symbol/variant/timeframe) kurallarÄ±yla karar verip policy.diff yayÄ±nlamak.

AÅŸamalÄ± yayma (rollout): yÃ¼zde/kÃ¼me/canary hedefleri, effectiveAt/expireAt, rollback.

Ä°lgili modÃ¼llere uygulanabilir direktifler Ã¼retmek (Throttler, Balancer, Supervisor, Guard, Composer).

Bu modÃ¼l policyâ€™nin tek doÄŸrusudur. Trade karar vermez; sadece kurallarÄ± yayÄ±nlar.

Girdiler (Event / JSON ÅemalarÄ±)
// policy.source.update â€” her kaynaktan gelen politika parÃ§alarÄ±
{
  "event": "policy.source.update",
  "timestamp": "iso8601",
  "source": "default|livia|manual|governance|runtime",
  "priority": "number",                 // yÃ¼ksek sayÄ± = yÃ¼ksek Ã¶ncelik (Ã¶rn: manual=100, governance=80, livia=70, default=10)
  "scope": {                            // kime uygulanÄ±r
    "level": "global|cluster|symbol|variant|timeframe",
    "cluster": "string|null",
    "symbol": "string|null",
    "variant": "base|aggressive|conservative|null",
    "timeframe": "M1|M5|M15|H1|H4|D1|null"
  },
  "window": {                           // zaman penceresi (opsiyonel)
    "effectiveAt": "iso8601|null",
    "expireAt": "iso8601|null",
    "rollout": {"percent": "0..100|null", "canaryTags": ["string"]}  // Ã¶r: "beta_users"
  },
  "patch": {                            // kÄ±smi gÃ¼ncelleme (JSON Merge Patch semantiÄŸi)
    "risk": {
      "riskPerTradePct": "number|null",
      "totalRiskPct": "number|null",
      "kellyCap": "number|null",
      "dailyMaxTrades": "number|null",
      "maxConcurrentPerSymbol": "number|null",
      "globalMaxConcurrent": "number|null",
      "longShortImbalancePct": "number|null"
    },
    "quality": {
      "confirmationBounds": {"min":"number|null","max":"number|null"},
      "openBarPolicy": "penalize|defer|block|null",
      "slippageHardBps": "number|null",
      "latencyHardMs": "number|null"
    },
    "variants": {
      "allowed": {"base": "boolean|null","aggressive":"boolean|null","conservative":"boolean|null"}
    },
    "clusters": {                       // per cluster/sector limitleri (opsiyonel)
      "caps": {"Layer1":"number|null","DeFi":"number|null","Infra":"number|null","Other":"number|null"}
    },
    "symbols": {                        // per symbol limit/override (opsiyonel)
      "AVAXUSDT": {"perSymbolPct":"number|null","cooldownMin":"number|null"}
    },
    "throttle": {
      "maxBurstsPerMin": "number|null",
      "slowdownEnabled": "boolean|null"
    }
  },
  "audit": {"reasonCodes": ["string"], "note":"string|null", "changeId":"string|null"}
}

// risk.governance.recommendation â€” VIVO-23â€™ten gelen Ã¶neriler
{
  "event": "risk.governance.recommendation",
  "timestamp": "iso8601",
  "incidentId": "string",
  "recommendations": ["apply_cooldown_30m","halt_new_intents_10m","disable_aggressive_variant_2h","tighten_confirmation_by_0.01"],
  "rationale": ["string"]
}

// connectivity/piyasa sinyalleri (uyum amaÃ§lÄ±; sadece okuma)
{
  "event": "sentry.guard.directive|latency_slip.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic|halt_entry|block_aggressive",
  "expiresAt": "iso8601"
}

Ã‡Ä±ktÄ±lar (Kanonik Politika & Uygulama)
// policy.snapshot â€” kanonik, birleÅŸtirilmiÅŸ ve Ã§Ã¶zÃ¼mlenmiÅŸ politika
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "effectiveAt": "iso8601",
  "expiresAt": "iso8601|null",
  "hash": "string",
  "sourceStack": [                      // katkÄ± veren yamalar (Ã¶ncelik sÄ±rasÄ±na gÃ¶re)
    {"source":"manual","priority":100,"changeId":"MAN-2025-09-01-01"},
    {"source":"governance","priority":80,"changeId":"RIS-..."},
    {"source":"livia","priority":70,"changeId":"LIV-..."},
    {"source":"default","priority":10,"changeId":"DEF-..."}
  ],
  "policy": {
    "riskPerTradePct": "number",
    "totalRiskPct": "number",
    "kellyCap": "number",
    "dailyMaxTrades": "number",
    "maxConcurrentPerSymbol": "number",
    "globalMaxConcurrent": "number",
    "longShortImbalancePct": "number",
    "confirmationBounds": {"min":"number","max":"number"},
    "openBarPolicy": "penalize|defer|block",
    "slippageHardBps": "number",
    "latencyHardMs": "number",
    "variants": {"base": true, "aggressive": false, "conservative": true},
    "clusterCaps": {"Layer1":"number","DeFi":"number","Infra":"number","Other":"number"},
    "symbolOverrides": {"AVAXUSDT":{"perSymbolPct":"number","cooldownMin":"number|null"}},
    "throttle": {"maxBurstsPerMin":"number","slowdownEnabled":"boolean"}
  },
  "scopeIndex": [                       // kapsam bazÄ±nda farklar (en spesifik kazanÄ±r)
    {"scope":{"level":"global"},"policyRef":"hash#global"},
    {"scope":{"level":"cluster","cluster":"Layer1"},"policyRef":"hash#cluster:Layer1"},
    {"scope":{"level":"symbol","symbol":"AVAXUSDT"},"policyRef":"hash#symbol:AVAXUSDT"},
    {"scope":{"level":"variant","variant":"aggressive"},"policyRef":"hash#variant:aggressive"}
  ]
}

// policy.diff â€” eskiâ†’yeni farklar (Ã¶zet)
{
  "event": "policy.diff",
  "timestamp": "iso8601",
  "versionFrom": "number",
  "versionTo": "number",
  "changes": [
    {"path":"/variants/aggressive","from":true,"to":false,"reasonCodes":["disable_aggressive_variant_2h"]},
    {"path":"/confirmationBounds/min","from":0.58,"to":0.60,"reasonCodes":["tighten_confirmation_by_0.01"]}
  ],
  "rollout": {"percent": 100, "canaryTags": []}
}

// policy.apply.directive â€” alt modÃ¼ller iÃ§in uygulanabilir emirler
{
  "event": "policy.apply.directive",
  "timestamp": "iso8601",
  "version": "number",
  "targets": ["throttler","balancer","supervisor","guard","composer"],
  "scope": {"level":"global|cluster|symbol|variant|timeframe","symbol":"string|null","variant":"string|null"},
  "actions": [
    {"type":"set_limit","key":"riskPerTradePct","value":"number"},
    {"type":"toggle_variant","variant":"aggressive","enabled":false},
    {"type":"set_confirm_bounds","min":"number","max":"number"},
    {"type":"set_cluster_cap","cluster":"Layer1","value":"number"},
    {"type":"set_symbol_cap","symbol":"AVAXUSDT","value":"number"},
    {"type":"set_throttle","maxBurstsPerMin":"number"}
  ],
  "effectiveAt": "iso8601",
  "expiresAt": "iso8601|null"
}

// Rollback (acil geri dÃ¶nÃ¼ÅŸ)
{
  "event": "policy.rollback",
  "timestamp": "iso8601",
  "rollbackToVersion": "number",
  "reason": "string"
}

// Telemetri & uyarÄ±
{
  "event": "policy.metrics",
  "timestamp": "iso8601",
  "applies": "number",
  "rollouts": "number",
  "rollbacks": "number",
  "conflictsResolved": "number",
  "canaryCoveragePct": "number"
}
{
  "event": "policy.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"conflictPaths":["string"]}
}

Ã–ncelik ve Kapsam KurallarÄ±

Kaynak Ã¶nceliÄŸi (yÃ¼ksekten dÃ¼ÅŸÃ¼ÄŸe): manual (100) â†’ governance (80) â†’ livia (70) â†’ runtime (60) â†’ default (10).

Kapsam Ã¶zgÃ¼llÃ¼ÄŸÃ¼: symbol > cluster > variant > timeframe > global.
AynÄ± alan iÃ§in daha spesifik kapsam genel kapsamÄ± gÃ¶lger.

Zaman penceresi: effectiveAt gelmedi ise now, expireAt geÃ§tiyse geÃ§ersiz.
Zamansal Ã§akÄ±ÅŸmada en gÃ¼ncel (en yÃ¼ksek priority) kazanÄ±r.

Rollout: rollout.percent < 100 ise canary; hedefleme canaryTags veya pseudo-random hash (correlationId/ symbol) ile deterministik.

TypeScript ArayÃ¼zleri (Ã¼rettir)

PolicySourceUpdate, PolicyPatch, Scope, Window, SourceMeta.

PolicySnapshot, PolicyDiff, PolicyApplyDirective, PolicyRollback, PolicyMetrics, PolicyAlert.

YardÄ±mcÄ±: CoordinatorState, ScopeKey, MergeResult, RolloutSelector, Conflict, VersionClock.

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: policy.source.update, risk.governance.recommendation, sentry.guard.directive, latency_slip.guard.directive

Out: policy.snapshot, policy.diff, policy.apply.directive, policy.rollback, policy.metrics, policy.alert

Konfig & VarsayÄ±lanlar
{
  versionStart: 1000,
  defaultPolicy: {
    riskPerTradePct: 0.5,
    totalRiskPct: 2.0,
    kellyCap: 0.25,
    dailyMaxTrades: 3,
    maxConcurrentPerSymbol: 1,
    globalMaxConcurrent: 3,
    longShortImbalancePct: 1.0,
    confirmationBounds: { min: 0.58, max: 0.72 },
    openBarPolicy: "penalize",
    slippageHardBps: 15,
    latencyHardMs: 1800,
    variants: { base: true, aggressive: true, conservative: true },
    clusterCaps: { Layer1: 1.2, DeFi: 0.8, Infra: 0.8, Other: 0.8 },
    symbolOverrides: {},
    throttle: { maxBurstsPerMin: 3, slowdownEnabled: true }
  },
  precedence: { manual: 100, governance: 80, livia: 70, runtime: 60, default: 10 },
  rollout: { defaultPercent: 100, hashSalt: "vivo29" },
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

CoordinatorState (in-memory + periyodik persist data/policy.state.json):

versionClock, son PolicySnapshot, aktif overlays (kaynakâ†’scopeâ†’patch).

rolloutAssignments: correlationId/symbolâ†’bucket (deterministik).

history: diff/uygulama geÃ§miÅŸi (append-only).

Idempotency: AynÄ± changeId gelen gÃ¼ncellemeyi ikinci kez uygulama.

Algoritma (AkÄ±ÅŸ)

Kaynak GÃ¼ncellemesi Al

policy.source.update â†’ Zod doÄŸrulama â†’ valid window?

overlays[source][scopeKey] = newestByTimeAndPriority(patch) olarak cacheâ€™le.

Governance Ã–nerilerini Haritala

disable_aggressive_variant_2h â†’ patch.variants.allowed.aggressive=false + expireAt = now+2h.

apply_cooldown_30m â†’ symbolOverrides.*.cooldownMin = max(existing,30).

tighten_confirmation_by_0.01 â†’ confirmationBounds.min += 0.01 (clamp â‰¤ maxâˆ’0.01).

halt_new_intents_10m â†’ throttle.maxBurstsPerMin = 0, expireAt=+10m.

Kanonik Snapshot Ãœret

base = defaultPolicy.

TÃ¼m overlayâ€™leri priority desc â†’ scope specificity desc sÄ±rasÄ± ile JSON merge-patch uygula.

Zaman penceresi dÄ±ÅŸÄ± yamalarÄ± atla. Conflicts kaydet (policy.alert(warn)).

Rollout Uygula (opsiyonel)

rollout.percent < 100 yamalar iÃ§in RolloutSelector: symbol/correlationId hashâ†’bucket.

Canary dÄ±ÅŸÄ±nda kalanlara ilgili alanlar baseâ€™ten devam.

Yeni SÃ¼rÃ¼m & Diff

Hash Ã¼ret (snapshot.policy). if (hash != lastHash) â†’ version++, policy.diff oluÅŸtur.

policy.snapshot ve uygulama direktifleri yayÄ±nla:

Throttler: dailyMaxTrades, throttle, variants.allowed.

Balancer: totalRiskPct, clusterCaps, longShortImbalancePct.

Supervisor/Guard: slippageHardBps, latencyHardMs, openBarPolicy.

Composer: confirmationBounds, riskPerTradePct, perSymbolPct.

Sona Erme & Rollback

expireAt geÃ§en overlayâ€™leri otomatik sil â†’ yeni snapshot yayÄ±nla.

policy.rollback gelirse rollbackToVersionâ€™Ä± historyden al, snapshotâ€™Ä± geri sar.

Telemetri

10 snâ€™de bir policy.metrics (applies/rollouts/rollbacks/conflicts).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/policyCoordinator.ts

src/vivo/state/policyStore.ts (overlays + snapshot + history)

src/vivo/lib/mergePatch.ts, src/vivo/lib/rollout.ts, src/vivo/lib/diff.ts

__tests__/policyCoordinator.test.ts

Mimari

Saf Ã§ekirdek: recompute(state, cfg, now) â†’ {snapshot, diffs, directives, alerts}

IO adaptÃ¶rÃ¼: bus subscribe/publish + persist + timers (expire sweep).

Validasyon

Zod ÅŸemalarÄ±; clamp: 0â‰¤min<maxâ‰¤1 (confirmation), yÃ¼zdelik alanlar 0..100.

GeÃ§ersiz patch â†’ policy.alert(error,"invalid_patch").

Idempotency

changeId veya eventHash ile tekrarÄ± yut; aynÄ± snapshot hashâ€™i â†’ yayÄ±nlama.

Performans

p99 < 5ms hedef; overlay sayÄ±sÄ± artsa da O(S log S) (s=overlay sayÄ±sÄ±).

Test Ä°skeleti (Jest)

manual vs livia Ã§akÄ±ÅŸma â†’ manual kazanÄ±r; diff doÄŸru

symbol override globalâ€™i gÃ¶lgeler

governance:disable_aggressive_variant_2h â†’ expire sonrasÄ± otomatik geri aÃ§Ä±lÄ±r

tighten_confirmation_by_0.01 â†’ clamp â‰¤ max-0.01

rollout 30% â†’ deterministik bucket; canary dÄ±ÅŸÄ± etkilenmez

policy.snapshot hash deÄŸiÅŸmezse version artmaz

rollback â†’ Ã¶nceki snapshot geri gelir

invalid patch â†’ policy.alert(error)

throttle=0 (halt) â†’ policy.apply.directive targets=throttler

Ã–rnek Senaryo (Ã–zet)

Girdiler

default yÃ¼klenmiÅŸ.

risk.governance.recommendation: ["disable_aggressive_variant_2h","tighten_confirmation_by_0.01"]

policy.source.update(manual):

scope=symbol: AVAXUSDT, patch=symbols.AVAXUSDT.perSymbolPct=0.6

window=effectiveAt=now, expireAt=null

livia: totalRiskPct=1.8 Ã¶nerdi (geÃ§ici savunma).

Beklenen YayÄ±nlar

policy.diff:

/variants/aggressive: trueâ†’false

/confirmationBounds/min: 0.58â†’0.59

/symbols/AVAXUSDT/perSymbolPct: 0.8â†’0.6

/totalRiskPct: 2.0â†’1.8

policy.apply.directive:

toggle_variant(aggressive=false) (targets: throttler)

set_confirm_bounds(min=0.59,max=0.72) (composer)

set_symbol_cap(AVAXUSDT=0.6) (balancer)

set_limit(totalRiskPct=1.8) (balancer)

policy.snapshot(version++ , effectiveAt=now)

2 saat sonra aggressive tekrar true (expiry ile rollback-like).

Entegrasyon NotlarÄ±

VIVO-23 (Incident Reporter) â†’ Governance Ã¶nerileri doÄŸrudan policy.source.updateâ€™e dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼r; bu modÃ¼l sÃ¼re/pencere ekler.

VIVO-26 & VIVO-27 sinyalleri (halt/degraded) kalÄ±cÄ± policy deÄŸildir; ama bu modÃ¼l throttle/variants Ã¼stÃ¼nden geÃ§ici yumuÅŸatma yÃ¼kleyebilir (window/expireAt ile).

TÃ¼m tÃ¼keticiler policy.apply.directive.versionâ€™Ä± saklayÄ±p aynÄ± versiyonu iki kez uygulamamalÄ± (idempotent).
_________________________________________________________________________________________________________________
VIVO-30 Â· strategyBanditOrchestrator.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Strateji/variant/formation kollarÄ± arasÄ±nda gÃ¼venli keÅŸifâ€“istismar (multi-armed bandit) orkestrasyonu yapmak.

Policy tavanlarÄ±, risk/guard sinyalleri ve rejim uyumu ile bandit seÃ§imini kÄ±sÄ±tlamak.

Deney trafiÄŸini (A/B/Ã§ok kollu) yÃ¼zdesel pay olarak daÄŸÄ±tÄ±p idempotent seÃ§im kararÄ± Ã¼retmek.

VIVO-22/17 geri beslemesiyle Bayes gÃ¼ncellemesi yapÄ±p performans inanÃ§larÄ±nÄ± (priorsâ†’posteriors) gÃ¼ncel tutmak.

Bu modÃ¼l yalnÄ±zca seÃ§im/daÄŸÄ±tÄ±m yapar; emir aÃ§maz. Uygulama VIVO-18/19â€™da.

Girdiler (Event / JSON ÅemalarÄ±)
// strategy.catalog â€” kullanÄ±labilir kollar ve meta
{
  "event": "strategy.catalog",
  "timestamp": "iso8601",
  "arms": [
    {
      "name": "momentum_pullback_M5",
      "variant": "base|aggressive|conservative",
      "formationTag": "string|null",
      "timeframes": ["M5","M15"],
      "fits": ["trend","breakout"],
      "riskClass": "low|mid|high",
      "minSamplesToUnlock": 50,
      "trafficCapPct": 60
    }
  ]
}

// policy.snapshot â€” politika kÄ±sÄ±tlarÄ± (VIVO-29)
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": 1012,
  "policy": {
    "variants": {"base": true,"aggressive": false,"conservative": true},
    "confirmationBounds": {"min":0.59,"max":0.72},
    "dailyMaxTrades": 3
  }
}

// regime.snapshot â€” rejim baÄŸlamÄ± (Grafik Beyni)
{
  "event": "regime.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "regime": "trend|range|breakout|highVol|illiquid"
}

// vivo.feedback.raw â€” performans geri beslemesi (VIVO-22)
{
  "event": "vivo.feedback.raw",
  "timestamp": "iso8601",
  "scope": {"symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null"},
  "kpis": {"hit":"0|1","profitFactor":"number","rMultiple":"number","slippageBps":"number","fees":"number"},
  "samples": {"fills":"int"}
}

// risk.incident.* â€” gÃ¼venlik/ihlal sinyalleri (VIVO-23)
{
  "event": "vivo.feedback.incident|risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "type": "series_loss|drawdown_breach|execution_anomaly|data_staleness|exposure_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"}
}

// guard directives â€” giriÅŸleri sÄ±nÄ±rlayan modlar (VIVO-26/27)
{
  "event": "latency_slip.guard.directive|sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|slowdown|block_aggressive|halt_entry|degraded|streams_panic",
  "expiresAt": "iso8601"
}

// execution.intent.request â€” orkestratÃ¶rden seÃ§im talebi
{
  "event": "execution.intent.request",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "context": {"regime":"string","confidence":"0..1"},
  "audit": {"requestId":"string"}
}

Ã‡Ä±ktÄ±lar (SeÃ§im, Trafik, Telemetri)
// SeÃ§im kararÄ± (tek kol)
{
  "event": "strategy.selection.decision",
  "timestamp": "iso8601",
  "requestId": "string",
  "symbol": "string",
  "timeframe": "string",
  "mode": "explore|exploit|safe_fallback|blocked",
  "selectedArm": {
    "name": "string",
    "variant": "base|aggressive|conservative",
    "formationTag": "string|null"
  },
  "allocationPct": "number",                 // 0..100; intent trafiÄŸinde bu kola ayrÄ±lacak pay
  "policyVersion": "number",
  "reasonCodes": ["string"],                 // Ã¶r: "ucb_max", "ts_sample_best", "variant_blocked", "guard_active"
  "constraints": {"minConfirm": "number","haltEntry": false}
}

// Ã‡ok kollu daÄŸÄ±tÄ±m (batch)
{
  "event": "strategy.traffic.plan",
  "timestamp": "iso8601",
  "symbol": "string",
  "timeframe": "string",
  "allocations": [
    {"arm":"momentum_pullback_M5:base","pct":55},
    {"arm":"breakout_M5:conservative","pct":45}
  ],
  "mode": "explore_mix|exploit_dominant",
  "ttlSec": 300,
  "reasonCodes": ["soft_explore_cap","cold_start_arm"]
}

// Bandit durum gÃ¼ncellemesi (posterior snapshot)
{
  "event": "strategy.bandit.state",
  "timestamp": "iso8601",
  "arms": [
    {
      "arm":"momentum_pullback_M5:base",
      "posteriors":{
        "hitRate": {"alpha":"number","beta":"number"},
        "rMean": {"mu":"number","sigma":"number"}
      },
      "trafficSharePct": "number",
      "safety": {"cooldownUntil":"iso8601|null","blocked":false}
    }
  ]
}

// Telemetri & uyarÄ±
{
  "event": "strategy.bandit.metrics",
  "timestamp": "iso8601",
  "exploreRate": "number",
  "blockedRate": "number",
  "avgSamplesPerArm": "number",
  "coldStartActive": "boolean"
}
{
  "event": "strategy.bandit.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"arm":"string","reasonCodes":["string"]}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: StrategyCatalog, PolicySnapshot, RegimeSnapshot, FeedbackRaw, IncidentEvent, GuardDirective, ExecutionIntentRequest.

Outputs: StrategySelectionDecision, StrategyTrafficPlan, StrategyBanditState, StrategyBanditMetrics, StrategyBanditAlert.

Helpers:
ArmKey (name:variant:formationTag:timeframe),
BanditParams (priors), PosteriorHitRate (Beta), PosteriorR (Gaussian),
SafetyGate (cooldown/blocked), RandomSource (deterministic seed).

Zod: tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: strategy.catalog, policy.snapshot, regime.snapshot, vivo.feedback.raw, risk.incident.*, latency_slip.guard.directive, sentry.guard.directive, execution.intent.request

Out: strategy.selection.decision, strategy.traffic.plan, strategy.bandit.state, strategy.bandit.metrics, strategy.bandit.alert

Konfig & VarsayÄ±lanlar
{
  // Bandit yÃ¶ntemi
  bandit: {
    mode: "thompson_ucb_hybrid",  // TS + risk ayarlÄ± UCB karÄ±ÅŸÄ±mÄ±
    exploreFloorPct: 10,          // min keÅŸif trafiÄŸi
    exploreCapPct: 35,            // max keÅŸif trafiÄŸi
    coldStartTrafficPct: 20,      // yeni kola baÅŸlangÄ±Ã§
    minSamplesToExploit: 30,      // bundan azsa tam istismar etme
    ucbConfidenceZ: 1.0           // UCB z-Ã§arpanÄ±
  },

  // GÃ¼venlik kapÄ±larÄ±
  safety: {
    blockAggressiveWhenGuard: true,
    blockWhenStreamsPanic: true,
    cooldownOnIncident: {
      "series_loss": "PT30M",
      "drawdown_breach": "PT2H",
      "execution_anomaly": "PT20M"
    }
  },

  // Rejim eÅŸleÅŸme bonus/ceza
  regimeFit: { matchBonus: 0.02, mismatchPenalty: 0.03, highVolPenalty: 0.04, illiquidBlock: true },

  // Trafik & adalet
  traffic: { rebalanceTtlSec: 300, perArmCapPct: 60, perVariantCapPct: {"aggressive": 0, "base": 70, "conservative": 70} },

  // Priors (Bayes)
  priors: {
    hitRate: {"alpha": 2, "beta": 3},     // Beta(2,3) ~ %40 ilk inanÃ§
    rMean: {"mu": 0.2, "sigma": 0.6}      // R-multiple ortalamasÄ±
  },

  // Deterministiklik
  seed: "vivo30-bandit",

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

BanditStateStore (in-memory + periyodik persist data/bandit.state.json veya SQLite):

arms[ArmKey]: { posteriors.hitRate (Î±,Î²), posteriors.rMean (Î¼,Ïƒ), samples, trafficSharePct, safety, lastUpdateAt }

policyVersion, lastRegimeByTF, activeTrafficPlan{symbol,timeframe} (TTL).

rng deterministik tohumlu (seed + symbol + timeframe + requestId â†’ seÃ§im idempotent).

Idempotency: AynÄ± requestId iÃ§in aynÄ± seÃ§im.

SeÃ§im Fonksiyonu (Skor & GÃ¼venlik)

GÃ¼venlik KapÄ±larÄ±

guard.mode in ["halt_entry","streams_panic"] â†’ mode="blocked", hiÃ§bir kol seÃ§ilmez.

policy.variants.aggressive=false â†’ aggressive kollar gizle.

Son incident tipi iÃ§in cooldownOnIncident[type] sÃ¼resi dolmadÄ±ysa ilgili kol/variant blok.

Uygun KollarÄ± Filtrele

regimeFit: illiquid ve illiquidBlock==true â†’ tÃ¼m kollar blok.

catalog.fits rejime uymayan kola mismatchPenalty uygula (skorda).

minSamplesToUnlock dolmamÄ±ÅŸ yeni kollar coldStartTrafficPct ile sÄ±nÄ±rlanÄ±r.

Posterior Ã–rnekleme

Thompson:

p_hit ~ Beta(Î±,Î²), r ~ Normal(Î¼,Ïƒ) Ã¶rnekle.

Utility â‰ˆ p_hit * r (R beklentisi),
ardÄ±ndan regime bonus/penalty ekle.

UCB katkÄ±sÄ±: ucb = Î¼ + z * Ïƒ / sqrt(n); **hybridScore = 0.7TS + 0.3normalized(UCB)`.

Trafik KÄ±sÄ±tlarÄ±

perArmCapPct ve perVariantCapPct sÄ±nÄ±rlarÄ±nÄ± uygula.

exploreFloorPct â‰¤ exploreShare â‰¤ exploreCapPct.

coldStart kollar toplamÄ± â‰¤ coldStartTrafficPct.

SeÃ§im ve DaÄŸÄ±tÄ±m

Tek istek (request) iÃ§in en yÃ¼ksek hybridScore kola decision Ã§Ä±kar.

Batch/plan gerekiyorsa (Ã¶r. per-symbol stream): top-K kollarÄ± traffic.plan ile yÃ¼zdelere bÃ¶l (softmax/normalize).

Onay & Ã‡Ä±ktÄ±

strategy.selection.decision Ã¼ret; constraints.minConfirm = policy.confirmationBounds.min.

strategy.bandit.state ve metrikleri periyodik yayÄ±nla.

GÃ¼ncelleme (Ã–ÄŸrenme) MantÄ±ÄŸÄ±

vivo.feedback.raw geldiÄŸinde ArmKey eÅŸleÅŸtir:

Beta gÃ¼ncelle: Î± += hit, Î² += (1-hit).

Gaussian gÃ¼ncelle: Welford/online mean-variance; Î¼, Ïƒ gÃ¼ncellenir.

Samples artar; trafficSharePct akÄ±ÅŸa gÃ¶re EWMA ile gÃ¼ncellenir.

AykÄ±rÄ±/cezalÄ± Ã¶rnekler (execution anomaly, extreme slip) dÃ¼ÅŸÃ¼k aÄŸÄ±rlÄ±kla sayÄ±labilir (opsiyonel w=0.5).

Algoritma (YÃ¼ksek Seviye AkÄ±ÅŸ)

Katalog/Policy/Rejim gÃ¼ncel deÄŸilse â†’ alert(warn,"stale_context") ve safe_fallback (konservatif kol).

execution.intent.request â†’ gÃ¼venlikâ†’filtreâ†’skorâ†’kÄ±sÄ±tâ†’seÃ§im akÄ±ÅŸÄ±nÄ± Ã§alÄ±ÅŸtÄ±r.

feedback eventleri ile posteriors gÃ¼ncellenir, bandit.state yayÄ±nlanÄ±r.

traffic.plan TTL dolduÄŸunda veya rejim/policy deÄŸiÅŸtiÄŸinde yeniden hesaplanÄ±r.

metrics her 10 sn: exploreRate, blockedRate, avgSamplesPerArm, coldStartActive.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/strategyBanditOrchestrator.ts

src/vivo/state/banditStore.ts (posteriors + traffic + safety + RNG persist)

src/vivo/lib/beta.ts, src/vivo/lib/gauss.ts, src/vivo/lib/score.ts, src/vivo/lib/rng.ts

__tests__/strategyBanditOrchestrator.test.ts

Mimari

Saf Ã§ekirdek: select(request, state, cfg) â†’ Decision|Blocked
update(feedback, state, cfg) â†’ BanditStateDelta

IO adaptÃ¶rÃ¼: bus subscribe/publish, timers (metrics/TTL).

Validasyon

Zod; sayÄ±sal alanlar finite(). Katalog boÅŸsa safe_fallback.

Deterministiklik

RNG seed + (symbol,timeframe,requestId) â†’ kararlÄ± sonuÃ§; seed deÄŸiÅŸmeden sonuÃ§ tekrarlanabilir.

Performans

p99 < 3ms hedef (N=â‰¤32 kol varsayÄ±mÄ±); Ã¶rnekleme O(N).

Test Ä°skeleti (Jest)

guard.halt_entry â†’ decision.mode="blocked"

aggressive policy off â†’ aggressive kollar filtrelenir

illiquid regime & illiquidBlock=true â†’ blocked

coldStart arm â†’ allocation â‰¤ coldStartTrafficPct

TS+UCB hybrid â†’ yÃ¼ksek Î¼ fakat belirsiz Ïƒ kolu zamanla yÃ¼kselir

feedback hit=1 â†’ Beta Î± artar, seÃ§im olasÄ±lÄ±ÄŸÄ± yÃ¼kselir

drawdown_breach incident â†’ ilgili kol cooldown

explore caps (floor/cap) â†’ traffic.plan oranlarÄ± sÄ±nÄ±rlar iÃ§inde

deterministic RNG â†’ aynÄ± requestId aynÄ± karar

stale context â†’ safe_fallback

Ã–rnek Senaryo (Ã–zet)

Durum

Katalog:

momentum_pullback_M5:base (fits: trend/breakout)

meanRevert_M5:conservative (fits: range)

Rejim: trend

Policy: aggressive kapalÄ±; minConfirm=0.59

Posteriors (Ã¶zet):

MP5: p_hitâ‰ˆ0.55, Î¼â‰ˆ0.35R

MR5: p_hitâ‰ˆ0.48, Î¼â‰ˆ0.25R

SeÃ§im

Regime bonus MP5â€™e +0.02, MR5â€™e mismatch -0.03.

Hybrid skor MP5 > MR5 â†’ exploit.

Beklenen Ã‡Ä±ktÄ±lar

{
  "event":"strategy.selection.decision",
  "requestId":"REQ-123",
  "symbol":"AVAXUSDT","timeframe":"M5",
  "mode":"exploit",
  "selectedArm":{"name":"momentum_pullback_M5","variant":"base","formationTag":null},
  "allocationPct":100,
  "policyVersion":1012,
  "reasonCodes":["ts_sample_best","regime_match","aggressive_disabled"],
  "constraints":{"minConfirm":0.59,"haltEntry":false}
}

Entegrasyon NotlarÄ±

VIVO-18 Throttler: strategy.selection.decisionâ€™daki constraints.minConfirm ve allocationPctâ€™i tÃ¼ketip niyet basamaklarÄ±nÄ± ayarlayabilir.

VIVO-19 Composer: seÃ§ilen arma gÃ¶re parametre setleri (giriÅŸ tipi, TTL, TP/SL stili) yÃ¼klenir.

VIVO-17/22: feedback akÄ±ÅŸÄ± bu modÃ¼lÃ¼n tek Ã¶ÄŸrenme kaynaÄŸÄ±dÄ±r; loggerâ€™Ä±n trade.summary.closed ve feedback.rawâ€™Ä± yeterli.

VIVO-23/26/27/29: guard/incident/policy sinyalleri gÃ¼venlik kapÄ±sÄ± olarak uygulanÄ±r; modÃ¼l sonuÃ§larÄ±na Ã¼stteki kÄ±sÄ±tlar Ã¶nceliklidir.
_________________________________________________________________________________________________________________
VIVO-31 Â· symbolUniverseManager.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Ä°ÅŸlem yapÄ±labilir sembol evrenini dinamik yÃ¶netmek: whitelist/blacklist, likidite & kalite eÅŸikleri, dÃ¶nemsel rotasyon, canary/deneysel kÃ¼meler.

Likidite/saÄŸlÄ±k (hacim, spread, derinlik, uptime), performans (hitRate/expectancy), maliyet (fees/funding), risk/incident sinyallerini birleÅŸtirip evren snapshot Ã¼retmek.

Sonucu Throttler/QA/Balancer/Bandit gibi modÃ¼llere uygulanabilir direktif olarak yayÄ±nlamak.

Bu modÃ¼l giriÅŸ-Ã§Ä±kÄ±ÅŸ akÄ±ÅŸlarÄ±nÄ± yÃ¶netir; emir mantÄ±ÄŸÄ±na karÄ±ÅŸmaz.

Girdiler (Event / JSON ÅemalarÄ±)
// exchange.symbols.catalog â€” borsadan desteklenen semboller ve filtreleri
{
  "event": "exchange.symbols.catalog",
  "timestamp": "iso8601",
  "exchange": "string",
  "symbols": [
    {
      "symbol": "AVAXUSDT",
      "status": "TRADING|BREAK|HALT",
      "base": "AVAX",
      "quote": "USDT",
      "filters": {
        "minNotional": "number",
        "tickSize": "number",
        "stepSize": "number"
      }
    }
  ]
}

// market.liquidity.snapshot â€” likidite ve mikro yapÄ± metrikleri (rolling/periodic)
{
  "event": "market.liquidity.snapshot",
  "timestamp": "iso8601",
  "symbol": "string",
  "windowMin": 60,
  "metrics": {
    "volUSD": "number",            // pencere hacmi (USD)
    "avgSpreadBps": "number",
    "p10DepthUSD": "number",       // en iyi 10 seviye toplam derinlik
    "uptimePct": "number",         // son pencerede stream/heartbeat sÃ¼rekliliÄŸi
    "msgRatePerSec": "number"      // WS mesaj/se
  }
}

// vivo.performance.daily â€” (VIVO-22) performans Ã¶zetleri (symbolÃ—tfÃ—variant)
{
  "event": "vivo.performance.daily",
  "date": "YYYY-MM-DD",
  "scope": {"symbol":"string","timeframe":"string","variant":"string","formationTag":"string|null"},
  "kpis": {
    "trades":"int","wins":"int","hitRate":"number","profitFactor":"number",
    "avgR":"number","expectancyR":"number","avgSlipBps":"number","maxDD_R":"number"
  }
}

// cost.forecast.update â€” (VIVO-28) maliyet (fees/funding) baÄŸlamÄ±
{
  "event": "cost.forecast.update",
  "timestamp": "iso8601",
  "symbol": "string",
  "tradeMode": "spot|usdm|coinm",
  "fee": {"effectiveMakerBp":"number","effectiveTakerBp":"number"},
  "funding": {"period":"8h|4h|1h","predictedNextRateBp":"number|null","windowMinutesToFunding":"number","signHint":"string"},
  "derived": {"basisBpAnnual":"number|null","riskLevel":"low|elevated|high"}
}

// risk.incident.* â€” (VIVO-23) risk olaylarÄ±; sembol saÄŸlÄ±ÄŸÄ±nÄ± etkiler
{
  "event": "risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "type": "exposure_breach|execution_anomaly|data_staleness|series_loss|drawdown_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null"}
}

// sentry.guard.directive â€” (VIVO-27) baÄŸlantÄ± saÄŸlÄ±ÄŸÄ± (evren kararÄ± iÃ§in)
{
  "event": "sentry.guard.directive",
  "timestamp": "iso8601",
  "mode": "normal|degraded|streams_panic",
  "expiresAt": "iso8601",
  "reasonCodes": ["string"]
}

// mapping.meta â€” kÃ¼me ve beta sÄ±nÄ±flarÄ± (VIVO-25 ile uyumlu)
{
  "event": "mapping.meta",
  "overrides": {"AVAXUSDT":{"cluster":"Layer1","beta":{"BTC":0.84,"Market":1.1}}}
}

// policy.snapshot â€” evren kotalarÄ± ve kurallar (VIVO-29)
{
  "event": "policy.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "policy": {
    "clusterCaps": {"Layer1":"number","DeFi":"number","Infra":"number","Other":"number"},
    "variants": {"base":true,"aggressive":true,"conservative":true},
    "openBarPolicy": "penalize|defer|block"
  }
}

// external.universe.command â€” manuel mÃ¼dahale (opsiyonel)
{
  "event": "external.universe.command",
  "timestamp": "iso8601",
  "action": "whitelist_add|whitelist_remove|blacklist_add|blacklist_remove|watch_add|watch_remove|rotate_now",
  "symbols": ["string"]
}

Ã‡Ä±ktÄ±lar (Evren & Direktifler)
// Evrenin kanonik anlÄ±k gÃ¶rÃ¼ntÃ¼sÃ¼
{
  "event": "universe.snapshot",
  "timestamp": "iso8601",
  "version": "number",
  "hash": "string",
  "exchange": "string",
  "summary": {
    "totalSymbols": "number",
    "allowed": "number",
    "experimental": "number",
    "blacklisted": "number"
  },
  "universe": [
    {
      "symbol": "AVAXUSDT",
      "status": "allowed|experimental|blocked",
      "cluster": "Layer1",
      "score": {
        "liquidity": "0..1",
        "performance": "0..1",
        "cost": "0..1",
        "riskPenalty": "0..1",
        "composite": "0..1"
      },
      "tags": ["core","quiet_ok","funding_high_window","recent_incident"],
      "limits": {"maxRiskPct":"number|null","maxConcurrent":"number|null"}
    }
  ]
}

// Farklar (eskiâ†’yeni)
{
  "event": "universe.diff",
  "timestamp": "iso8601",
  "versionFrom": "number",
  "versionTo": "number",
  "added": ["string"],            // yeni allowed/experimental
  "removed": ["string"],          // evrenden Ã§Ä±kan
  "statusChanges": [              // allowedâ†”experimentalâ†”blocked
    {"symbol":"AVAXUSDT","from":"experimental","to":"allowed","reasonCodes":["liquidity_ok","stable_perf"]}
  ]
}

// Uygulama direktifleri (downstream hedefler)
{
  "event": "universe.apply.directive",
  "timestamp": "iso8601",
  "version": "number",
  "targets": ["throttler","qa","balancer","bandit","router"],
  "actions": [
    {"type":"allow_symbols","symbols":["BTCUSDT","ETHUSDT","AVAXUSDT"]},
    {"type":"block_symbols","symbols":["LOWLIQUSDT","HALTCOINUSDT"]},
    {"type":"experimental_symbols","symbols":["NEWCOINUSDT"]},
    {"type":"set_symbol_limit","symbol":"AVAXUSDT","maxRiskPct":0.6}
  ],
  "effectiveAt": "iso8601"
}

// Alarm/telemetri
{
  "event": "universe.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"symbols":["string"]}
}
{
  "event": "universe.metrics",
  "timestamp": "iso8601",
  "scores": {"avgLiquidity":"number","avgPerf":"number","avgCost":"number"},
  "counts": {"allowed":"number","experimental":"number","blocked":"number"},
  "rotation": {"lastAt":"iso8601","added": "number","removed":"number"}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: ExchangeSymbolsCatalog, MarketLiquiditySnapshot, DailyPerformance, CostForecastUpdate, IncidentEvent, SentryGuardDirective, MappingMeta, PolicySnapshot, ExternalUniverseCommand.

Outputs: UniverseSnapshot, UniverseDiff, UniverseApplyDirective, UniverseAlert, UniverseMetrics.

Helpers:
SymbolHealth, ScoreBreakdown, UniverseState, RotationPlan, HysteresisGate, QuotaTracker, Ranker, Hasher (deterministik canary).

Zod: tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon (NaN/âˆ reddet).

Event Bus KonularÄ±

In: exchange.symbols.catalog, market.liquidity.snapshot, vivo.performance.daily, cost.forecast.update, risk.incident.*, sentry.guard.directive, mapping.meta, policy.snapshot, external.universe.command

Out: universe.snapshot, universe.diff, universe.apply.directive, universe.alert, universe.metrics

Konfig & VarsayÄ±lanlar
{
  // Tazelik pencereleri
  freshness: { liquidityMaxAgeSec: 180, perfMaxAgeHours: 36, costMaxAgeMin: 60 },

  // Likidite eÅŸikleri (minimumlar)
  liquidityMin: { volUSD: 2e6, p10DepthUSD: 5e5, uptimePct: 0.97 },
  spreadMaxBpsAvg: 25,            // bunun Ã¼stÃ¼ riskli

  // Sembol filtreleri
  filters: { minNotional: 10, minTickPrecision: 1e-6, minStepPrecision: 1e-6 },

  // Skor aÄŸÄ±rlÄ±klarÄ± (0..1 normalizasyon sonrasÄ±)
  weights: { liquidity: 0.45, performance: 0.30, cost: 0.10, riskPenalty: 0.15 },

  // Performans skorlamasÄ±
  perfNorm: { hitRateRef: 0.5, expectancyRef: 0.15, slipPenaltyScale: 0.02 },

  // Maliyet skoru (dÃ¼ÅŸÃ¼k daha iyi â†’ ters normalize)
  costNorm: { feeBpRef: 4.0, fundingRiskRefBp: 15 },

  // Risk/incident cezasÄ±
  incidentPenalty: { low: 0.02, medium: 0.05, high: 0.10, critical: 0.20, decayHalfLifeMin: 180 },

  // Kotalar ve rotasyon
  quotas: { maxAllowed: 40, maxExperimental: 8, perClusterMax: { Layer1: 12, DeFi: 10, Infra: 8, Other: 10 } },
  rotation: { periodMin: 60, hysteresisBps: 5, promoteThreshold: 0.62, demoteThreshold: 0.55 },

  // Canary/deneysel seÃ§im
  experimental: { candidateTopK: 20, canaryPercent: 20, holdMinPeriodMin: 120 },

  // Manuel listeler Ã¶nceliÄŸi
  manual: { whitelistWins: true, blacklistWins: true },

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul",
  seed: "vivo31-universe"
}

Durum YÃ¶netimi

UniverseState (in-memory + periyodik persist data/universe.state.json):

catalog (aktif semboller + filtreler), lastLiquidityBySymbol, lastPerfBySymbolTF, lastCostBySymbol, incidentPenalties, mappingMeta, policyVersion.

currentUniverse (Map<symbol, entry>), version, lastRotationAt.

manualLists: whitelist, blacklist, watchlist.

quotaTracker: cluster/overall sayaÃ§lar.

Idempotency: AynÄ± hashâ€™li snapshot/diffâ€™i tekrar yayÄ±nlama.

Skorlamalar

Likidite Skoru (0..1)

L = w1 * min(1, volUSD / volRef) + w2 * min(1, p10DepthUSD / depthRef) + w3 * clamp(1 - avgSpreadBps/spreadMax, 0, 1) + w4 * uptimePct

Referanslar: volRef=5e6, depthRef=1e6, spreadMax=config.spreadMaxBpsAvg. (Normalize et, aÄŸÄ±rlÄ±klarÄ± eÅŸit veya sabit tut.)

Performans Skoru (0..1)

P = 0.5*normHit + 0.4*normExp + 0.1*(1 - normSlip)

normHit = clamp((hitRate - 0.35)/(0.6 - 0.35), 0, 1)

normExp = clamp((expectancyR - 0.05)/(0.25 - 0.05), 0, 1)

normSlip = clamp(avgSlipBps / (2*perfNorm.slipPenaltyScale*100), 0, 1) (uygun Ã¶lÃ§ekle)

Maliyet Skoru (0..1)

feesScore = clamp(1 - effectiveTakerBp/feeBpRef, 0, 1)

fundScore = if riskLevel=="high" then 0 else if "elevated" then 0.5 else 1

C = 0.6*feesScore + 0.4*fundScore

Risk CezasÄ± (0..1)

Son incident ÅŸiddetine gÃ¶re ceza, zamanla exponential decay: penalty = base * exp(-ln(2)*ageMin/decayHalfLifeMin)

R = 1 - penalty (yani 1 iyi, 0 kÃ¶tÃ¼)

BileÅŸik Skor

S = weights.liquidity*L + weights.performance*P + weights.cost*C + weights.riskPenalty*R

Algoritma (Karar AkÄ±ÅŸÄ±)

Tazelik KontrolÃ¼

Likidite/perf/cost verisi bayatsa sembol experimental veya blockeda dÃ¼ÅŸebilir (konfige gÃ¶re).

sentry.guard.directive.mode=="streams_panic" â†’ evren deÄŸiÅŸikliklerini yavaÅŸlat (yalnÄ±zca blocked geniÅŸlet).

Ã–n Filtreler

exchange.symbols.catalog.status!="TRADING" â†’ blocked.

filters.minNotional < config.filters.minNotional veya tick/step hassasiyeti yetersiz â†’ blocked.

Blacklistâ€™te olan â†’ blocked. Whitelistâ€™te olan â†’ filtreler geÃ§se doÄŸrudan allowed.

Skor Hesapla & Etiketle

L/P/C/R/S deÄŸerlerini hesapla.

Tagâ€™ler: core (yÃ¼ksek L ve P), experimental (S orta ama taze), recent_incident, funding_high_window, quiet_ok (avgSpread<15 bps).

Kotalar & KÃ¼meler

quotasâ€™a gÃ¶re cluster bazÄ±nda kontenjan uygula (Layer1, DeFi, â€¦).

allowed sÄ±nÄ±fÄ± iÃ§in en yÃ¼ksek S puanlÄ±lar seÃ§ilir; sÄ±nÄ±rÄ± aÅŸanÄ± experimental veya blockeda iter.

Rotasyon & Histerezis

rotation.periodMin dolmadan statÃ¼ deÄŸiÅŸtirme.

Terfi (experimentalâ†’allowed) yalnÄ±zca S â‰¥ promoteThreshold;
DÃ¼ÅŸÃ¼rme (allowedâ†’experimental/blocked) ancak S â‰¤ demoteThreshold ve hysteresisBps Ã¼stÃ¼nde fark varsa.

Deneysel/Canary SeÃ§imi

experimental.candidateTopK iÃ§inden seedâ€™e gÃ¶re deterministik canaryPercent seÃ§; statÃ¼ experimental.

holdMinPeriodMin dolmadan deneysel statÃ¼yÃ¼ bozma.

Manuel Komutlar

external.universe.command uygula (whitelist/blacklist/watch). *manual.Wins=true kurallarÄ± Ã¶ncelikli.

Snapshot & Diff

Yeni evreni oluÅŸtur, hashle.

hash != lastHash ise universe.diff ve universe.apply.directive yayÄ±nla:

allow_symbols: Throttler/Routerâ€™a.

block_symbols: QA/Throttler/Balancerâ€™a.

experimental_symbols: Banditâ€™e â€œdÃ¼ÅŸÃ¼k trafikâ€ etiketi.

Telemetri & Alarm

EÅŸik ihlallerinde universe.alert(warn|error).

10 snâ€™de bir universe.metrics.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/symbolUniverseManager.ts

src/vivo/state/universeStore.ts (catalog + metrics + penalties + lists + snapshot persist)

src/vivo/lib/score.ts (normalize & composite), src/vivo/lib/decay.ts, src/vivo/lib/hysteresis.ts, src/vivo/lib/quota.ts

__tests__/symbolUniverseManager.test.ts

Mimari

Saf Ã§ekirdek: recompute(state, cfg, now) â†’ {snapshot, diff, directives, alerts, metrics}

IO adaptÃ¶rÃ¼: bus subscribe/publish + timers (rotation schedule).

Validasyon

Zod; sayÄ±sal alanlar finite(); status alanlarÄ± enum; listeler set olarak tutulur.

Idempotency

AynÄ± hash â†’ tekrar yayÄ±n yok; external.universe.command iÃ§in eventId/hash ile yut.

Performans

N sembol iÃ§in O(N) skor; top-K seÃ§imleri iÃ§in O(N log K).

Test Ä°skeleti (Jest)

catalog.status!=TRADING â†’ blocked

liquidity below thresholds â†’ blocked

whitelist â†’ allowed (filters saÄŸsa); blacklist â†’ blocked

incident high/critical â†’ riskPenalty dÃ¼ÅŸÃ¼rÃ¼r; demoteThreshold altÄ±nda ise dÃ¼ÅŸer

promote/demote histerezis kurallarÄ±

quotas per cluster uygulanÄ±r

experimental canary deterministik (seed) ve holdMinPeriod korunur

stale data â†’ experimental/blocked

diff & apply.directive doÄŸru listeleri iÃ§erir

sentry.streams_panic â†’ yalnÄ±zca block yÃ¶nÃ¼nde deÄŸiÅŸim

Ã–rnek Senaryo (Ã–zet)

Girdi Ã–zetleri

exchange.symbols.catalog: { BTCUSDT, ETHUSDT, AVAXUSDT, NEWCOINUSDT } (hepsi TRADING)

market.liquidity.snapshot (60dk):

BTC: vol 150M, spread 4 bps, depth 20M, uptime 0.999

AVAX: vol 6.2M, spread 18 bps, depth 1.1M, uptime 0.985

NEWCOIN: vol 0.9M, spread 48 bps, depth 0.08M, uptime 0.94

vivo.performance.daily: AVAX M5 expectancy 0.18R, hit 0.53; NEWCOIN veri az (trades=3)

cost.forecast.update: AVAX funding risk elevated, BTC low

risk.incident.open: NEWCOIN execution_anomaly high (taze)

policy.snapshot: quotas maxAllowed=40, clusterCaps.Layer1=12

Beklenen Karar

BTC: allowed (core) â€” S â‰ˆ yÃ¼ksek

ETH: allowed

AVAX: allowed veya experimentalâ†’allowed (likidite sÄ±nÄ±rÄ± geÃ§ti, performans pozitif, funding elev. â†’ kÃ¼Ã§Ã¼k eksi)

NEWCOIN: blocked (likidite zayÄ±f + high incident)

universe.apply.directive:

allow_symbols: [BTCUSDT, ETHUSDT, AVAXUSDT]

block_symbols: [NEWCOINUSDT]

experimental_symbols: []

Entegrasyon NotlarÄ±

VIVO-18 Throttler / VIVO-16 Router: YalnÄ±zca allow_symbols listesindeki semboller iÃ§in niyet Ã¼ret; experimentalâ€™a dÃ¼ÅŸÃ¼k hacim limiti uygulanabilir.

VIVO-24 QA: blocked sembollerden gelen sinyalleri reject("symbol_blocked").

VIVO-25 Balancer: Cluster kotalarÄ± ve set_symbol_limitleri uygular.

VIVO-30 Bandit: experimental_symbols canary trafiÄŸi olarak kÄ±sÄ±tlÄ± daÄŸÄ±tÄ±lÄ±r.

VIVO-27 Sentry: streams_panic sÄ±rasÄ±nda evren daraltma yÃ¶nÃ¼nde sinyal verir, geri aÃ§mayÄ± bu modÃ¼l zamansal kurallara gÃ¶re yapar.
_________________________________________________________________________________________________________________
VIVO-32 Â· telemetryDashboardEmitter.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Sistemdeki tÃ¼m modÃ¼llerden gelen metrik, sayaÃ§, latency ve oran bilgilerini toplayÄ±p dashboard-friendly formatta yayÄ±nlamak:

Prometheus (pull, /metrics), TSDB satÄ±r-protokolÃ¼ (push; Influx/Quest/ClickHouse).

SLO/SLI tanÄ±mÄ± ve ihlal uyarÄ±larÄ± (error budget, p95/p99).

Servis/boru saÄŸlÄ±ÄŸÄ±: akÄ±ÅŸ gecikmesi, mesaj oranlarÄ±, hata oranlarÄ±, uptime.

Minimal overhead ve idempotent yayÄ±m: aggregator â†’ exporterâ€™lar.

Bu modÃ¼l sadece gÃ¶zlemler; karar vermez. UyarÄ± Ã¼retir, ama â€œguard/policyâ€yi deÄŸiÅŸtirmez.

Girdiler (Events / JSON ÅemalarÄ±)

AÅŸaÄŸÄ±daki olaylar diÄŸer VIVO modÃ¼llerinden gelmektedir (hepsi opsiyoneldir; geleni iÅŸler).

// QA, Guard, Sentry, Policy, Portfolio, Bandit, Universe, Cost, Logger vb. metrikleri
{ "event": "signal.qa.metrics", "timestamp": "iso8601",
  "p99_ms": 4.6, "pass_rate": 0.62, "reject_rate": 0.28, "defer_rate": 0.10, "dup_drop_rate": 0.02, "avg_quality": 0.61 }

{ "event": "latency_slip.guard.metrics", "timestamp": "iso8601",
  "ewma": {"placeMs": 740, "firstFillMs": 1120, "slipBps": 8.9, "spreadBps": 22.1},
  "modeRates": {"normal": 0.76, "slowdown": 0.18, "block_aggressive": 0.06, "halt_entry": 0.00},
  "panicCount": 1 }

{ "event": "sentry.metrics", "timestamp": "iso8601",
  "ewma": {"pingMs": 880, "wsMsgsPerSec": 94}, "gaps": {"count": 3, "avgGap": 74}, "reconnects": 2, "endpointSwitches": 1 }

{ "event": "policy.metrics", "timestamp": "iso8601",
  "applies": 4, "rollouts": 1, "rollbacks": 0, "conflictsResolved": 2, "canaryCoveragePct": 30 }

{ "event": "portfolio.balancer.metrics", "timestamp": "iso8601",
  "approved": 6, "adjusted": 3, "deferred": 1, "rejected": 2, "avg_scale": 0.81, "top_corr_pair": "ETHUSDT:AVAXUSDT" }

{ "event": "strategy.bandit.metrics", "timestamp": "iso8601",
  "exploreRate": 0.23, "blockedRate": 0.05, "avgSamplesPerArm": 41.3, "coldStartActive": false }

{ "event": "universe.metrics", "timestamp": "iso8601",
  "scores": {"avgLiquidity": 0.84, "avgPerf": 0.31, "avgCost": 0.67},
  "counts": {"allowed": 28, "experimental": 4, "blocked": 12},
  "rotation": {"lastAt": "iso8601", "added": 2, "removed": 1 } }

{ "event": "cost.forecaster.metrics", "timestamp": "iso8601",
  "avgAdviceMs": 2.1, "adviceRates": {"info": 0.55, "warn": 0.30, "block": 0.15},
  "makerUsageSuggestRate": 0.62, "fundingWindowAvoidRate": 0.21 }

{ "event": "vivo.logger.metrics", "timestamp": "iso8601",
  "p99_ingest_ms": 3.2, "rows_appended": 142, "summaries_published": 11, "anomalies": 1 }

{ "event": "risk.incident.alert", "timestamp": "iso8601",
  "level": "warn|error", "message": "string", "context": {"type": "series_loss"} }

// Her modÃ¼l kendi *.metrics olayÄ±nÄ± benzer yapÄ±da yollar; emitter hepsini haritalar.


AyrÄ±ca sistem kalp atÄ±ÅŸÄ±:

{ "event": "connectivity.heartbeat", "timestamp":"iso8601",
  "latencyMs": 910, "marketStreamAlive": true, "orderStreamAlive": true, "wsEndpoint": "primary", "clockSkewMs": 1200 }

Ã‡Ä±ktÄ±lar (Exporter veri & UyarÄ±lar)
// Prometheus exporter anlÄ±k dump'Ä± (pull modeli iÃ§in memory snapshot)
{
  "event": "telemetry.prom.dump",
  "timestamp": "iso8601",
  "contentType": "text/plain; version=0.0.4",
  "body": "vivo_qa_pass_rate 0.62\nvivo_qa_p99_ms 4.6\nvivo_guard_slip_ewma_bps 8.9\n..."
}

// TSDB push paketi (line protocol / JSON batch)
{
  "event": "telemetry.tsdb.batch",
  "timestamp": "iso8601",
  "lines": [
    "vivo_guard,scope=global slip_ewma_bps=8.9,place_ewma_ms=740i 1693552800000000000",
    "vivo_sentry endpoint_switches=1i,reconnects=2i,ping_ms=880i 1693552800000000000"
  ],
  "target": "primary|secondary"
}

// SLO deÄŸerlendirmesi ve uyarÄ±
{
  "event": "telemetry.slo.status",
  "timestamp": "iso8601",
  "service": "qa|sentry|guard|bandit|balancer|policy|universe|cost|logger",
  "slo": "availability|latency_p99|decision_success_rate",
  "window": "1h|24h|7d",
  "target": "number",
  "sli": "number",
  "status": "ok|breach|at_risk",
  "errorBudgetUsedPct": "number"
}

{
  "event": "telemetry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"service":"string","slo":"string","reasonCodes":["string"]}
}

// SaÄŸlÄ±k nabzÄ± (self)
{
  "event": "telemetry.emitter.heartbeat",
  "timestamp": "iso8601",
  "p95_emit_ms": "number",
  "exporterQueueDepth": "number",
  "scrapeCount": "number"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: QaMetrics, GuardMetrics, SentryMetrics, PolicyMetrics, PortfolioBalancerMetrics, BanditMetrics, UniverseMetrics, CostForecasterMetrics, LoggerMetrics, ConnectivityHeartbeat, IncidentAlert.

Outputs: PromDump, TsdbBatch, SloStatus, TelemetryAlert, EmitterHeartbeat.

Helpers: MetricRegistry, Counter, Gauge, Histogram, Summary, QuantileEstimator (CKMS/TDigest), SloTracker, LabelSet, ExporterQueue.

Zod: tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸta runtime validasyon; finite/NaN/âˆ reddet.

Event Bus KonularÄ±

In: *.metrics, connectivity.heartbeat, risk.incident.alert

Out: telemetry.prom.dump, telemetry.tsdb.batch, telemetry.slo.status, telemetry.alert, telemetry.emitter.heartbeat

Konfig & VarsayÄ±lanlar
{
  // Prometheus exporter
  prom: {
    enabled: true,
    httpPort: 9108,
    path: "/metrics",
    histogramBucketsMs: [1, 2, 5, 10, 25, 50, 100, 250, 500, 1000, 2000],
    slipBucketsBps: [1, 2, 4, 6, 8, 10, 12, 15, 20, 30]
  },

  // TSDB push
  tsdb: {
    enabled: true,
    protocol: "line",              // "line" | "json"
    endpointPrimary: "http://tsdb:8086/write",
    endpointSecondary: "http://tsdb-b:8086/write",
    batchMaxSize: 1000,
    batchMaxWaitMs: 1000,
    retryBackoffMs: [250, 500, 1000, 2000]
  },

  // SLO tanÄ±mlarÄ± (hedef ve pencere)
  slo: {
    qa: { availability: { target: 0.995, window: "24h" }, latency_p99: { targetMs: 8, window: "1h" } },
    sentry: { availability: { target: 0.995, window: "24h" }, latency_p99: { targetMs: 1500, window: "1h" } },
    guard: { decision_success_rate: { target: 0.98, window: "24h" } },
    bandit: { decision_latency_p99: { targetMs: 3, window: "1h" } },
    balancer: { approve_or_adjust_rate: { target: 0.8, window: "24h" } },
    policy: { apply_success_rate: { target: 0.99, window: "24h" } }
  },

  // Ã–rnekleme / downsample
  sampling: { metricsEveryNth: 1, heavySeriesEveryNth: 3 },

  // Etiketler
  labels: { env: "prod", service: "vivo", instance: "vivo32-01" },

  // Telemetri
  metricsFlushSec: 10,
  emitterHeartbeatSec: 30,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

MetricRegistry:

Counters/Gauges: isim + LabelSet (Ã¶r. symbol, variant, service).

Histograms/Summaries: CKMS/TDigest ile p90/p95/p99; bucket counters.

SloTracker (serviceÃ—sloKey):

SLI zaman pencereleri: halka arabellek (1m dilimler); error budget hesap.

ExporterQueue:

Prom dump memory snapshot (idempotent), TSDB batch kuyruÄŸu (retry/backoff).

Persist (opsiyonel): data/telemetry.state.json (yalnÄ±zca SLO pencereleri); crash sonrasÄ± devam.

SLI TanÄ±mlarÄ± (Ã¶rnekler)

QA availability = pass + defer > 0 ? pass / (pass + reject + defer) : 1.0

QA latency_p99 = p99_ms (signal QA dÃ¶ngÃ¼sÃ¼).

Sentry availability = marketStreamAlive && orderStreamAlive dakika baÅŸÄ±na oran.

Guard decision_success_rate = directive_published / directive_attempted.

Bandit decision_latency_p99 = seÃ§im dÃ¶ngÃ¼sÃ¼ p99 (ms).

Balancer approve_or_adjust_rate = (approved + adjusted) / (approved + adjusted + rejected + deferred).

Policy apply_success_rate = applies_success / applies_total (apply Ã§Ä±ktÄ±sÄ± olan modÃ¼ller raporlar).

Exchange connectivity (opsiyonel SLI): heartbeat within timeout oranÄ±.

Algoritma (AkÄ±ÅŸ)

Ingest & Map

Gelen *.metrics olayÄ±nÄ± Zodâ€™la doÄŸrula â†’ MetricRegistryâ€™de ilgili serilere haritala:

Ã–rn: signal.qa.metrics.pass_rate â†’ gauge vivo_qa_pass_rate{tf="*",source="all"}.

p99_ms â†’ histogram/summary gÃ¼ncelle.

modeRates.* â†’ Ã§ok-etiketli gauge (mode).

connectivity.heartbeat â†’ sentry_availability SLI pencere gÃ¼ncelle.

SLO Hesapla

Her metricsFlushSec â†’ SLI pencerelerini hesapla, hedefle karÅŸÄ±laÅŸtÄ±r:

status = ok|at_risk|breach â†’ telemetry.slo.status yayÄ±nla.

breach durumunda telemetry.alert(level="error").

Exporters

Prometheus: Bellekteki MetricRegistry â†’ /metrics dump (pull).

TSDB: Son metricsFlushSecâ€™te deÄŸiÅŸen Ã¶lÃ§Ã¼mler â†’ telemetry.tsdb.batch (push, retry/backoff).

Sampling & Downsample

sampling.heavySeriesEveryNth ile yÃ¼ksek hacimli serilerde (Ã¶r. per-symbol histograms) downsample uygula.

Labeling & Idempotency

Global labels her seriye eklenir. AynÄ± zaman diliminde aynÄ± seri iki kez gÃ¶nderilmez (hash/kadran anahtarÄ±).

Alarm KurallarÄ±

Pik deÄŸerler: guard.slip_ewma_bps â‰¥ slipPanicBps veya sentry.ping_ms p99 > target â†’ warn/error.

Error budget burn: 1h pencerede >20% tÃ¼ketim â†’ at_risk uyarÄ±sÄ±.

Self Heartbeat

Her emitterHeartbeatSec â†’ telemetry.emitter.heartbeat (p95 emit ms, queue depth, scrape count).

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/telemetryDashboardEmitter.ts

src/vivo/state/metricsRegistry.ts, src/vivo/lib/ckms.ts (veya t-digest), src/vivo/lib/lineProtocol.ts, src/vivo/lib/slo.ts

__tests__/telemetryDashboardEmitter.test.ts

Mimari

Saf Ã§ekirdek: ingest(event) â†’ updates[], tick(now) â†’ {promDump?, tsdbBatch?, sloStatuses[], alerts[]}

IO adaptÃ¶rÃ¼: HTTP server (Prom dump), TSDB HTTP client, bus publish/subscribe.

Validasyon

Zod; Ã¶lÃ§Ã¼mler finite(). Negatif ms/bps â†’ discard + telemetry.alert(warn,"invalid_metric").

Performans

p99 ingest < 2ms; dump < 20ms; batch push < 50ms hedef. GC baskÄ±sÄ±nÄ± azaltmak iÃ§in object pool veya reused buffers.

GÃ¼venlik

/metrics endpointâ€™ini opsiyonel basic auth / allowlist ile koru (config).

Test Ä°skeleti (Jest)

qa.metrics ingest â†’ prom/gauges & histograms doÄŸru dolar.

slo: qa.availability 0.994 < 0.995 â†’ breach + telemetry.alert(error).

sentry heartbeat false â†’ availability SLI dÃ¼ÅŸer.

tsdb.batch boyut/timeout â†’ retryBackoff uygular.

sampling heavySeriesEveryNth â†’ seri sayÄ±sÄ± azalÄ±r.

idempotent dump â†’ aynÄ± snapshot tekrarÄ± yok.

invalid metric â†’ alert(warn) ve seri gÃ¼ncellenmez.

Ã–rnek Senaryo (Ã–zet)

Durum

10 snâ€™de bir qa.metrics, guard.metrics, sentry.metrics, bandit.metrics akÄ±yor.

Son 1 saatte qa.p99_ms hedef 8ms, gÃ¶zlem ~9.1ms; pass_rate 0.61.

3 reconnect ve bir endpoint switch yaÅŸanmÄ±ÅŸ.

Beklenen YayÄ±nlar

/metrics dumpâ€™Ä±nda:

vivo_qa_pass_rate 0.61, vivo_qa_p99_ms 9.1, vivo_guard_mode_rate{mode="slowdown"} 0.18, vivo_sentry_endpoint_switches_total 1 â€¦

telemetry.slo.status(qa.latency_p99) â†’ breach, errorBudgetUsedPct â‰ˆ 35%

telemetry.alert(error,"qa_latency_p99_breach")

telemetry.tsdb.batch push: line-proto ile yukarÄ±daki metrikler (env/service/instance labelâ€™larÄ± ile).

Entegrasyon NotlarÄ±

Ops/Dev dashboardâ€™larÄ± (Grafana/Kibana) bu modÃ¼lÃ¼n Prom/TSDB Ã§Ä±ktÄ±sÄ±nÄ± veri kaynaÄŸÄ± yapar.

VIVO-27/26 ihlallerinde emitter sadece uyarÄ± Ã¼retir; guard/policyâ€™ye mÃ¼dahale etmez.

SLOâ€™lar haftalÄ±k rapor ve Denetim AsistanÄ± iÃ§in telemetry.slo.status akÄ±ÅŸÄ±ndan alÄ±nÄ±r.
_________________________________________________________________________________________________________________
VIVO-33 Â· incidentNotificationBridge.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Risk olaylarÄ± ve kritik telemetri/SLO ihlallerini Telegram/Discord/Email/Webhook gibi kanallara akÄ±llÄ± ÅŸekilde kÃ¶prÃ¼lemek:

Sessiz saat (quiet hours) ve soaking (X sn bekle, benzerleri tek mesajda topla),

Dedupe (aynÄ± incident tekrarlarÄ±nÄ± bastÄ±r), oran sÄ±nÄ±rlama (rate-limit),

Eskalasyon (on-call rotasÄ±), ACK/Resolve geri akÄ±ÅŸÄ±,

Åablonlama (platforma uygun Markdown/format), yerelleÅŸtirme (TR/EN),

GÃ¼venlik (imza, webhook secret), audit (kim, ne zaman, nereye gÃ¶nderildi).

Bu modÃ¼l sadece bildirim kÃ¶prÃ¼ler; risk/policy kararÄ±nÄ± deÄŸiÅŸtirmez.

Girdiler (Event / JSON ÅemalarÄ±)
// Kritik sinyaller (birincil)
{
  "event": "risk.incident.open|risk.incident.update|risk.incident.closed",
  "timestamp": "iso8601",
  "incidentId": "string",
  "type": "series_loss|drawdown_breach|exposure_breach|execution_anomaly|data_staleness|emergency_halt|limit_breach|...",
  "severity": "low|medium|high|critical",
  "scope": {"symbol":"string|null","timeframe":"string|null","variant":"string|null"},
  "openReasonCodes": ["string"],
  "metrics": {"totalRiskPctOpen":"number|null","ddFromPeakR":"number|null","slipBps":"number|null"},
  "notes": "string|null"
}

{
  "event": "telemetry.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"service":"string","slo":"string|null","reasonCodes":["string"],"symbol":"string|null"}
}

{
  "event": "telemetry.slo.status",
  "timestamp": "iso8601",
  "service": "qa|sentry|guard|bandit|balancer|policy|universe|cost|logger",
  "slo": "availability|latency_p99|decision_success_rate|...",
  "window": "1h|24h|7d",
  "target": "number",
  "sli": "number",
  "status": "ok|breach|at_risk",
  "errorBudgetUsedPct": "number"
}

// On-call & kanal haritasÄ±
{
  "event": "oncall.roster",
  "timestamp": "iso8601",
  "rotation": [
    {"team":"core","primary":{"name":"string","contact":{"telegramUserId":"number","email":"string"}},"secondary":{"name":"string","contact":{"telegramUserId":"number","email":"string"}},"since":"iso8601"}
  ]
}

{
  "event": "bridge.channel.map",
  "timestamp": "iso8601",
  "routes": [
    {"match":{"event":"risk.incident.*","severity":">=high"},"channels":["telegram:ops","discord:#incidents","email:oncall@acme.io"]},
    {"match":{"service":"sentry","status":"streams_panic"},"channels":["telegram:ops"],"rateLimitPerMin":2}
  ]
}

// KullanÄ±cÄ±/ekip tercihleri
{
  "event": "bridge.prefs",
  "timestamp": "iso8601",
  "locale": "tr|en",
  "quietHours": {"start":"HH:mm","end":"HH:mm","timezone":"Europe/Istanbul"},
  "mute": {"symbols":["string"],"incidentTypes":["string"]},
  "digest": {"enabled": true, "periodMin": 15}
}

// Geri akÄ±ÅŸ (kanallardan ACK/resolve komutu, webhook/bot ile)
{
  "event": "bridge.inbound.command",
  "timestamp": "iso8601",
  "channel": "telegram|discord|email|webhook",
  "userId": "string",
  "cmd": "ack|resolve|note",
  "incidentId": "string",
  "note": "string|null",
  "signature": "hex"
}

Ã‡Ä±ktÄ±lar (KÃ¶prÃ¼ MesajlarÄ± & AkÄ±ÅŸ)
// Platformdan baÄŸÄ±msÄ±z Ã§Ä±kÄ±ÅŸ (iÃ§ katman)
{
  "event": "bridge.notification.outgoing",
  "timestamp": "iso8601",
  "dedupeKey": "string",
  "channels": ["telegram:ops","discord:#incidents","email:oncall@acme.io","webhook:https://..."],
  "title": "string",
  "body": "markdown",
  "severity": "low|medium|high|critical",
  "threadKey": "string",                  // incidentId veya sloKey
  "actions": [{"type":"ack","incidentId":"string"},{"type":"resolve","incidentId":"string"}],
  "context": {"incidentId":"string|null","service":"string|null","symbol":"string|null"},
  "ttlSec": 900
}

// Kanal Ã¶zgÃ¼l â€œsendâ€ olaylarÄ± (adaptÃ¶rler dinler ve gÃ¶nderir)
{
  "event": "bridge.telegram.send",
  "timestamp": "iso8601",
  "chat": "ops|dev|customId",
  "threadKey": "string",
  "text": "markdown",
  "buttons": [{"text":"ACK","callback":"ack:INC-123"},{"text":"RESOLVE","callback":"resolve:INC-123"}]
}

{
  "event": "bridge.discord.send",
  "timestamp": "iso8601",
  "channel": "#incidents",
  "threadKey": "string",
  "embed": {
    "title":"string","description":"markdown",
    "color":"int","fields":[{"name":"Symbol","value":"AVAXUSDT","inline":true}]
  },
  "components": [{"type":"buttons","items":[{"label":"ACK","customId":"ack:INC-123"}]}]
}

{
  "event": "bridge.email.send",
  "timestamp": "iso8601",
  "to": ["oncall@acme.io"],
  "subject": "[HIGH] exposure_breach AVAXUSDT",
  "html": "<p>â€¦</p>",
  "threadKey": "string",
  "headers": {"Message-Id":"<...>","In-Reply-To":"<...>"}
}

{
  "event": "bridge.webhook.send",
  "timestamp": "iso8601",
  "url": "https://hooks.example/xyz",
  "method": "POST",
  "headers": {"X-Signature":"hex"},
  "json": {"title":"â€¦","severity":"high","incidentId":"INC-123","link":"https://â€¦"}
}

// ACK/Resolve dÄ±ÅŸa yansÄ±ma (iÃ§ sisteme geri)
{
  "event": "incident.acknowledged",
  "timestamp": "iso8601",
  "incidentId": "string",
  "by": {"userId":"string","channel":"telegram|discord|email|webhook"},
  "note": "string|null"
}

{
  "event": "incident.resolved.external",
  "timestamp": "iso8601",
  "incidentId": "string",
  "by": {"userId":"string","channel":"telegram|discord|email|webhook"},
  "note": "string|null"
}

// Telemetri & uyarÄ±
{
  "event": "bridge.metrics",
  "timestamp": "iso8601",
  "sent": {"telegram": "number","discord":"number","email":"number","webhook":"number"},
  "suppressed": {"quiet":"number","dedupe":"number","rate":"number"},
  "ackMedianSec": "number",
  "errorRate": "number"
}
{
  "event": "bridge.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"reasonCodes":["string"],"channel":"string|null"}
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: RiskIncidentEvent, TelemetryAlert, SloStatus, OncallRoster, BridgeChannelMap, BridgePrefs, InboundCommand.

Outputs: BridgeNotificationOutgoing, BridgeTelegramSend, BridgeDiscordSend, BridgeEmailSend, BridgeWebhookSend, IncidentAcknowledged, IncidentResolvedExternal, BridgeMetrics, BridgeAlert.

Helpers: TemplateEngine (Markdown/HTML), RateLimiter, DedupeCache, SoakBuffer, QuietHours, EscalationPlan, Signer (HMAC), ThreadIndex, LocaleDict.

Zod: tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon.

Event Bus KonularÄ±

In: risk.incident.*, telemetry.alert, telemetry.slo.status, oncall.roster, bridge.channel.map, bridge.prefs, bridge.inbound.command

Out: bridge.notification.outgoing, bridge.*.send, incident.acknowledged, incident.resolved.external, bridge.metrics, bridge.alert

Konfig & VarsayÄ±lanlar
{
  // Sessiz saat ve soaking
  quietHours: { start: "23:30", end: "07:30", timezone: "Europe/Istanbul" },
  soak: { windowSec: 60, maxBatch: 5 },                // benzer olaylarÄ± 60 sn topla

  // Dedupe & rate-limit
  dedupe: { windowSec: 300 },                          // aynÄ± dedupeKey'i bastÄ±r
  rate: { telegramPerMin: 8, discordPerMin: 8, emailPerMin: 20, webhookPerMin: 30 },

  // Eskalasyon
  escalation: {
    stages: [
      { afterSec: 300, channels: ["telegram:ops"], target: "primary" },
      { afterSec: 900, channels: ["telegram:ops","email:oncall@acme.io"], target: "secondary" }
    ],
    requireAckSeverities: ["high","critical"]
  },

  // Åablonlar
  templates: {
    title: "[${severity}] ${type} ${symbol ?? ''}",
    bodyTR: "Olay: **${type}**\nÅiddet: **${severity}**\nSembol: ${symbol ?? '-'}\nNot: ${notes ?? '-'}\nMetrikler: ${metricsStr}",
    bodyEN: "Incident: **${type}**\nSeverity: **${severity}**\nSymbol: ${symbol ?? '-'}\nNotes: ${notes ?? '-'}\nMetrics: ${metricsStr}"
  },

  // GÃ¼venlik
  secrets: { webhookHmacKey: "env:BRIDGE_HMAC", emailFrom: "vivo@acme.io" },

  // Haritalama (renk/kod)
  severityColors: { low: 0x2e7d32, medium: 0xf9a825, high: 0xef6c00, critical: 0xc62828 },

  // Lokalizasyon varsayÄ±lanÄ±
  defaultLocale: "tr",

  // Telemetri
  metricsFlushSec: 10,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

BridgeState (in-memory + periyodik persist data/bridge.state.json):

prefs, routes, oncallRoster, quietRangeToday, dedupeIndex (keyâ†’expiresAt),

soakBuffer (threadKeyâ†’[events]), threadIndex (incidentId|sloKeyâ†’threadKey),

acks (incidentIdâ†’{ackAt, by}), pendingEscalations zamanlayÄ±cÄ±larÄ±,

Kanal baÅŸÄ±na rateLimiter sayaÃ§larÄ±.

Idempotency: dedupeKey (eventType + incidentId/sloKey + severity + roundedMinute) ile tekrarlarÄ± yut.

Åablonlama & Dedupe AnahtarlarÄ±

threadKey = incidentId ?? "${service}:${slo}:${window}".

dedupeKey = threadKey + ":" + severity + ":" + floor(now, 1m).

metricsStr yardÄ±mcÄ± fonksiyon: {totalRiskPctOpen:1.8, slipBps:17} â†’ "risk=1.8%, slip=17bps".

Algoritma (Karar AkÄ±ÅŸÄ±)

Normalize & Filtrele

Zod validasyon; prefs.mute eÅŸleÅŸirse drop (telemetriye suppressed yaz).

routes ile eÅŸleÅŸen kanal setini Ã§Ä±kar; yoksa varsayÄ±lan kanal(lar).

Quiet Hours & Soaking

Quiet aralÄ±ÄŸÄ±ndaysa olay soakBufferâ€™a eklenir; pencere sonunda tek batched mesaj oluÅŸturulur (Ã¶zet listesi).

Quiet dÄ±ÅŸÄ±ndaysa soak.windowSec kÄ±sa bekleme ile benzerleri toplayÄ±p gÃ¶nder.

Dedupe & Rate-Limit

dedupeKey aktifse suppress; deÄŸilse insert.

Kanal baÅŸÄ±na oran sÄ±nÄ±rÄ± aÅŸÄ±lÄ±rsa ilgili kanala suppress + bridge.alert(warn,"rate_limited").

Eskalasyon

severity âˆˆ requireAckSeverities ve ack yoksa:

Stage-1 zamanlayÄ±cÄ±: afterSec dolunca hÃ¢lÃ¢ ack yoksa ek kanallara gÃ¶nder.

Stage-2 â€¦ (Ã§oklu aÅŸama destekli).

ACK geldiÄŸinde tÃ¼m bekleyen eskalasyonlar iptal.

Åablonlama & Lokalizasyon

locale = prefs.locale || defaultLocale. TemplateEngine ile baÅŸlÄ±k/gÃ¶vde Ã¼ret (TR/EN).

Platform Ã¶zelindeki Markdown/HTML farklarÄ±nÄ± uygula (Telegram vs Discord).

GÃ¶nderimler

bridge.notification.outgoing â†’ adaptÃ¶rler bridge.telegram.send|discord.send|email.send|webhook.send Ã¼retir.

Webhook iÃ§in Signer(HMAC) ile X-Signature.

Inbound Komutlar (ACK/Resolve/Note)

bridge.inbound.command imzasÄ±nÄ± doÄŸrula (gerekiyorsa).

incident.acknowledged veya incident.resolved.external yayÄ±nla.

Ä°lgili threadâ€™e ACK/RESOLVED gÃ¼ncellemesi gÃ¶nder (kanallara kÃ¼Ã§Ã¼k edit mesajÄ±).

Telemetri

bridge.metrics her 10 sn: gÃ¶nderilen/suppressed/ackMedianSec vb.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/incidentNotificationBridge.ts

src/vivo/state/bridgeStore.ts (prefs/routes/roster/soak/dedupe/rate persist)

src/vivo/lib/template.ts, src/vivo/lib/quiet.ts, src/vivo/lib/ratelimit.ts, src/vivo/lib/hmac.ts

Kanal adaptÃ¶rleri: src/vivo/adapters/telegram.ts, discord.ts, email.ts, webhook.ts

__tests__/incidentNotificationBridge.test.ts

Mimari

Ã‡ekirdek: ingest(event, state, cfg) â†’ emissions[]

AdaptÃ¶rler: â€œsendâ€ olaylarÄ±nÄ± gerÃ§ek kanala Ã§evirir (burada sadece arayÃ¼z; secrets/env kullanÄ±lacak).

Validasyon

Zod; ÅŸiddet map: risk.severity â†’ bridge.severity.

GÃ¼venlik

Webhook imzalama, inbound komutlarda imza/doÄŸrulama opsiyonu.

Performans

p99 < 5ms; soak batch iÅŸlemi zamanlayÄ±cÄ±yla.

Test Ä°skeleti (Jest)

risk.incident.open(high) â†’ telegram+discord gÃ¶nderildi, email yoksa config gereÄŸi

quiet hours â†’ soak ile tek batched mesaj

dedupe window â†’ ikinci aynÄ± olay suppressed

rate limit aÅŸÄ±ldÄ± â†’ suppressed + bridge.alert(warn)

ACK gelmedi â†’ 5 dk sonra Stage-2 eskalasyon email

inbound ack â†’ incident.acknowledged yayÄ±nlandÄ±; eskalasyonlar iptal

webhook signature doÄŸrulamasÄ±

locale=tr â†’ gÃ¶vde TR / locale=en â†’ EN

threadKey tutarlÄ±lÄ±ÄŸÄ± (incidentId bazlÄ±)

Ã–rnek Senaryo (Ã–zet)

Durum

00:05 (quiet hours iÃ§inde). risk.incident.open(severity=high, type="exposure_breach", symbol="AVAXUSDT", incidentId="INC-884")

00:05:30 risk.incident.update(severity=high, slipBps=19)

00:06:10 soaking penceresi biter, ACK yok.

Beklenen YayÄ±nlar

{
  "event":"bridge.notification.outgoing",
  "channels":["telegram:ops","discord:#incidents"],
  "title":"[high] exposure_breach AVAXUSDT",
  "body":"Olay: **exposure_breach**\nÅiddet: **high**\nSembol: AVAXUSDT\nMetrikler: risk=1.9%, slip=19bps\nÃ–zet: 2 gÃ¼ncelleme soÄŸuruldu.",
  "severity":"high",
  "threadKey":"INC-884",
  "actions":[{"type":"ack","incidentId":"INC-884"},{"type":"resolve","incidentId":"INC-884"}],
  "ttlSec":900
}


ACK gelmezse 5. dakikada:

{"event":"bridge.email.send","to":["oncall@acme.io"],"subject":"[HIGH] exposure_breach AVAXUSDT","threadKey":"INC-884","html":"<p>â€¦</p>"}


Telegramâ€™dan operatÃ¶r ACK tuÅŸuna basar:

{"event":"incident.acknowledged","incidentId":"INC-884","by":{"userId":"@opslead","channel":"telegram"}}


Eskalasyon zamanlayÄ±cÄ±larÄ± iptal edilir; kanallara kÃ¼Ã§Ã¼k â€œACKed by @opsleadâ€ gÃ¼ncellemesi dÃ¼ÅŸer.

Entegrasyon NotlarÄ±

VIVO-23: risk.incident.* olaylarÄ±nÄ±n incidentIdâ€™si kÃ¶prÃ¼de threadKeyâ€™dir.

VIVO-27/32: telemetry.alert|slo.status kritik olanlarÄ± kÃ¶prÃ¼lenir; dÃ¼ÅŸÃ¼k Ã¶nemdekiler yalnÄ±zca dashboardâ€™da kalabilir (route/prefs ile).

Geri akÄ±ÅŸ: incident.acknowledged|resolved.external sinyallerini Denetim AsistanÄ± ve Policy raporlama iÃ§in dinleyebilir.

Gizlilik: E-posta/Discordâ€™a PII koyma; linkleri imzalÄ± panel URLâ€™siyle ver.
_________________________________________________________________________________________________________________
VIVO-34 Â· backtestReplayHarness.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

TarihÃ® verileri gerÃ§ek zamanlÄ± akÄ±ÅŸ gibi event busâ€™a enjekte ederek tÃ¼m VIVO zincirini uÃ§tan uca test etmek:

HÄ±z kontrolÃ¼ (1Ã—/2Ã—/5Ã—/bar-close), duraklat/baÅŸlat/geri-sar/ileri-sar/seek,

Hata/fault enjeksiyonu (jitter, kayÄ±p paket, tekrar/Ã§ift, yeniden sÄ±ralama, kesinti),

Deterministik yÃ¼rÃ¼tme (seed), yerel saat (Europe/Istanbul) emÃ¼lasyonu,

Oracle/Ground-Truth karÅŸÄ±laÅŸtÄ±rmasÄ± (gerÃ§ek sonuÃ§larla kÄ±yas; PnL/hit/slip farklarÄ±),

Ã–lÃ§Ã¼m & raporlama (throughput, gecikme, drop/reorder sayÄ±larÄ±, deÄŸerlendirme metrikleri).

GerÃ§ek borsaya baÄŸlanmadan, tÃ¼m modÃ¼lleri canlÄ± koÅŸuyormuÅŸ gibi sÃ¼rmek.

Bu modÃ¼l sadece veri akÄ±tÄ±r ve Ã¶lÃ§er; risk/policy/karar mantÄ±ÄŸÄ±na mÃ¼dahale etmez.

Girdiler (Event / JSON ÅemalarÄ±)
// replay.manifest â€” dataset ve akÄ±ÅŸ haritasÄ±
{
  "event": "replay.manifest",
  "timestamp": "iso8601",
  "datasetId": "string",
  "tz": "Europe/Istanbul",
  "range": { "start": "iso8601", "end": "iso8601" },
  "sources": [
    {
      "type": "jsonl|csv|parquet",
      "path": "file:///data/bars_M5.jsonl",
      "topic": "market.bar",                 // konu adÄ± (aÅŸaÄŸÄ±daki "out map" ile canlÄ± olaya dÃ¶nÃ¼ÅŸecek)
      "timeField": "ts",                     // epochMs | iso
      "symbolField": "symbol",
      "schemaHint": "bar_M5_v1"
    },
    {
      "type": "jsonl",
      "path": "file:///data/aggTrades.jsonl",
      "topic": "market.aggTrade",
      "timeField": "ts",
      "symbolField": "symbol",
      "schemaHint": "agg_v1"
    },
    {
      "type": "jsonl",
      "path": "file:///data/funding_8h.jsonl",
      "topic": "funding.snapshot",
      "timeField": "timestamp",
      "symbolField": "symbol",
      "schemaHint": "funding_v1"
    }
  ],
  "outMap": [
    { "from":"market.bar", "to":"market.refs" },      // bar â†’ refs (mid/spread tÃ¼retilebilir)
    { "from":"market.aggTrade", "to":"market.trade.tick" },
    { "from":"funding.snapshot", "to":"funding.snapshot" }
  ],
  "groundTruth": {
    "trades": { "type":"jsonl","path":"file:///data/oracle_trades.jsonl","idField":"tradeId" },
    "pnl":    { "type":"jsonl","path":"file:///data/oracle_pnl.jsonl","key":["tradeId"] }
  },
  "clock": { "mode":"wall|bar_close", "tickMs": 200 },  // wall: duvar saatiyle akar, bar_close: bar kapanÄ±ÅŸlarÄ±nda ilerler
  "seed": "vivo34-replay"
}

// replay.control â€” kontrol komutlarÄ±
{
  "event": "replay.control",
  "timestamp": "iso8601",
  "cmd": "load|start|pause|resume|stop|seek|speed|bookmark|restore|shutdown",
  "args": {
    "datasetId": "string|null",
    "speed": "0.25|0.5|1|2|5|10|bar",     // bar = bar_close adÄ±mÄ±
    "seekTo": "iso8601|null",
    "filters": { "symbols": ["AVAXUSDT","BTCUSDT"], "timeframes": ["M1","M5"], "topics": ["market.*","funding.snapshot"] },
    "bookmarkId": "string|null"
  }
}

// replay.faults â€” hata/fault enjeksiyonu
{
  "event": "replay.faults",
  "timestamp": "iso8601",
  "dropProb": 0.00,          // 0..1
  "dupProb": 0.00,
  "reorderProb": 0.00,
  "reorderJitterMs": 150,    // yeniden sÄ±ralama iÃ§in rastgele gecikme
  "latencyJitterMs": 50,     // yayÄ±n Ã¶ncesi jitter
  "outages": [               // akÄ±ÅŸ kesintisi pencereleri
    { "start":"iso8601","end":"iso8601","topics":["market.*"] }
  ]
}

// replay.mapping.override â€” alan/dÃ¶nÃ¼ÅŸÃ¼m override (opsiyonel)
{
  "event": "replay.mapping.override",
  "timestamp": "iso8601",
  "map": {
    "market.bar â†’ market.refs": { "mid":"(o+h+l+c)/4", "spreadBps":"derived_by_model" }
  }
}


Not: Bu modÃ¼l, diÄŸer modÃ¼llerin zaten tanÄ±mlÄ± olay ÅŸemalarÄ±nÄ± yeniden kullanÄ±r: market.refs, funding.snapshot, connectivity.heartbeat, vb.

Ã‡Ä±ktÄ±lar (AkÄ±ÅŸ, Durum, Ã–lÃ§Ã¼m, DeÄŸerlendirme)
// AkÄ±tÄ±lan canlÄ± olaylar (Ã¶rnek)
{ "event":"market.refs", "timestamp":"iso8601", "symbol":"AVAXUSDT", "mid":12.34, "bestBid":12.33, "bestAsk":12.35, "spreadBps":8.1, "volZScore":1.2 }

{ "event":"funding.snapshot", "timestamp":"iso8601", "symbol":"AVAXUSDT", "period":"8h", "lastFundingRateBp":32, "nextFundingTime":"iso8601", "predictedNextRateBp":35 }

// Yapay kalp atÄ±ÅŸÄ± (canlÄ± saat emÃ¼lasyonu)
{ "event":"replay.clock.tick", "timestamp":"iso8601", "now":"iso8601", "lagMs":"number" }

// Ä°lerleme ve durum
{
  "event": "replay.status",
  "timestamp": "iso8601",
  "state": "idle|loaded|running|paused|stopped",
  "datasetId": "string|null",
  "speed": "number|string",
  "progress": { "cursor":"iso8601","start":"iso8601","end":"iso8601","pct":"number" },
  "filters": {"symbols":["string"],"topics":["string"]},
  "faultsActive": true
}

// Ã–lÃ§Ã¼mler
{
  "event": "replay.metrics",
  "timestamp": "iso8601",
  "eventsOutPerSec": "number",
  "avgLagMs": "number",
  "drops": "number",
  "dups": "number",
  "reorders": "number",
  "outageWindows": "number",
  "bufferFillPct": "number"
}

// Yer imleri (bookmark) & restore
{
  "event": "replay.bookmark.saved",
  "timestamp": "iso8601",
  "bookmarkId": "string",
  "cursor": "iso8601",
  "seed": "string",
  "filters": {"symbols":["string"],"topics":["string"]}
}

// UyarÄ±/Alarm
{
  "event": "replay.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"datasetId":"string","reasonCodes":["string"]}
}

// DeÄŸerlendirme: ground-truth kÄ±yas
{
  "event": "replay.eval.sample",
  "timestamp": "iso8601",
  "tradeId": "string",
  "symbol": "string",
  "expected": {"hit":0|1,"r":"number","slipBps":"number"},
  "observed": {"hit":0|1,"r":"number","slipBps":"number"},
  "deltas": {"hit":"-1|0|+1","r":"number","slipBps":"number"},
  "reasonCodes": ["match|miss|slip_diff|rr_diff"]
}

{
  "event": "replay.eval.report",
  "timestamp": "iso8601",
  "datasetId": "string",
  "summary": {
    "samples": "number",
    "hitAcc": "number",
    "rMse": "number",
    "slipMse": "number",
    "winRateExp": {"expected":"number","observed":"number"},
    "profitFactor": {"expected":"number","observed":"number"}
  },
  "bySymbol": [{"symbol":"string","samples":"number","deltaWinRate":"number","deltaPF":"number"}]
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: ReplayManifest, ReplayControl, ReplayFaults, ReplayMappingOverride.

Outputs: ReplayClockTick, ReplayStatus, ReplayMetrics, ReplayBookmarkSaved, ReplayAlert, ReplayEvalSample, ReplayEvalReport.

Helpers: DatasetReader (jsonl/csv/parquet), StreamMapper (fromâ†’to dÃ¶nÃ¼ÅŸtÃ¼rme), Clock, RingBuffer, Rng, FaultInjector, Bookmark, Indexer (timeâ†’offset), EvalJoiner (oracleâ†”observed).

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸlarda runtime validasyon; tarih alanlarÄ± ISO, sayÄ±lar finite().

Event Bus KonularÄ±

In: replay.manifest, replay.control, replay.faults, replay.mapping.override

Out: canlÄ± veri (market.refs, funding.snapshot, â€¦), replay.clock.tick, replay.status, replay.metrics, replay.bookmark.saved, replay.eval.sample, replay.eval.report, replay.alert

Konfig & VarsayÄ±lanlar
{
  io: { readBatchSize: 5000, prefetchSec: 5, maxBufferEvents: 20000 },
  speed: { default: 1, allowed: [0.25,0.5,1,2,5,10,"bar"] },
  clock: { tickMs: 200, catchUpPct: 0.25 },            // lag varsa hÄ±zlandÄ±ÄŸÄ± oran
  filterDefaults: { symbols: [], topics: [] },         // boÅŸ = hepsi
  faults: { dropProb: 0, dupProb: 0, reorderProb: 0, reorderJitterMs: 0, latencyJitterMs: 0, outages: [] },
  eval: { joinKey: "tradeId", allowTimeSkewMs: 1500, slipToleranceBps: 2, rTolerance: 0.05 },
  seed: "vivo34-replay",
  metricsFlushSec: 5,
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

ReplayState (in-memory + periyodik persist data/replay.state.json):

datasetId, manifest, cursorTs, startTs, endTs, state (idle/loaded/running/paused/stopped),

filters, speed, clockMode, rng(seed), buffer (min-heap/zaman sÄ±ralÄ±),

indexers (sourceâ†’timeâ†’offset), bookmarks (idâ†’{cursor,seed,filters}),

faults, outageWindows, lastMetrics, progress.

Idempotency: eventHash ile rewind/seek sonrasÄ± aynÄ± olay ikinci kez yayÄ±nlanmaz (opsiyon).

AkÄ±ÅŸ DÃ¶nÃ¼ÅŸÃ¼mÃ¼ (OutMap)

market.bar â†’ market.refs:
mid = (open+high+low+close)/4, spreadBps â‰ˆ clamp((high-low)/mid*1e4, 0, 200), volZScore yoksa null/0.
bestBid/Ask opsiyonel: mid Â± spread/2.

market.aggTrade â†’ market.trade.tick: alan eÅŸle.

funding.snapshot zaten hedef formatta.

MappingOverride ile tÃ¼rev alanlar deÄŸiÅŸtirilebilir (Ã¶rn. spread hesap yÃ¶ntemi).

Algoritma (Karar AkÄ±ÅŸÄ±)

Manifest YÃ¼kle & Ä°ndeksle

replay.manifest â†’ Zod doÄŸrula; her kaynak iÃ§in hafif index (timestamp â†’ byte offset) oluÅŸtur veya mevcut indexâ€™i yÃ¼kle.

outMap doÄŸrula; bilinmeyen fromâ†’to iÃ§in replay.alert(error,"unknown_map").

HazÄ±rla (load)

replay.control(cmd=load) â†’ Readerâ€™lar aÃ§Ä±lÄ±r, state="loaded", cursor=start.

filters uygulanÄ±r; replay.status yayÄ±nla.

Ã‡alÄ±ÅŸtÄ±r (start/resume)

Saat modu wall: her tickMsâ€™de clock.tick ve cursor ile now arasÄ±nda kalan olaylarÄ± oku â†’ bufferâ€™a koy.

bar_close: bir sonraki bar kapanÄ±ÅŸ timestampâ€™ine atla; aradaki olaylarÄ± toplu yayÄ±nla.

Prefetch: prefetchSec kadar ileri olaylarÄ± Ã¶nceden bufferâ€™a al.

Fault Enjeksiyonu

Her event, FaultInjectorâ€™dan geÃ§er:

dropProb â†’ dÃ¼ÅŸÃ¼r,

dupProb â†’ aynÄ± eventâ€™i ikinci kez sÄ±raya koy,

reorderProb â†’ reorderJitterMs kadar rasgele gecikmeyle sÄ±rayÄ± boz,

latencyJitterMs â†’ yayÄ±m Ã¶ncesi beklet,

outages â†’ belirli pencerelerde/topiklerde event bastÄ±r.

SayacÄ± gÃ¼ncelle (drops/dups/reorders/outages).

YayÄ±n

Bufferâ€™daki zamanÄ± gelen olaylarÄ± outMap.to konularÄ±nda yayÄ±nla.

Her adÄ±mda replay.clock.tick ve per metricsFlushSec replay.metrics.

Kontroller

pause â†’ saat durur, buffer korunur; resume â†’ devam.

seek(ts) â†’ tÃ¼m readerâ€™lar index ile tsâ€™e sarÄ±lÄ±r; buffer temizlenir.

speed(x) â†’ hÄ±z Ã§arpanÄ± deÄŸiÅŸir; catchUpPct ile lag varsa bir sÃ¼re yÃ¼ksek hÄ±z uygula.

bookmark(id) â†’ {cursor,seed,filters} kaydet; restore(id) â†’ aynÄ± noktaya/seedâ€™e geri.

DeÄŸerlendirme (Oracle)

Sistem alt modÃ¼lleri koÅŸarken, vivo.logger veya trade.summary.closed Ã§Ä±ktÄ±larÄ±nÄ± dinle (observed).

Oracle groundTruth.trades/pnl dosyalarÄ±yla joinKey veya zaman+sembol yakÄ±nlÄ±ÄŸÄ±yla eÅŸle.

Her eÅŸleÅŸme iÃ§in replay.eval.sample; test sonunda replay.eval.report.

Stop/Shutdown

stop â†’ akÄ±ÅŸ biter; state="stopped".

shutdown â†’ kaynaklar kapatÄ±lÄ±r, state persist edilir.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/backtestReplayHarness.ts

src/vivo/state/replayStore.ts (manifest/state/index/bookmark persist)

src/vivo/lib/reader.ts (jsonl/csv/parquet), src/vivo/lib/fault.ts, src/vivo/lib/clock.ts, src/vivo/lib/indexer.ts, src/vivo/lib/eval.ts

__tests__/backtestReplayHarness.test.ts

Mimari

Ã‡ekirdek: advance(event, state, cfg, now) â†’ emissions[] (deterministik state machine).

IO adaptÃ¶rÃ¼: dosya okuyucular, zamanlayÄ±cÄ±, bus publish/subscribe.

Validasyon

Zod; tarih parse hatasÄ±nda replay.alert(warn,"bad_timestamp"), event drop.

Performans

20k ev/s yayÄ±n hedef; buffer ve prefetch ile I/O gizle. p99 < 5ms event enjekte dÃ¶ngÃ¼sÃ¼.

Deterministiklik

RNG seed + datasetId+cursor â†’ fault/jitter aynÄ± ÅŸekilde tekrar Ã¼retilebilmeli.

GÃ¼n Sonu

Metrik sayaÃ§larÄ±nÄ± Europe/Istanbul gÃ¼n sonunda sÄ±fÄ±rla (replay bitmiyorsa rulover).

Test Ä°skeleti (Jest)

loadâ†’startâ†’pauseâ†’resumeâ†’stop durum geÃ§iÅŸleri.

seek doÄŸru Ã§alÄ±ÅŸÄ±r; cursor ve buffer resetlenir.

speed 5Ã— â†’ eventsOutPerSec artar; bar modunda sadece bar kapanÄ±ÅŸlarÄ±nda ilerler.

faults.dropProb=0.1 â†’ drops sayacÄ± ~%10 civarÄ±.

reorderProb>0 â†’ zaman sÄ±rasÄ±na aykÄ±rÄ± yayÄ±nlar histerezisle dÃ¼zeltilir (buffer toleransÄ±).

bookmark/restore deterministiktir (aynÄ± seed â†’ aynÄ± sÄ±ralama).

eval join doÄŸru; tolerans altÄ±nda farklar match sayÄ±lÄ±r.

outage window iÃ§inde ilgili topicâ€™ler susar; sonra normale dÃ¶ner.

mapping.override ile spread formÃ¼lÃ¼ deÄŸiÅŸir.

Ã–rnek Senaryo (Ã–zet)

Manifest

bars_M5.jsonl (2025-05-01 08:00 â†’ 2025-05-01 12:00), aggTrades.jsonl, funding_8h.jsonl.

outMap: market.bar â†’ market.refs.

Kontroller

load(datasetId="session-avax-0501") â†’ start(speed=2Ã—, filters.symbols=["AVAXUSDT"]).

30 dk sonra faults: reorderProb=0.1, reorderJitterMs=120, latencyJitterMs=25.

09:30 iÃ§in bookmark("b1"). 10:10â€™da pause, seek(09:45), resume.

BitiÅŸte stop ve rapor.

Beklenen YayÄ±nlar

AkÄ±ÅŸ boyunca market.refs ve funding.snapshot olaylarÄ± akar; replay.clock.tick ve replay.metrics dÃ¼zenli gelir.

Sonunda:

{
  "event":"replay.eval.report",
  "datasetId":"session-avax-0501",
  "summary":{"samples":124,"hitAcc":0.92,"rMse":0.07,"slipMse":2.3,"winRateExp":{"expected":0.55,"observed":0.53},"profitFactor":{"expected":1.42,"observed":1.37}},
  "bySymbol":[{"symbol":"AVAXUSDT","samples":124,"deltaWinRate":-0.02,"deltaPF":-0.05}]
}

Entegrasyon NotlarÄ±

GerÃ§ek borsa yok: Sentry/Guard/Policy modÃ¼lleri bu akÄ±ÅŸta canlÄ± sanÄ±r; harness gerekli replay.clock.tick/connectivity.heartbeat sinyallerini saÄŸlayabilir.

VIVO-22 Loggerâ€™Ä±n trade.summary.closed Ã§Ä±ktÄ±larÄ± observed olarak yakalanÄ±r; oracle dosyalarÄ±yla kÄ±yaslanÄ±r.

VIVO-26/27â€™de fault/outage sinyalleri doÄŸal tetiklenir; SLO/telemetri Ã¶lÃ§Ã¼mleri VIVO-32 ile gÃ¶rÃ¼lebilir.

Performans/Ã¶lÃ§ek: Ã‡ok dosyalÄ± evrende sembol baÅŸÄ±na worker (opsiyonel) ama karar sÄ±rayÄ± bozmadan birleÅŸik saatle yayÄ±n.
_________________________________________________________________________________________________________________
VIVO-35 Â· dataRetentionAndPrivacyManager.ts â€” GeliÅŸmiÅŸ Prompt v3 (AIâ€™ye verilecek kodlama yol-promptu)
AmaÃ§

Log/veri saklama kurallarÄ±nÄ± merkezÃ® yÃ¶neten, PII temizliÄŸi/anonimleÅŸtirme/maskeleme yapan, ihracat (export) ve silme (erasure) taleplerini iÅŸleyen gizlilik katmanÄ±.

Kategori-bazlÄ± saklama sÃ¼releri, data lineage & tag ile uygun silme/erken-redaksiyon; ÅŸifreleme/pseudonymization; denetim izi.

VIVO-22 Logger, VIVO-32 Telemetry, VIVO-33 Bridge dahil tÃ¼m Ã¼reticilerin log/metrik olaylarÄ±nÄ± privacy-aware hale getirir.

Bu modÃ¼l yalnÄ±zca veri yaÅŸam dÃ¶ngÃ¼sÃ¼nÃ¼ yÃ¶netir; ticaret/risk kararlarÄ±na dokunmaz.

Veri SÄ±nÄ±flandÄ±rma (dahili taksonomi)

PUBLIC: herkese aÃ§Ä±k; kimlik iÃ§ermez (Ã¶rn. aggregate metrik).

SENSITIVE_LOW: sÄ±nÄ±rlÄ± kimlik ipuÃ§larÄ± (Ã¶rn. kullanÄ±cÄ± takma adlarÄ±, chat id).

PII_BASIC: e-posta, telefon, kullanÄ±cÄ± id, IP.

PII_STRICT: ulusal kimlik no, tam ad + doÄŸum, adres.

FINANCIAL: hesap/iban, cÃ¼zdan adresi.

SECRET: API key/token (Ã§Ä±ktÄ±larda asla gÃ¶sterme).

Olaylar data.tags.classification ile etiketlenir; yoksa varsayÄ±lan konservatif politika uygulanÄ±r.

Girdiler (Event / JSON ÅemalarÄ±)
// privacy.policy.update â€” saklama & maskeleme kurallarÄ±
{
  "event": "privacy.policy.update",
  "timestamp": "iso8601",
  "version": "number",
  "retention": {
    "PUBLIC": "P365D",
    "SENSITIVE_LOW": "P180D",
    "PII_BASIC": "P90D",
    "PII_STRICT": "P30D",
    "FINANCIAL": "P180D",
    "SECRET": "P0D"
  },
  "masking": {
    "PII_BASIC": {"email":"mask","phone":"mask","ip":"truncate"},
    "PII_STRICT": {"id":"hash","address":"drop"},
    "SECRET": {"api_key":"drop","token":"drop"}
  },
  "encryption": {
    "atRest": true,
    "keyAlias": "kms:vivo35-rotating",
    "rotateDays": 90
  },
  "redaction": {
    "telemetry": {"fields":["user","email","ip"], "mode":"hash"},
    "alerts": {"fields":["email","phone"], "mode":"mask"}
  },
  "defaults": {"classification":"SENSITIVE_LOW"}
}

// data.ingest â€” tÃ¼m modÃ¼llerin gÃ¶nderdiÄŸi **ham** kayÄ±t (VIVO-22 Ã¶ncesi/sonrasÄ±)
{
  "event": "data.ingest",
  "timestamp": "iso8601",
  "source": "logger|telemetry|bridge|sentry|guard|composer|custom",
  "topic": "string",
  "payload": { "any": "json" },
  "data": {
    "tags": {
      "classification": "PUBLIC|SENSITIVE_LOW|PII_BASIC|PII_STRICT|FINANCIAL|SECRET",
      "subjectId": "string|null",           // kiÅŸi/kurum kimliÄŸi (pseudonymizable)
      "region": "TR|EU|US|...",
      "ttlOverride": "duration|null"        // Ã¶r. "P14D" (yalnÄ±z yÃ¼kseltici olabilir)
    }
  },
  "audit": {"producer":"service-name","eventId":"string"}
}

// data.tagging â€” yukarÄ± akÄ±ÅŸtan gelen ek etiket
{
  "event": "data.tagging",
  "timestamp": "iso8601",
  "eventId": "string",
  "add": {"classification":"...", "subjectId":"...", "labels":["string"]}
}

// privacy.scan.request â€” PII saptama taramasÄ±
{
  "event": "privacy.scan.request",
  "timestamp": "iso8601",
  "scope": {"since":"iso8601","until":"iso8601","sources":["logger","telemetry"],"topics":["*"]},
  "detectors": ["email","phone","ip","national_id","iban","api_key"]
}

// data.subject.request â€” ihracat/silme (DSR)
{
  "event": "data.subject.request",
  "timestamp": "iso8601",
  "requestId": "string",
  "type": "export|erasure|access",
  "subjectId": "string",
  "identityProof": {"method":"signed_token|email_match|manual","evidence":"string"},
  "window": {"since":"iso8601|null","until":"iso8601|null"},
  "delivery": {"format":"jsonl|zip","target":"s3://bucket/prefix|file:///..."}
}

Ã‡Ä±ktÄ±lar (Normalize edilmiÅŸ veri, redaksiyon, silme raporlarÄ±)
// data.normalized â€” maskeleme/pseudonymization uygulanmÄ±ÅŸ Ã§Ä±ktÄ± (downstreamâ€™e)
{
  "event": "data.normalized",
  "timestamp": "iso8601",
  "source": "string",
  "topic": "string",
  "payload": { "sanitized": "json" },
  "data": {
    "tags": {"classification":"string","subjectIdHash":"string|null","labels":["string"]},
    "retention": {"expiresAt":"iso8601","policyVersion":"number"}
  },
  "audit": {"fromEventId":"string","maskActions":["drop:token","mask:email","hash:id"]}
}

// privacy.scan.result â€” PII bulgularÄ±
{
  "event": "privacy.scan.result",
  "timestamp": "iso8601",
  "scope": {"since":"iso8601","until":"iso8601"},
  "summary": {"recordsScanned":"number","findings":"number"},
  "byType": [{"type":"email","count":"number"},{"type":"api_key","count":"number"}],
  "recommendations": ["rotate_keys","tighten_masks"]
}

// retention.sweep.report â€” periyodik silme/redaksiyon raporu
{
  "event": "retention.sweep.report",
  "timestamp": "iso8601",
  "policyVersion": "number",
  "deleted": {"records":"number","bytes":"number"},
  "redacted": {"records":"number","bytes":"number"},
  "skipped": {"records":"number","reason":"string"}
}

// data.subject.receipt â€” DSR onayÄ±
{
  "event": "data.subject.receipt",
  "timestamp": "iso8601",
  "requestId": "string",
  "type": "export|erasure|access",
  "status": "accepted|rejected|completed|failed",
  "link": "string|null",           // export paketi yolu
  "hash": "string|null",
  "reason": "string|null"
}

// privacy.alert & metrics
{
  "event": "privacy.alert",
  "timestamp": "iso8601",
  "level": "info|warn|error",
  "message": "string",
  "context": {"eventId":"string|null","reasonCodes":["string"]}
}
{
  "event": "privacy.metrics",
  "timestamp": "iso8601",
  "throughput": "number",
  "piiDetectedRate": "number",
  "drops": "number",
  "redactions": "number",
  "exports": "number",
  "erasures": "number",
  "errors": "number"
}

TypeScript ArayÃ¼zleri (Ã¼rettir)

Inputs: PrivacyPolicyUpdate, DataIngest, DataTagging, PrivacyScanRequest, DataSubjectRequest.

Outputs: DataNormalized, PrivacyScanResult, RetentionSweepReport, DataSubjectReceipt, PrivacyAlert, PrivacyMetrics.

Helpers:
Classifier (rules + default), Masker (mask/drop/hash/truncate), Hasher (salted HMAC-SHA256; key alias),
RetentionIndex (expiresAt hesap), Vault (encrypt/decrypt; key rotation),
Scanner (regex/dictionary for email/phone/ip/national_id/iban/api_key),
ExportBuilder (streamâ†’JSONL/ZIP), Eraser (tombstone + secure delete),
Lineage (eventIdâ†’origin), DSRValidator (identity proof).

Zod ile tÃ¼m giriÅŸ/Ã§Ä±kÄ±ÅŸta runtime validasyon; sayÄ±lar finite(); tarih ISO.

Event Bus KonularÄ±

In: privacy.policy.update, data.ingest, data.tagging, privacy.scan.request, data.subject.request

Out: data.normalized, privacy.scan.result, retention.sweep.report, data.subject.receipt, privacy.alert, privacy.metrics

Konfig & VarsayÄ±lanlar
{
  // SÃ¼reler (ISO-8601)
  defaultRetention: "P180D",
  sweep: { intervalMin: 30, batchRecords: 5000 },
  export: { tmpDir: "data/exports", maxRecords: 5_000_000, partSizeMB: 64, zip: true },
  hash: { algo: "HMAC-SHA256", saltAlias: "kms:vivo35-rotating", subjectIdPepperEnv: "SUBJECT_PEPPER" },
  scan: { maxRatePerSec: 2000, detectors: ["email","phone","ip","national_id","iban","api_key"] },
  masking: { email: "a***@***.tld", phone: "***-****", ipTruncate: "/24" },
  security: { encryptAtRest: true, keyAlias: "kms:vivo35-rotating", allowDecryptionInExport: false },
  audit: { keepExportsD: 30, keepReceiptsD: 365 },
  tz: "Europe/Istanbul"
}

Durum YÃ¶netimi

PrivacyState (in-memory + periyodik persist data/privacy.state.json):

policyVersion, retentionMap, maskingRules, keyMeta{alias,rotatedAt},

lineageIndex (eventIdâ†’storageRef), retentionIndex (expiresAtâ†’refs),

subjectMap (subjectIdHashâ†’refs count), pendingDSR (requestIdâ†’status),

stats (throughput, drops, redactions, exports, erasures, errors).

Idempotency: aynÄ± eventId ikinci kez gelirse yut (hash/eTag); aynÄ± requestId tekrar Ã§alÄ±ÅŸtÄ±rÄ±lmaz.

Algoritma (Karar AkÄ±ÅŸÄ±)

Politika YÃ¼kle

privacy.policy.update â†’ doÄŸrula, version++, mask/retention/encryption/redaction tablolarÄ±nÄ± gÃ¼ncelle.

Key rotasyon tarihi geldiyse Vault.rotate(); eski anahtarlarla ÅŸifrelenmiÅŸ kayÄ±tlara read-compatible.

Ingest â†’ Normalize

data.ingest geldiÄŸinde:

SÄ±nÄ±flandÄ±rma = data.tags.classification || defaults.classification.

Masker uygula: drop/mask/hash/truncate.

subjectIdHash = HMAC(subjectId + pepper); plaintext subjectId tutma.

payloadu (gerekirse) encrypt-at-rest; storageRef Ã¼ret.

expiresAt = now + retention[classification] (ttlOverride sadece kÄ±saltabilir).

data.normalized yayÄ±nla (downstream tÃ¼ketir).

RetentionIndex ve Lineage gÃ¼ncelle.

Ek Etiketleme

data.tagging iÃ§in eventId bulunur â†’ etiket/subjectIdHash gÃ¼ncellenir; gerekiyorsa retention daraltÄ±lÄ±r.

Periyodik SÃ¼pÃ¼rme (Sweep)

Her sweep.intervalMin:

expiresAt â‰¤ now kayÄ±tlarÄ±nÄ± secure delete (Eraser):

encrypt-at-rest ise anahtarÄ± dÃ¶ndÃ¼rme + tombstone (geri dÃ¶nÃ¼ÅŸÃ¼ olmayan).

Telemetryâ€™ye retention.sweep.report.

Redaction-on-retain: SECRET alanlar derhal drop; PII_STRICT iÃ§eriÄŸi erken mask.

Tarama (Scan)

privacy.scan.request â†’ Scanner ile seÃ§ili kapsamda PII/SECRET tespit; privacy.scan.result yayÄ±nla.

api_key tespiti â†’ privacy.alert(error,"secret_leak") + key rotate Ã¶ner.

DSR (Export/Erasure/Access)

DSRValidator ile identityProof doÄŸrula (token/ eÅŸleÅŸen email/manuel).

Export: subjectIdHash eÅŸleÅŸen kayÄ±tlarÄ± maskeli biÃ§imde topla â†’ export package yaz â†’ data.subject.receipt(status="completed", link, hash).

Erasure: aynÄ± kapsamda kayÄ±tlarÄ± tombstone + secure delete â†’ receipt(completed).

Access: export ile aynÄ±; ancak salt/anahtar aÃ§Ä±lmadan maskeli dÃ¶ner (de-identify).

Redaksiyon KurallarÄ± (AnÄ±nda)

telemetry/alerts kanallarÄ±na giden olaylar iÃ§in redaction.* kurallarÄ± uygulanÄ±r (Ã¶rn. emailâ†’hash).

VIVO-32â€™ye aktarÄ±lan seriler kimliksiz kalÄ±r.

Hata & Telemetri

Åema/NaN/uygunsuz deÄŸer â†’ olay drop + privacy.alert(warn,"invalid_payload").

10 snâ€™de bir privacy.metrics.

GerÃ§ek DÃ¼nya KurallarÄ± (Uyum)

Minimize et, gerekliyse tut: Sadece gerekli alanlarÄ± tut; SECRET asla persist etme.

TTL kÄ±saltÄ±labilir, uzatÄ±lamaz (policy dÄ±ÅŸÄ±na taÅŸma yok).

Exportâ€™ta varsayÄ±lan maskeli/pseudonymized Ã§Ä±ktÄ±; tam aÃ§Ä±lÄ±m sadece hukuki zorunlulukta ve onaylÄ± anahtar ile (config allowDecryptionInExport=false).

SubjectId hiÃ§bir zaman dÃ¼z metin olarak yazÄ±lmaz; sadece hash (HMAC).

Right-to-be-forgotten: silme tamamlandÄ±ÄŸÄ±nda tÃ¼m indeksler temizlenir; downstream yeniden Ã¼retilemez.

Kodlama YÃ¶nlendirmesi

Dosya YapÄ±sÄ±

src/vivo/dataRetentionAndPrivacyManager.ts

src/vivo/state/privacyStore.ts (policy+index+dsr+stats persist)

src/vivo/lib/mask.ts, src/vivo/lib/hash.ts, src/vivo/lib/vault.ts, src/vivo/lib/scan.ts, src/vivo/lib/export.ts, src/vivo/lib/erase.ts

__tests__/dataRetentionAndPrivacyManager.test.ts

Mimari

Ã‡ekirdek: ingest(event, state, cfg) â†’ emissions[], sweep(now), handleDSR(req).

IO adaptÃ¶rÃ¼: storage (append-only + tombstone), kms/vault arayÃ¼zÃ¼, event bus pub/sub.

Validasyon

Zod; classification enum, duration ISO-8601, subjectId boÅŸsa hash alanÄ± null.

Performans

p99 ingest < 5ms, sweep batch I/O ardÄ±ÅŸÄ±k, export streaming (back-pressure).

GÃ¼venlik

KMS hata/baÄŸlantÄ± sorununda fail-secure: ingest drop + alert(error) (PIIâ€™yi ÅŸifresiz yazma!).

Test Ä°skeleti (Jest)

ingest(PERSONAL) â†’ mask/hash uygulanÄ±r, expiresAt doÄŸru

ttlOverride uzatma denemesi â†’ reddedilir

SECRET alan iÃ§eren kayÄ±t â†’ drop + privacy.alert(error)

scan(api_key) â†’ findings > 0, rotate Ã¶nerisi

sweep â†’ vadesi dolan kayÄ±tlar silinir, report sayÄ±larÄ± tutar

DSR export (subjectId) â†’ paket Ã¼retilir, link/hash yayÄ±nlanÄ±r

DSR erasure â†’ tÃ¼m referanslar tombstone edilir

redaction.telemetry â†’ email/phone hashlenir

idempotent eventId â†’ ikinci ingest yok

Ã–rnek Senaryo (Ã–zet)

Girdiler

privacy.policy.update(version=7) â†’ PII_STRICT: P30D, SECRET: P0D, redaction.telemetry {email,ip}=hash.

data.ingest (source=bridge, topic=incident.open): payloadâ€™da email ve telegramUserId var; classification PII_BASIC, subjectId="user:1234".

privacy.scan.request(since=âˆ’24h) (detectors: api_key,email).

data.subject.request(type="export", subjectId="user:1234").

Beklenen Ã‡Ä±ktÄ±lar

{
  "event":"data.normalized",
  "data":{"tags":{"classification":"PII_BASIC","subjectIdHash":"HMAC(...)"}, "retention":{"expiresAt":"...+P90D","policyVersion":7}},
  "audit":{"maskActions":["mask:email","hash:subjectId"]}
}

{"event":"privacy.scan.result","summary":{"recordsScanned":12045,"findings":3},"byType":[{"type":"email","count":3}],"recommendations":["tighten_masks"]}

{"event":"data.subject.receipt","requestId":"DSR-88","type":"export","status":"completed","link":"file:///data/exports/DSR-88.zip","hash":"sha256:..."}


30 gÃ¼n sonra retention.sweep.report silinen PII_STRICT kayÄ±tlarÄ±nÄ± raporlar.

Entegrasyon NotlarÄ±

VIVO-22 Logger: data.normalizedâ€™Ä± esas alarak kalÄ±cÄ± depoya yazar; ham data.ingestâ€™i tutmaz.

VIVO-32 Telemetry: redaction.telemetry kurallarÄ±nÄ± uygular; kiÅŸi alanlarÄ±nÄ± kimliksiz raporlar.

VIVO-33 Bridge: bildirim gÃ¶vdeleri redaction.alerts ile maskeleme yapar.

PolicyCoordinator (VIVO-29): gizlilik politikasÄ± deÄŸiÅŸimlerini privacy.policy.update olarak yayÄ±nlayabilir.
_________________________________________________________________________________________________________________
VIVO â€” Yeni ModÃ¼ller (Ek Blok)

AÅŸaÄŸÄ±daki 8 modÃ¼l, mevcut mimariye ek olacak ÅŸekilde numaralandÄ±rÄ±lmÄ±ÅŸtÄ±r.
Dosya adlarÄ± src/vivo/*.ts; testler __tests__/*.test.ts.

VIVO-36 Â· planSafetyNet.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

OperatÃ¶r onayÄ± + bracket kurulumundan ilk 60â€“180 saniye iÃ§inde negatif mark-out ve/veya aÅŸÄ±rÄ± slip gÃ¶rÃ¼lÃ¼rse trim/cancel/tighten aksiyonlarÄ±yla erken kaybÄ± sÄ±nÄ±rlamak.

Girdiler (In)

order.bracket.ready: { correlationId, symbol, side, qty, slOrderId, tpOrderIds[], variant }

trade.markout.tick: { correlationId, dtSecFromEntry, markOutBps, slipBps, mid, spreadBps }

order.update, supervisor.state, policy.snapshot (eÅŸikler), latency_slip.guard.directive

Ã‡Ä±ktÄ±lar (Out)

plan.safety.action: { correlationId, action: "none|trim|cancel_all|tighten_sl", params:{trimPct?|newSL?|note}, reasonCodes[], audit{} }

plan.safety.metrics: { windowSec, worstMarkOutBps, maxSlipBps, actions{...} }

Konfig
{
  windowSec: { min: 60, max: 180 },
  thresholds: { markOutWarnBps: -6, markOutCutBps: -12, slipCutBps: 15 },
  trim: { pct: 0.33, minQty: 0.001 },
  tightenSL: { addTightenBps: 6, maxTimes: 2 },
  cooldownMin: 5,
  idempotencyTtlSec: 300,
  tz: "Europe/Istanbul"
}

Algoritma

order.bracket.ready â†’ watch window baÅŸlat; idempotency anahtarÄ± = correlationId.

Pencere iÃ§inde en kÃ¶tÃ¼ markOutBps ve slipBpsâ€™i izleyin.

Kurallar:

markOut â‰¤ markOutCutBps â†’ cancel_all (reduce-only).

markOut â‰¤ markOutWarnBps â†’ trim(pct); bir kez.

slipBps â‰¥ slipCutBps â†’ tighten_sl(+addTightenBps); maxTimese kadar.

guard.directive in ["halt_entry","streams_panic"] â†’ aksiyonlarÄ± ertele, sadece tighten_sl izinli.

TÃ¼m aksiyonlar idempotent (aynÄ± baÄŸlamâ†’tek yayÄ±n). Pencere bitince metrics yayÄ±nla.

TypeScript ArayÃ¼zleri

BracketReady, MarkoutTick, PlanSafetyAction, PlanSafetyMetrics.

Event Bus

In: order.bracket.ready, trade.markout.tick, order.update, latency_slip.guard.directive, policy.snapshot

Out: plan.safety.action, plan.safety.metrics

Kodlama YÃ¶nlendirmesi

Ã‡ekirdek FSM: advance(state, event, cfg) â†’ emissions[].
SL/TP deÄŸiÅŸimiyle Ã§akÄ±ÅŸmalarÄ± supervisor.state ile Ã§Ã¶z; reduce-only emir Ã¼retimini Composer/Executor yapar.

Test Ä°skeleti

markOut -13bps@90s â†’ cancel_all

markOut -8bps@45s â†’ trim once

slip 17bps â†’ tighten_sl, maxTimes sÄ±nÄ±rÄ±

guard=halt_entry â†’ sadece tighten

Entegrasyon

VIVO-21 (Supervisor) & VIVO-19 (Composer) ile aksiyon paylaÅŸÄ±mÄ±; VIVO-26 slip guard eÅŸikleriyle tutarlÄ±lÄ±k.
_________________________________________________________________________________________________________________
VIVO-37 Â· scenarioPlaybookBinder.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

Rejim/news/liquidity etiketlerini uygun plan ÅŸablonlarÄ±na baÄŸlayÄ±p VIVO-19â€™a varyant + exec style Ã¶nerisi Ã¼retmek.

Girdiler

gb.regime.snapshot: { symbol, timeframe, tags:["highVol","range","trend","newsWindow","thinLiq"] }

qa.tags: { tags:["open-bar","highVol","gap-open", ...] }

playbook.catalog: { id, variant, exec: "market|limit|twap|iceberg", params{}, guards{} }

Ã‡Ä±ktÄ±lar

composition.playbook.choice: { symbol, timeframe, playbookId, variant, exec, params, constraints, reasonCodes[] }

Konfig
{
  matrix: {
    "newsWindow": { variant:"conservative", exec:"twap", constraints:{postOnly:true} },
    "highVol":    { variant:"conservative", exec:"limit", params:{offsetBps:5} },
    "thinLiq":    { exec:"iceberg", params:{displayPct:0.2} },
    "trend":      { variant:"base" },
    "range":      { variant:"conservative" }
  },
  fallback: { variant:"base", exec:"limit" },
  tz: "Europe/Istanbul"
}

Algoritma

Rejim/QA tagâ€™lerini Ã¶ncelik sÄ±rasÄ±na gÃ¶re eÅŸle.

UyuÅŸan playbook yoksa fallback.

Policy/Guard kÄ±sÄ±tlarÄ±yla son Ã¶neriyi clamp et (Ã¶r. aggressive kapalÄ±ysa dÃ¼ÅŸÃ¼r).

ArayÃ¼zler & Bus

In: gb.regime.snapshot, qa.tags, playbook.catalog, policy.snapshot, guard.directive

Out: composition.playbook.choice

Testler

newsWindow+highVol â†’ twap+conservative

aggressive kapalÄ± â†’ conservativeâ€™a dÃ¼ÅŸÃ¼r
_________________________________________________________________________________________________________________
VIVO-38 Â· operatorConsistencyScore.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

OperatÃ¶r seÃ§imlerinin tutarlÄ±lÄ±k & sonuÃ§ skorunu hesaplayÄ±p Ã¶neri sÄ±ralamasÄ± ve soru derinliÄŸi iÃ§in sinyal Ã¼retmek.

Girdiler

operator.choice.log: { when, symbol, decision, overrides[], context{} }

vivo.feedback.raw, trade.summary.closed

Ã‡Ä±ktÄ±lar

operator.consistency.score: { score0to1, horizonDays, strengthTags[], explanations[] }

Konfig
{
  horizonDays: 30,
  weights: { hit:0.4, expectancy:0.3, discipline:0.2, latency:0.1 },
  decayHalfLifeDays: 7,
  thresholds: { low:0.4, high:0.7 }
}

Algoritma

30 gÃ¼nlÃ¼k pencere; EWMA ile hit/expectancy/discipline(latency & rule-break).

Skoru 0..1 normalize; low/high eÅŸiklerine gÃ¶re tagâ€™ler.

low ise operatorDialog iÃ§in ek soru bayraÄŸÄ±.

Bus

In: operator.choice.log, vivo.feedback.raw, trade.summary.closed

Out: operator.consistency.score

Testler

disiplin bozuldukÃ§a skorâ†“

son 7 gÃ¼nde iyileÅŸme â†’ skorâ†‘ (decay etkisi)
_________________________________________________________________________________________________________________
VIVO-39 Â· cashRunwayAdvisor.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

Spot/nakit akÄ±ÅŸÄ±nÄ± haftalÄ±k/aylÄ±k planla; %30 spot payÄ± hedefi, Ã§ekme/yatÄ±rma/transfer tavsiyeleri Ã¼ret.

Girdiler

account.cashflow: { inflowUSD, outflowUSD, recurring[], holdings{spotUSD, futuresUSD} }

portfolio.exposure: { totalRiskPct, leverage, ddFromPeak }

daily.kpis: { pf, winRate, avgR }, policy.snapshot

Ã‡Ä±ktÄ±lar

cash.runway.plan: { horizonDays, minUSD, actions:[{type:"topup|withdraw|rebalance", amountUSD, when}] , notes[] }

Konfig
{
  targetSpotPct: 0.30,
  minRunwayDays: 30,
  ddGuardPct: 15,
  pfFloor: 1.25,
  bufferUSD: 500,
  tz: "Europe/Istanbul"
}

Algoritma

Runway = (spotUSD + netInflowNext30d) / avgDailyOutflow.

< minRunwayDays â†’ topup Ã¶ner; ddFromPeak > ddGuard â†’ risk azalt.

Spot payÄ± %30â€™dan sapmÄ±ÅŸsa rebalance planÄ± Ã¼ret.

Bus

In: account.cashflow, portfolio.exposure, daily.kpis, policy.snapshot

Out: cash.runway.plan

Testler

runway 18g â†’ topup + rebalance

PF<1.25 â†’ daha muhafazakÃ¢r Ã¶neriler
_________________________________________________________________________________________________________________
VIVO-40 Â· dominanceShiftWatcher.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

BTC/ETH dominans kaymalarÄ±nÄ± ve beta rejimini izleyip varyant/simge aÄŸÄ±rlÄ±k Ã¶nerisi Ã§Ä±karmak.

Girdiler

market.dominance: { btcD, ethD, zScores{btcD,ethD} }

portfolio.correlation: { topPairs[], betaByCluster{} }

universe.snapshot

Ã‡Ä±ktÄ±lar

dominance.shift.signal: { regime:"btc-led|alt-led|neutral", suggest:{ variant?, reduceCluster?:{Layer1:number} }, reasonCodes[] }

Konfig
{
  zThr: { shift: 1.2, strong: 2.0 },
  hysteresis: 0.3,
  maxReducePerStep: 0.2
}

Algoritma

z(btcD)-z(ethD) farkÄ± â†’ rejim.

â‰¥ strong â†’ aggressive kapat, conservative Ã¶ner; Layer1 riskini maxReducePerStep kadar azalt.

Histerezis ile flip-flop engelle.

Bus

In: market.dominance, portfolio.correlation, universe.snapshot

Out: dominance.shift.signal

Testler

fark 2.1 â†’ alt-led; reduce Layer1 20%

geri dÃ¶nÃ¼ÅŸte histerezis Ã§alÄ±ÅŸÄ±r
_________________________________________________________________________________________________________________
VIVO-41 Â· strategyStabilityScore.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

Stratejiler iÃ§in istikrar skoru; Bandit/Composer iÃ§in dÃ¼ÅŸÃ¼k istikrarÄ± iÅŸaretle.

Girdiler

Son N Ã¶rnekten vivo.feedback.raw, trade.summary.closed

Ã‡Ä±ktÄ±lar

strategy.stability.scores: [ { arm, score0to1, samples, flags:["volatile|stable"], notes[] } ]

Konfig
{
  windowTrades: 50,
  weights: { stdR:0.4, winVar:0.3, slipVar:0.2, durationVar:0.1 },
  thresholds: { volatile: 0.35, stable: 0.7 }
}

Algoritma

Normalize varyans Ã¶lÃ§Ã¼leri â†’ 0..1 ters skor; eÅŸiklere gÃ¶re flag.

Bus

In: vivo.feedback.raw, trade.summary.closed

Out: strategy.stability.scores

Testler

yÃ¼ksek stdR â†’ skor dÃ¼ÅŸÃ¼k, volatile

Ã¶rnek sayÄ±sÄ± < window â†’ samples uyarÄ±sÄ±
_________________________________________________________________________________________________________________
VIVO-42 Â· biasWeightedSignalTuner.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

LIVIA/Ã¶znel bias aÄŸÄ±rlÄ±klarÄ±na ve QA tagâ€™lerine gÃ¶re sinyal varyantÄ±nÄ± otomatik ayarlamak.

Girdiler

livia.bias.weights: { overconfidence:0..1, lossAversion:0..1, riskSeeking:0..1 }

qa.tags, operator.consistency.score, policy.snapshot

Ã‡Ä±ktÄ±lar

signal.variant.tuned: { base:"base|aggressive|conservative", adjusted:"...", reasonCodes[] }

Konfig
{
  rules: {
    overconfidence_gt_0_6: { to:"conservative" },
    lossAversion_gt_0_7: { to:"base", clampTP:true },
    guardHighVol: { to:"conservative" }
  }
}

Algoritma

Kural tabanlÄ± dÃ¶nÃ¼ÅŸÃ¼m + policy clamp; aggressive yasaksa otomatik dÃ¼ÅŸÃ¼r.

Bus

In: livia.bias.weights, qa.tags, operator.consistency.score, policy.snapshot

Out: signal.variant.tuned

Testler

overconfidence 0.8 â†’ conservative

policy aggressive=false â†’ conservative zorunlu
_________________________________________________________________________________________________________________
VIVO-43 Â· riskToleranceVariantSelector.ts â€” GeliÅŸmiÅŸ Prompt v3
AmaÃ§

KullanÄ±cÄ±/hesap geÃ§miÅŸine gÃ¶re otomatik variant Ã¶ner (base/aggressive/conservative).

Girdiler

Son 15 iÅŸlem istatistikleri: { avgDrawdownR, maxDD_R, avgHoldMin, abortRate, hitRate, expectancyR }

policy.snapshot, operator.consistency.score

Ã‡Ä±ktÄ±lar

variant.suggestion: { suggested:"conservative|base|aggressive", confidence0to1, reasons[] }

Konfig
{
  rules: {
    highDD: { maxDD_R_gt: 3.0, to:"conservative" },
    strongEdge: { hit_gt:0.56, expR_gt:0.2, to:"aggressive" },
    slowStyle: { avgHold_gt_min:120, to:"base" }
  },
  hysteresis: { promoteAfterTrades: 10, demoteAfterTrades: 5 }
}

Algoritma

Kural eÅŸleÅŸmeleri â†’ puanlama; histerezis ile yÃ¼kseltme/dÃ¼ÅŸÃ¼rme koÅŸullarÄ±.

Bus

In: performance.window15, policy.snapshot, operator.consistency.score

Out: variant.suggestion

Testler

maxDD_R 3.4 â†’ conservative

hit 0.58 & expR 0.25 â†’ aggressive

histerezis: 1â€“2 iyi iÅŸlemde hemen yÃ¼kseltme yok

Genel Ek Notlar (bu blok iÃ§in)

Dosya yapÄ±sÄ±: her modÃ¼l iÃ§in state/*.ts (store), lib/*.ts (helpers) ve Jest testleri.

Audit & Telemetri: her aksiyonda audit alanÄ± ve *.metrics olayÄ±; p99 hedef < 5 ms.

Ã‡akÄ±ÅŸma Ã§Ã¶zÃ¼mÃ¼: Guard/Policy > Supervisor > SafetyNet sÄ±rasÄ±; idempotency hash ile Ã§ift yayÄ±n engeli.

Zamanlama: tÃ¼m sayaÃ§/sweep resetleri Europe/Istanbul gÃ¼n sonuna gÃ¶re.
_________________________________________________________________________________________________________________